# AvsP - an AviSynth editor
#
# GPo mod based on the last release from vdcrim (2.5.1)
# Modifications (Avisynth Header v6) by pinterf (pfmod)
#
# ###############
#
# Copyright 2007 Peter Jang <http://www.avisynth.org/qwerpoi>
#           2010-2015 the AvsPmod authors <https://github.com/avspmod/avspmod>
#
# Printing support based on stcprint.py from Peppy/Editra (wxWidgets license)
# Copyright 2007 Cody Precord <staff@editra.org>
#           2009 Rob McMullen <robm@users.sourceforge.net>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
#  http://www.gnu.org/copyleft/gpl.html .

# Dependencies:
#     Python (tested on v2.6 and 2.7)
#     wxPython (tested on v2.8 Unicode and 2.9)
#     cffi and its dependencies (only for x86-64, tested on v0.9.2)
#         pycparser
#         Visual C++
#     avisynth_c.h (only for x86-64, interface 5, or at least 3 + colorspaces
#                   from 5, tested with the header used by x264)
# Scripts:
#     wxp.py (general wxPython framework classes)
#     avisynth.py (Python AviSynth/AvxSynth wrapper, only for x86-32)
#     avisynth_cffi.py (Python AviSynth wrapper, only for x86-64)
#     pyavs.py (AvsP AviSynth support by loading AviSynth directly as a library)
#     pyavs_avifile.py (AvsP AviSynth support through Windows AVIFile routines)
#     icon.py (icons embedded in a Python script)
#     i18n.py (internationalization and localization)
#     global_vars.py (application info and other shared variables)

import os
import sys
import platform
import traceback
try:
    import cPickle # Python 2
except ImportError:
    import pickle as cPickle # Python 3
import shutil
import string
import array
import struct
import codecs
import re
import functools
import bisect
import random, math, copy
import subprocess, shlex
import socket
#import gc

# thread module was deprecated in python 3.
#try:
    #import thread
#except:
    #pass
import threading
from threading import Thread
import time

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO # not 100% the same, ComvertError can occur
    # Python 3: The StringIO and cStringIO modules are gone.
    # Instead, import the io module and use io.StringIO or io.BytesIO for text and data respectively.

import textwrap
import ctypes
if os.name == 'nt':
    import _winreg
    #import ctypes.wintypes
    # GPo, WndProc
    from ctypes.wintypes import HANDLE, LPVOID, LONG, WPARAM, LPARAM, UINT, DWORD
    def LOWORD(x):
        return x & 0xFFFF

    def HIWORD(x):
        return (x >> 16) & 0xFFFF

import tempfile
import zlib
import glob
# The urllib2 module has been split across several modules in Python 3 named urllib.request and urllib.error. The 2to3 tool will automatically adapt imports when converting your sources to Python 3.
try:
    import urllib2
except ImportError:
    import urllib.request

import cgi
from hashlib import md5
try:
    import __builtin__ as builtins
except ImportError:
    #The __builtin__ module was renamed to builtins in Python3.
    import builtins

import collections

if hasattr(sys,'frozen'):
    programdir = os.path.dirname(sys.executable)
    sys.path.insert(0, programdir)

import global_vars
import i18n
messages = None
def _(s):
    if messages:
        s2 = messages.get(s, s)
        if s2:
            return s2.replace(r'\n','\n')
    return s

builtins._ = _ # Python3
# Python2 only: __builtin__._ = _

encoding = sys.getfilesystemencoding()

import wx
from wx import stc
import wx.lib.buttons as wxButtons
import wx.lib.colourselect as colourselect
import wxp
import dpi
import utils
import Queue as queue

from icons import AvsP_icon, next_icon, play_icon, pause_icon, external_icon, \
                  skip_icon, spin_icon, ok_icon, smile_icon, question_icon, \
                  rectangle_icon, dragdrop_cursor

# GPo, PPI (DPI) scaling
ppi_factor = 1.0
intPPI = dpi.intPPI
roundPPI = dpi.roundPPI
tuplePPI = dpi.tuplePPI
floatPPI = dpi.floatPPI
SetFontPPI = dpi.SetFontPPI

#globals()['__debug__'] = True

# Filter database for each tab
class AvsFilterDict(collections.MutableMapping):

    def __init__(self, shared_dict=None, own_dict=None):
        self.shared_dict = shared_dict or {}
        self.own_dict = own_dict or {}

    def __getitem__(self, key):
        if key in self.own_dict:
            return self.own_dict[key]
        return self.shared_dict[key]

    def __setitem__(self, key, value):
        return self.own_dict.__setitem__(key, value)

    def __delitem__(self, key):
        return self.own_dict.__delitem__(key)

    def __len__(self, key):
        return len(self.shared_dict) + len(self.own_dict)

    def __iter__(self):
        for item in self.own_dict:
            yield item
        for item in self.shared_dict:
            yield item

# Custom styled text control for avisynth language
class AvsStyledTextCtrl(stc.StyledTextCtrl):
    (
    STC_AVS_DEFAULT, STC_AVS_COMMENT, STC_AVS_COMMENT_2, STC_AVS_ENDCOMMENT,
    STC_AVS_PREVIEWFILTER, STC_AVS_PREVIEWFILTER_END, STC_AVS_SPLITCLIP,
    STC_AVS_BLOCKCOMMENT, STC_AVS_NUMBER, STC_AVS_NUMBERBAD,
    STC_AVS_OPERATOR, STC_AVS_STRING, STC_AVS_STRINGEOL,
    STC_AVS_TRIPLE, STC_AVS_COREFILTER, STC_AVS_PLUGIN,
    STC_AVS_CLIPPROPERTY, STC_AVS_USERFUNCTION, STC_AVS_UNKNOWNFUNCTION,
    STC_AVS_USERSLIDER, STC_AVS_SCRIPTFUNCTION, STC_AVS_PARAMETER,
    STC_AVS_ASSIGN, STC_AVS_KEYWORD, STC_AVS_MISCWORD,
    STC_AVS_DATATYPE, STC_AVS_IDENTIFIER) = range(27)
    def __init__(self, parent, app, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.SIMPLE_BORDER):
        stc.StyledTextCtrl.__init__(self, parent, id, pos, size, style)
        self.app = app
        self.styleInfo = {
            self.STC_AVS_DEFAULT: ('default', ''),
            self.STC_AVS_COMMENT: ('comment', ',eol'),
            self.STC_AVS_COMMENT_2: ('comment2', ',eol'),
            self.STC_AVS_ENDCOMMENT: ('endcomment', ''),
            self.STC_AVS_PREVIEWFILTER: ('operator', ''),
            self.STC_AVS_PREVIEWFILTER_END: ('operator',''),
            self.STC_AVS_SPLITCLIP: ('operator',''),
            self.STC_AVS_BLOCKCOMMENT: ('blockcomment', ''),
            self.STC_AVS_NUMBER: ('number', ''),
            self.STC_AVS_STRING: ('string', ''),
            self.STC_AVS_TRIPLE: ('stringtriple', ''),
            self.STC_AVS_COREFILTER: ('internalfilter', ''),
            self.STC_AVS_PLUGIN: ('externalfilter', ''),
            self.STC_AVS_CLIPPROPERTY: ('clipproperty', ''),
            self.STC_AVS_USERFUNCTION: ('userdefined', ''),
            self.STC_AVS_UNKNOWNFUNCTION: ('unknownfunction', ''),
            self.STC_AVS_PARAMETER: ('parameter', ''),
            self.STC_AVS_ASSIGN: ('assignment', ''),
            self.STC_AVS_OPERATOR: ('operator', ''),
            self.STC_AVS_STRINGEOL: ('stringeol', ',eol'),
            self.STC_AVS_USERSLIDER: ('userslider', ''),

            self.STC_AVS_SCRIPTFUNCTION: ('internalfunction', ''),
            self.STC_AVS_KEYWORD: ('keyword', ''),
            self.STC_AVS_MISCWORD: ('miscword', ''),

            stc.STC_STYLE_LINENUMBER: ('linenumber', ''),
            stc.STC_STYLE_BRACELIGHT: ('bracelight', ''),
            stc.STC_STYLE_BRACEBAD: ('badbrace', ''),
            self.STC_AVS_NUMBERBAD: ('badnumber', ''),

            self.STC_AVS_DATATYPE: ('datatype', '')

        }

        self.avsfilterdict = AvsFilterDict(self.app.avsfilterdict)
        self.avsfilterdictEx = AvsFilterDict(self.app.avsfilterdictEx)
        self.avsazdict = collections.defaultdict(list)
        self.styling_refresh_needed = False
        self.SetUserOptions()
        if wx.VERSION > (2, 9):
            self.SetScrollWidth(1)
            self.SetScrollWidthTracking(True)
        self.SetEOLMode(stc.STC_EOL_LF)
        #~ self.CmdKeyClear(stc.STC_KEY_TAB,0)
        self.UsePopUp(0)
        self.showLinenumbers = 1
        #~ self.enableFolding = 1
        self.calltipFilter = None
        #self.calltiptext = None
        self.hintShown = 0
        self.calltipOpenpos = None
        self.flagTextChanged = self.flagCodeFolding = False
        self.flagModified = False
        self.lastText = ''
        self.IsDClicked = False
        self.keywordStyleList = (
            self.STC_AVS_COREFILTER,
            #~ self.STC_AVS_CLIPPROPERTY,
            self.STC_AVS_PLUGIN,
            self.STC_AVS_USERFUNCTION,
            #~ self.STC_AVS_SCRIPTFUNCTION,
        )
        self.highlightwordStyleList = (
            self.STC_AVS_COREFILTER,
            self.STC_AVS_CLIPPROPERTY,
            self.STC_AVS_PLUGIN,
            self.STC_AVS_USERFUNCTION,
            self.STC_AVS_SCRIPTFUNCTION,
        )
        self.commentStyle = [self.STC_AVS_COMMENT, self.STC_AVS_COMMENT_2, self.STC_AVS_BLOCKCOMMENT, self.STC_AVS_ENDCOMMENT,
                self.STC_AVS_PREVIEWFILTER, self.STC_AVS_PREVIEWFILTER_END]
        # only for self.ScriptChanged() used
        self.commentStyle_2 = [self.STC_AVS_COMMENT, self.STC_AVS_BLOCKCOMMENT, self.STC_AVS_ENDCOMMENT,
                self.STC_AVS_PREVIEWFILTER, self.STC_AVS_SPLITCLIP ,self.STC_AVS_PREVIEWFILTER_END]
        self.nonBraceStyles = [
            self.STC_AVS_COMMENT,
            self.STC_AVS_COMMENT_2,
            self.STC_AVS_ENDCOMMENT,
            self.STC_AVS_BLOCKCOMMENT,
            self.STC_AVS_STRING,
            self.STC_AVS_TRIPLE,
            self.STC_AVS_STRINGEOL,
            self.STC_AVS_USERSLIDER,
            self.STC_AVS_PREVIEWFILTER,
            self.STC_AVS_PREVIEWFILTER_END,
            self.STC_AVS_SPLITCLIP,
        ]
        self.stc_attr = ( # 'eol' not supported in html export
            ('bold', 'italic', 'underline'),
            ('fore', 'back', 'face', 'size'))
        self.css_properties = {
            'bold':      'font-weight',
            'italic':    'font-style',
            'fore':      'color',
            'back':      'background-color',
            'face':      'font-family',
            'size':      'font-size',
            'underline': 'text-decoration',
        }
        # Auto-completion options
        self.AutoCompSetIgnoreCase(1)
        self.AutoCompSetDropRestOfWord(1)
        self.AutoCompSetAutoHide(1)
        self.AutoCompSetChooseSingle(0)
        self.AutoCompSetCancelAtStart(1)
        self.AutoCompSetSeparator(ord('\n'))
        self.AutoCompStops_chars = ''' `~!@#$%^&*()+=[]{};:'",<.>/?\|'''
        # Margin options
        self.SetMarginWidth(0, self.initialMarginWidth)
        self.SetMarginWidth(1, 0)
        self.SetMarginType(2, stc.STC_MARGIN_SYMBOL)
        self.SetMarginMask(2, stc.STC_MASK_FOLDERS)
        self.SetMarginSensitive(2, True)
        self.SetMarginWidth(2, 13)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPEN,    stc.STC_MARK_MINUS)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDER,        stc.STC_MARK_PLUS)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERSUB,     stc.STC_MARK_EMPTY)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_EMPTY)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_EMPTY)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_EMPTY)
        self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_EMPTY)
        self.SetSavePoint()
        # Event handling
        self.Bind(stc.EVT_STC_UPDATEUI, self.OnUpdateUI)
        #self.Bind(stc.EVT_STC_CHANGE, self.OnTextChange)
        self.Bind(stc.EVT_STC_MODIFIED, self.OnTextChange)
        self.Bind(stc.EVT_STC_CHARADDED, self.OnTextCharAdded)
        self.Bind(stc.EVT_STC_NEEDSHOWN, self.OnNeedShown)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftMouseDown)
        self.Bind(stc.EVT_STC_AUTOCOMP_SELECTION, self.OnAutocompleteSelection)
        self.Bind(stc.EVT_STC_USERLISTSELECTION, self.OnUserListSelection)
        self.Bind(stc.EVT_STC_CALLTIP_CLICK, self.OnCalltipClick)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(stc.EVT_STC_MARGINCLICK, self.OnMarginClick)
        self.Bind(stc.EVT_STC_ZOOM, lambda event: self.fitNumberMarginWidth())
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        try:
            self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, lambda event: self.ReleaseMouse())
        except AttributeError:
            pass
        if self.GetLexer() == stc.STC_LEX_CONTAINER:
            self.Bind(stc.EVT_STC_STYLENEEDED, self.OnStyleNeeded)

    def SetUserOptions(self):
        # AviSynth filter information
        self.SetTextStyles(self.app.options['textstyles'], self.app.options['usemonospacedfont'])
        if self.styling_refresh_needed:
            self.styling_refresh_needed = False
            self.Colourise(0, 0) # set self.GetEndStyled() to 0
        if self.app.options['autocompleteicons']:
            self.RegisterImage(1, ok_icon.GetBitmap())
            self.RegisterImage(2, smile_icon.GetBitmap())
            self.RegisterImage(3, question_icon.GetBitmap())
            self.RegisterImage(4, rectangle_icon.GetBitmap())
            self.RegisterImage(5, wx.ArtProvider.GetBitmap(wx.ART_FOLDER))
            self.RegisterImage(6, wx.ArtProvider.GetBitmap(wx.ART_NORMAL_FILE))
        else:
            self.ClearRegisteredImages()
        # General options
        self.SetUseTabs(self.app.options['usetabs'])
        self.SetTabWidth(self.app.options['tabwidth'])
        self.SetCaretLineBack(self.app.options['textstyles']['highlightline'].split(':')[1])
        self.SetCaretLineVisible(self.app.options['highlightline'])
        if self.app.options['wrap']:
            self.SetWrapMode(stc.STC_WRAP_WORD)
        else:
            self.SetWrapMode(stc.STC_WRAP_NONE)
        self.SetFoldFlags(self.app.options['foldflag']<<4)
        if self.app.options['numlinechars']:
            self.initialMarginWidth = self.numlinechars2pixels(self.app.options['numlinechars'])
            self.fitNumberMarginWidth()
        else:
            self.initialMarginWidth = 0
            self.SetMarginWidth(0, 0)

    def ParseFunctions(self, text=None, refresh_highlighting=False):
        if text is None:
            text = self.GetText()
        filterInfo = self.app.ParseAvisynthScript(script_text=text, quiet=True) or []
        self.avsfilterdict.clear()
        self.avsfilterdict.update(dict(
            [
            (filtername.lower(), (filterargs, self.STC_AVS_USERFUNCTION, filtername, None))
            for filename, filtername, filterargs, ftype in filterInfo
            ]
        ))
        self.avsazdict = self.app.GetAutocompleteDict(self.avsfilterdict.own_dict)
        if refresh_highlighting:
            self.Colourise(0, 0)

    def SetTextStyles(self, textstyles, monospaced=False):
        self.SetLexer(stc.STC_LEX_CONTAINER)
        default = 'font:Arial, size:10, fore:#000000, back:#FFFFFF'
        # Global default styles for all languages
        self.StyleSetSpec(stc.STC_STYLE_DEFAULT, textstyles.get('default', default))
        if monospaced:
            face = ''
            size = ''
            for item in textstyles['monospaced'].split(','):
                if item.lower().startswith('face:'):
                    face = item.split(':')[1]
                if item.lower().startswith('size:'):
                    size = int(item.split(':')[1])
            self.StyleSetFaceName(stc.STC_STYLE_DEFAULT, face)
            self.StyleSetSize(stc.STC_STYLE_DEFAULT, size)
        self.StyleClearAll()  # Reset all to be like the default

        for style, (key, extra) in self.styleInfo.iteritems():
            self.StyleSetSpec(style, textstyles.get(key, default) + extra)
            if monospaced:
                self.StyleSetFaceName(style, face)
                self.StyleSetSize(style, size)
        # Set miscellaneous non-style colors
        for key in ('calltip', 'calltiphighlight'):
            value = textstyles[key]
            for elem in value.split(','):
                if elem.startswith('fore:'):
                    if key == 'calltip':
                        self.CallTipSetForeground(elem.split(':')[1].strip())
                    else:
                        self.CallTipSetForegroundHighlight(elem.split(':')[1].strip())
                if elem.startswith('back:'):
                    self.CallTipSetBackground(elem.split(':')[1].strip())
        self.SetCaretForeground(textstyles['cursor'].split(':')[1])
        for elem in textstyles['highlight'].split(','):
            if elem.startswith('fore:'):
                if self.app.options['highlight_fore']:
                    self.SetSelForeground(True, elem.split(':')[1].strip())
                else:
                    self.SetSelForeground(False, wx.WHITE)
            elif elem.startswith('back:'):
                self.SetSelBackground(True, elem.split(':')[1].strip())
        fore = back = None
        for elem in textstyles['foldmargin'].split(','):
            if elem.startswith('fore:'):
                fore = elem.split(':')[1].strip()
            elif elem.startswith('back:'):
                back = elem.split(':')[1].strip()
                self.SetFoldMarginColour(True, back)
                self.SetFoldMarginHiColour(True, back)
        fore = fore or 'white'
        back = back or 'black'
        self.MarkerSetForeground(stc.STC_MARKNUM_FOLDEROPEN, fore)
        self.MarkerSetBackground(stc.STC_MARKNUM_FOLDEROPEN, back)
        self.MarkerSetForeground(stc.STC_MARKNUM_FOLDER, fore)
        self.MarkerSetBackground(stc.STC_MARKNUM_FOLDER, back)
        self.MarkerSetForeground(stc.STC_MARKNUM_FOLDERSUB, fore)
        self.MarkerSetBackground(stc.STC_MARKNUM_FOLDERSUB, back)
        self.MarkerSetForeground(stc.STC_MARKNUM_FOLDERTAIL, fore)
        self.MarkerSetBackground(stc.STC_MARKNUM_FOLDERTAIL, back)
        self.MarkerSetForeground(stc.STC_MARKNUM_FOLDEREND, fore)
        self.MarkerSetBackground(stc.STC_MARKNUM_FOLDEREND, back)
        self.MarkerSetForeground(stc.STC_MARKNUM_FOLDEROPENMID, fore)
        self.MarkerSetBackground(stc.STC_MARKNUM_FOLDEROPENMID, back)
        self.MarkerSetForeground(stc.STC_MARKNUM_FOLDERMIDTAIL, fore)
        self.MarkerSetBackground(stc.STC_MARKNUM_FOLDERMIDTAIL, back)

    def numlinechars2pixels(self, numlinechars):
        return self.TextWidth(stc.STC_STYLE_LINENUMBER, '%s' % ('0'*numlinechars)) + 12

    def fitNumberMarginWidth(self):
        # Update line number margin width
        w = self.TextWidth(stc.STC_STYLE_LINENUMBER, '%s' % str(self.GetLineCount())) + 12
        w = max(w, self.initialMarginWidth)
        if w != self.GetMarginWidth(0):
            self.SetMarginWidth(0, w)

    # New utility functions
    def ShowQuickFindDialog(self):
        if self.app.findDialog.IsShown():
            self.app.findDialog.SetFocus()
        else:
            x0, y0 = self.app.currentScript.GetScreenPosition()
            w0, h0 = self.app.currentScript.GetSize()
            w, h = self.app.findDialog.GetSize()
            self.app.findDialog.SetPosition((x0 + w0 - w - 5, y0 + 5))
            self.app.findDialog.Show()
            self.app.findDialog.SetFocus()
        text = self.GetSelectedText()
        if text:
            self.app.findDialog.UpdateText(text)

    def ShowFindReplaceDialog(self, find=False):
        self.app.findDialog.Hide()
        text = self.GetSelectedText()
        if self.app.replaceDialog.IsShown():
            self.app.replaceDialog.SetFocus()
            if text:
                if '\n' in text.strip():
                    self.app.replaceDialog.only_selection.SetValue(True)
                else:
                    ctrl = 'find' if find else 'replace'
                    self.app.replaceDialog.UpdateText(text, ctrl)
        else:
            self.app.replaceDialog.Show()
            if text:
                if '\n' in text.strip():
                    self.app.replaceDialog.only_selection.SetValue(True)
                else:
                    self.app.replaceDialog.UpdateText(text, 'find')

    def FindNext(self):
        if self.AutoCompActive():
            self.AutoCompCancel()
        if self.app.replaceDialog.GetFindText():
            self.app.replaceDialog.OnFindNext()
        elif self.app.replaceDialog.IsShown():
            self.ShowFindReplaceDialog()
        else:
            text = self.GetSelectedText()
            if text:
                self.app.findDialog.UpdateText(text)
                self.app.replaceDialog.OnFindNext()
            else:
                self.ShowQuickFindDialog()

    def FindPrevious(self):
        if self.AutoCompActive():
            self.AutoCompCancel()
        if self.app.replaceDialog.GetFindText():
            self.app.replaceDialog.OnFindPrevious()
        elif self.app.replaceDialog.IsShown():
            self.ShowFindReplaceDialog()
        else:
            text = self.GetSelectedText()
            if text:
                self.app.findDialog.UpdateText(text)
                self.app.replaceDialog.OnFindPrevious()
            else:
                self.ShowQuickFindDialog()

    def ReplaceNext(self):
        if self.AutoCompActive():
            self.AutoCompCancel()
        if self.app.replaceDialog.GetReplaceText():
            if self.app.replaceDialog.GetFindText():
                self.app.replaceDialog.OnReplace()
            else:
                text = self.GetSelectedText()
                if text:
                    self.app.replaceDialog.UpdateText(text, 'find')
                    self.app.replaceDialog.OnReplace()
                else:
                    self.ShowFindReplaceDialog()
        else:
            self.ShowFindReplaceDialog()

    def IndentSelection(self):
        self.CmdKeyExecute(stc.STC_CMD_TAB)

    def UnIndentSelection(self):
        self.CmdKeyExecute(stc.STC_CMD_BACKTAB)

    def BlockComment(self, chars='#~ ', nextCharChancel=[], clearSelection=False):
        length = len(chars)
        if length < 1:
            return
        line1 = self.LineFromPosition(self.GetSelectionStart())
        line2 = self.LineFromPosition(self.GetSelectionEnd())
        self.BeginUndoAction()
        for line in xrange(line1, line2+1):
            txt = self.GetLine(line)
            if txt.strip():
                pos = self.PositionFromLine(line) + len(txt) - len(txt.lstrip())
                if txt.strip().startswith(chars):
                    if nextCharChancel and len(txt) > len(chars)\
                       and txt[len(chars):len(chars)+1] in nextCharChancel:
                        continue
                    self.SetTargetStart(pos)
                    self.SetTargetEnd(pos+length)
                    self.ReplaceTarget('')
                else:
                    self.SetTargetStart(pos)
                    self.SetTargetEnd(pos)
                    self.ReplaceTarget(chars)
        self.EndUndoAction()
        if clearSelection:
            pos = self.GetCurrentPos()
            wx.CallLater(700, self.SetSelection, pos, pos)

    def StyleComment(self, chars='#~ '):
        length = len(chars)
        if length < 1:
            return
        pos = self.GetCurrentPos()
        start = self.PositionFromLine(self.LineFromPosition(pos))
        style = self.GetStyleAt(pos)
        if style == self.STC_AVS_COMMENT:
            while pos > start and self.GetStyleAt(pos-1) == self.STC_AVS_COMMENT:
                pos -= 1
            self.SetTargetStart(pos)
            if self.GetTextRange(pos, pos+length) == chars:
                self.SetTargetEnd(pos+length)
            else:
                self.SetTargetEnd(pos+1)
            self.ReplaceTarget('')
        else:
            if pos > start and unichr(self.GetCharAt(pos)) == '.' and self.GetStyleAt(pos-1) == self.STC_AVS_NUMBER:
                pos -= 1
                style = self.STC_AVS_NUMBER
            while pos > start and self.GetStyleAt(pos-1) == style:
                pos -= 1
            if pos > start and unichr(self.GetCharAt(pos-1)) == '.':
                pos -= 1
            if style == self.STC_AVS_NUMBER:
                while pos > start and self.GetStyleAt(pos-1) == style:
                    pos -= 1
                if pos > start and unichr(self.GetCharAt(pos-1)) in '+-':
                    pos -= 1
            self.InsertText(pos, chars)

    def MoveSelectionByOneLine(self, up=True):
        selA = self.GetSelectionStart()
        selB = self.GetSelectionEnd()
        line1 = self.LineFromPosition(selA)
        line2 = self.LineFromPosition(selB)
        numlines = self.GetLineCount()
        if line2 == numlines - 1:
            if selB != self.GetLength() or selB != self.PositionFromLine(line2):
                self.InsertText(self.GetLineEndPosition(line2), '\n')
        posA = self.PositionFromLine(line1)
        if self.GetSelectionEnd() == self.PositionFromLine(line2) and selA != selB:
            posB = self.PositionFromLine(line2)
        else:
            posB = self.PositionFromLine(line2 + 1)
        if up:
            newline = max(line1 - 1, 0)
        else:
            newline = min(line1 + 1, numlines-1 - (line2 - line1))
        if newline == line1:
            return
        if newline == self.GetLineCount() - 1 and self.GetLine(newline) != '':
                self.InsertText(self.GetLineEndPosition(newline), '\n')
        self.BeginUndoAction()
        self.SetSelection(posA, posB)
        txt = self.GetSelectedText()
        self.ReplaceSelection('')
        newpos = self.PositionFromLine(newline)
        self.GotoPos(newpos)
        self.ReplaceSelection(txt)
        self.SetSelection(newpos, newpos+len(txt))
        self.EndUndoAction()

    def ShowAutocomplete(self, all=False, auto=0):
        pos = self.GetCurrentPos()
        startwordpos = self.WordStartPosition(pos,1)
        if pos == startwordpos:
            return
        word = self.GetTextRange(startwordpos,pos)
        #~ if len(word) == 0:
            #~ return
        keywords = []
        wordlower = word.lower()
        avsazdict = self.app.avsazdict_all if all else self.app.avsazdict
        first_chr = word[0].lower()
        for keyword in set(avsazdict[first_chr] + self.avsazdict[first_chr]):
            if keyword.lower().startswith(wordlower):
                keywords.append(keyword)
        if self.app.options['autocompletevariables']:
            lineCount = self.LineFromPosition(pos)
            line = 0
            while line <= lineCount:
                if line == lineCount:
                    line += 1
                    lineCount = self.GetLineCount()
                    continue
                start = self.PositionFromLine(line)
                eol = self.GetLineEndPosition(line)
                while line < lineCount - 1 and (self.FindText(self.PositionFromLine(line), eol, r'\\[ ]*$', stc.STC_FIND_REGEXP) != -1 or \
                                                self.FindText(eol+1, self.GetLineEndPosition(line+1), r'^[ ]*\\', stc.STC_FIND_REGEXP) != -1):
                    line += 1
                    eol = self.GetLineEndPosition(line)
                start = self.FindText(start, eol, r'\<', stc.STC_FIND_REGEXP)
                while start != -1 and self.GetStyleAt(start) == self.STC_AVS_BLOCKCOMMENT:
                    end = self.WordEndPosition(start, 1)
                    start = self.FindText(end, eol, r'\<', stc.STC_FIND_REGEXP)
                if start == -1:
                    line += 1
                    continue
                end = self.WordEndPosition(start, 1)
                keyword = self.GetTextRange(start, end)
                #~ print keyword
                if self.GetStyleAt(start) == self.STC_AVS_ASSIGN and keyword.lower().startswith(wordlower) and keyword not in keywords:
                    keywords.append(keyword)
                elif keyword == 'global' or keyword == 'function':
                    start = self.FindText(end, self.GetLineEndPosition(line), r'\<', stc.STC_FIND_REGEXP)
                    if start == -1:
                        line += 1
                        continue
                    end = self.WordEndPosition(start, 1)
                    keyword = self.GetTextRange(start, end)
                    if keyword.lower().startswith(wordlower) and keyword not in keywords:
                        keywords.append(keyword)
                line += 1
            keywords.sort(key=lambda s: s.lower())
        if keywords:
            if auto != 2 or (len(keywords) == 1 and len(keywords[0]) != len(word)):
                if self.app.options['autocompleteicons']:
                    for i in range(len(keywords)):
                        keyword = keywords[i].lower()
                        if keyword not in self.avsfilterdict:
                            keywords[i] += '?4'
                            continue
                        keyword = self.avsfilterdict[keyword][3] or keyword
                        preset = self.app.options['filterpresets'].get(keyword)
                        if preset is None:
                            preset = self.CreateDefaultPreset(keywords[i])
                        question = preset.count('?')
                        comma = preset.count(',')
                        if question == 0:
                            keywords[i] += '?1'
                        elif question == 1 or question*10 <= (comma+1)*3:
                            keywords[i] += '?2'
                        elif comma <= 1:
                            pass
                        elif question*10 >= (comma+1)*7:
                            keywords[i] += '?3'
                self.autocomplete_case = 'function'
                self.AutoCompStops(self.AutoCompStops_chars)
                self.AutoCompShow(len(word), '\n'.join(keywords))
                if self.CallTipActive():
                    self.CallTipCancelCustom()
        elif auto == 0 and pos - startwordpos > 0:
            self.CmdKeyExecute(stc.STC_CMD_CHARLEFT)
            wx.CallAfter(self.ShowAutocomplete)

    def FinishAutocomplete(self, key=None):
        self.AutoCompComplete()
        pos = self.GetCurrentPos()
        startwordpos = self.WordStartPosition(pos,1)
        filtername = self.GetTextRange(startwordpos,pos)
        if filtername.lower() not in self.avsfilterdict:
            return
        boolActivatePreset = (
            self.app.options['presetactivatekey'] == 'tab' and key == wx.WXK_TAB or
            self.app.options['presetactivatekey'] == 'return' and key in (wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER) or
            self.app.options['presetactivatekey'] == 'both')
        if boolActivatePreset:
            keyword = filtername.lower()
            keyword = self.avsfilterdict[keyword][3] or keyword
            preset = self.app.options['filterpresets'].get(keyword)
            boolHighlightQuestionMarks = True
            if preset is not None:
                self.SetSelection(startwordpos, pos)
                self.ReplaceSelection(preset)
                cursorTag = '[|]'
                nCursorTags = preset.count(cursorTag)
                if nCursorTags > 0:
                    minPos = startwordpos
                    maxPos = self.GetCurrentPos()
                    startSelectionPos = endSelectionPos = None
                    for i in xrange(nCursorTags):
                        findpos = self.FindText(minPos, maxPos, cursorTag, stc.STC_FIND_MATCHCASE)
                        if findpos != -1:
                            self.SetSelection(findpos, findpos + len(cursorTag))
                            self.ReplaceSelection('')
                            endSelectionPos = findpos
                            if startSelectionPos is None:
                                startSelectionPos = findpos
                            minPos = findpos
                            maxPos -= len(cursorTag)
                        else:
                            break
                    if startSelectionPos is not None and endSelectionPos is not None:
                        self.SetSelection(startSelectionPos, endSelectionPos)
                        boolHighlightQuestionMarks = False
            else:
                preset = self.CreateDefaultPreset(filtername)
                self.SetSelection(startwordpos, pos)
                self.ReplaceSelection(preset)
            if boolHighlightQuestionMarks:
                minPos = self.WordEndPosition(pos,1)
                maxPos = self.GetCurrentPos()
                findpos = self.FindText(minPos, maxPos, '?')#, stc.STC_FIND_MATCHCASE)
                if findpos != -1:
                    self.SetSelection(findpos, findpos+1)
            return
        args = self.avsfilterdict[filtername.lower()][0]
        if not args:
            return
        if args == '()':
            self.InsertText(pos,'()')
            self.GotoPos(pos+2)
            return
        level = self.app.options['autoparentheses']
        if unichr(self.GetCharAt(pos)) == '(':
            level = 0
        if level==0:
            pass
        elif level==1:
            self.InsertText(pos,'(')
            self.GotoPos(pos+1)
        elif level==2:
            self.InsertText(pos,'()')
            self.GotoPos(pos+1)

    def AutocompleteFilename(self):
        """Autocomplete a filename string, showing choices if necessary"""
        pos = self.GetCurrentPos()
        str_range = self.GetStringRange(pos)
        if not str_range:
            return
        start, end = str_range
        if self.GetStyleAt(start) == self.STC_AVS_TRIPLE: # only current line
            line = self.LineFromPosition(pos)
            start = max(start, self.PositionFromLine(line))
            end = min(end, self.GetLineEndPosition(line))
        ac_str = self.GetTextRange(start, pos)
        prefix = '' if os.path.isabs(ac_str) else self.workdir
        if os.path.isdir(os.path.join(prefix, ac_str)):
            dir = ac_str
            base = ''
        else:
            dir, base = os.path.split(ac_str)
        try:
            filenames = sorted([path for path in os.listdir(os.path.join(prefix, dir) or unicode(os.curdir))
                                if not base or os.path.normcase(path).startswith(os.path.normcase(base))],
                               key=lambda s: s.upper())
        except OSError:
            return
        if filenames:
            if len(filenames) == 1:
                self.AutocompleteReplaceText(start, end, prefix, os.path.join(dir, filenames[0]))
            else:
                self.autocomplete_params = pos, start, end, prefix, dir
                if self.app.options['autocompleteicons']:
                    filenames = [u'{0}?{1}'.format(file, 5 if os.path.isdir(os.path.join(prefix, dir, file))
                                 else 6) for file in filenames]
                self.autocomplete_case = 'filename'
                self.AutoCompStops('')
                self.AutoCompShow(len(base), '\n'.join(filenames))
                if self.CallTipActive():
                    self.CallTipCancelCustom()

    def AutocompleteReplaceText(self, start, end, prefix, new_text):
        """Used on filename autocomplete, instead of the default handler"""
        if new_text != self.GetTextRange(start, end):
            self.SetTargetStart(start)
            self.SetTargetEnd(end)
            new_end = start + self.ReplaceTarget(new_text)
            self.GotoPos(new_end)
        else:
            self.GotoPos(end)
        if os.path.isdir(os.path.join(prefix, new_text)):
            def autocomplete_again():
                wx.GetApp().Yield(True)
                self.AutocompleteFilename()
            wx.CallAfter(autocomplete_again)

    def AutocompleteParameterName(self):
        """Autocomplete parameter name in a function call"""
        pos = self.GetCurrentPos()
        openpos = self.GetOpenParenthesesPos(pos - 1)
        if openpos is None:
            return
        wordstartpos = self.WordStartPosition(openpos, 1)
        if openpos == wordstartpos:
            wordstartpos = self.WordStartPosition(self.WordStartPosition(openpos, 0), 1)
        if wordstartpos != -1:
            matched_args = {}
            arg_start_pos = self.WordStartPosition(pos, 1)
            chrs = self.GetTextRange(arg_start_pos, pos).lower()
            function_name = self.GetTextRange(wordstartpos, openpos).strip()
            args_script = [arg[0].lower() for arg in self.GetFilterScriptArgInfo(openpos) or []]
            for arg_type, arg_name, arg_info in ((arg[1], arg[2].strip('"'), arg[5]) for arg in
                             self.GetFilterCalltipArgInfo(function_name) or []
                             if arg[2].startswith('"') and arg[2].endswith('"')):
                arg_name_lower = arg_name.lower()
                if arg_name_lower.startswith(chrs) and arg_name_lower not in args_script:
                    matched_args[arg_name] = arg_type, arg_info
            if matched_args:
                if len(matched_args) == 1:
                    arg_name, (arg_type, arg_info) = matched_args.items()[0]
                    if unichr(self.GetCharAt(pos)) == '=':
                        new_text = arg_name
                    else:
                        new_text = arg_name + '='
                    self.SetTargetStart(arg_start_pos)
                    self.SetTargetEnd(self.WordEndPosition(pos, 1))
                    self.GotoPos(arg_start_pos + self.ReplaceTarget(new_text))
                    self.AutocompleteParameterValue(arg_type, arg_info)
                else:
                    args = matched_args.keys()
                    args.sort(key=lambda s: s.upper())
                    self.autocomplete_case = 'parameter name'
                    self.autocomplete_params = matched_args
                    self.AutoCompStops(self.AutoCompStops_chars)
                    self.AutoCompShow(len(chrs), '\n'.join(args))
                    if self.CallTipActive():
                        self.CallTipCancelCustom()

    def AutocompleteParameterValue(self, arg_type=None, arg_info=None):
        """Autocomplete parameter name in a function call"""
        if arg_type is None or arg_info is None:
            pos = self.GetCurrentPos()
            openpos = self.GetOpenParenthesesPos(pos - 1)
            if openpos is None:
                return
            wordstartpos = self.WordStartPosition(openpos, 1)
            if openpos == wordstartpos:
                wordstartpos = self.WordStartPosition(self.WordStartPosition(openpos, 0), 1)
            if wordstartpos != -1:
                matched_args = self.GetFilterMatchedArgs(wordstartpos)[self.cursorFilterScriptArgIndex][1]
                arg_info = self.GetFilterCalltipArgInfo(calltip=matched_args)[0]
                arg_type, arg_info = arg_info[1], arg_info[-1]
        if arg_type is not None and arg_info is not None:
            value_list = self.GetParameterValues(arg_type, arg_info)
            if value_list:
                self.autocomplete_case = 'parameter value'
                self.AutoCompStops('')
                self.AutoCompShow(0, '\n'.join(value_list))
                if self.CallTipActive():
                    self.CallTipCancelCustom()

    @staticmethod
    def GetParameterValues(arg_type, arg_info):
        if arg_type == 'bool':
            return ['true', 'false']
        elif arg_type in ('int', 'string'):
            if arg_type == 'string' and arg_info.startswith('"'):
                arg_info = arg_info[arg_info[1:].index('"') + 2:]
            start = arg_info.find('(')
            if start == -1:
                return
            arg_info = arg_info[start + 1:]
            value_list = [value.strip() for value in
                          arg_info.strip(' )').split('/')]
            if len(value_list) > 1:
                return value_list

    def InsertSnippet(self):
        pos = self.GetCurrentPos()
        start = self.WordStartPosition(pos, 1)
        end = self.WordEndPosition(pos, 1)
        word = self.GetTextRange(start, end)
        if word in self.app.options['snippets']:
            text = self.app.options['snippets'][word]
            if text:
                self.SetTargetStart(start)
                self.SetTargetEnd(end)
                self.GotoPos(start + self.ReplaceTarget(text))
        else:
            if self.AutoCompActive():
                self.CmdKeyExecute(wx.stc.STC_CMD_CANCEL)
                if self.autocomplete_case == 'snippet':
                        return
            tag_list = [tag for tag, text in self.app.options['snippets'].iteritems() if text]
            if tag_list:
                self.autocomplete_case = 'snippet'
                self.autocomplete_params = pos
                self.UserListShow(1, '\n'.join(sorted(tag_list)))

    # GPo 2022, changed to display comments (e.g. alternative args)
    # filterdb.dat type #hint
    def UpdateCalltip(self, force=False):
        caretPos = self.GetCurrentPos()
        # Cancel under certain conditions
        boolHasFocus = (self.app.FindFocus() == self)
        boolIsComment = (self.GetStyleAt(caretPos - 1) in self.commentStyle)
        if (not self.app.options['calltips'] and not self.app.calltipstemporal) or not boolHasFocus or self.AutoCompActive() or boolIsComment: # GPo 2020, temporal
            self.CallTipCancelCustom()
            return
        # Determine the positions of the filter within the script
        openpos = self.GetOpenParenthesesPos(caretPos-1)
        if openpos is None:
            if force:
                openpos = self.WordEndPosition(caretPos,1) #+ 1
            else:
                self.CallTipCancelCustom()
                return
        closepos = self.BraceMatch(openpos)
        if closepos == -1:
            closepos = self.GetLength()
        # Set the force flag to true if there's an appropriate highlight
        selA, selB = self.GetSelection()
        if selA != selB:
            if selA >= openpos and selB <= closepos+1:
                force = True
            else:
                self.CallTipCancelCustom()
                return
        startwordpos = self.WordStartPosition(self.WordStartPosition(openpos, 0), 1)
        endwordpos = self.WordEndPosition(startwordpos, 1)
        # Show the calltip
        self.calltipFilter = None
        word = self.GetTextRange(startwordpos, endwordpos)
        iArgPos = None
        if self.GetStyleAt(startwordpos) in self.highlightwordStyleList:
            # Show the calltip
            wordWidth = self.TextWidth(stc.STC_STYLE_DEFAULT, '%s(' % word)
            spaceWidth = self.TextWidth(stc.STC_STYLE_DEFAULT, ' ')
            spaces = ' ' * int(round(wordWidth / float(spaceWidth)))
            args = self.avsfilterdict[word.lower()][0]
            if args  in ('', '()'):
                self.CallTipCancelCustom()
                self.calltipFilter = word
                return
            # Get the argument index based on the cursor position
            self.cursorFilterScriptArgIndex = None
            filterMatchedArgs = self.GetFilterMatchedArgs(startwordpos, args)
            try:
                iArgPos = filterMatchedArgs[self.cursorFilterScriptArgIndex][0]
            except IndexError:
                iArgPos = None
            boolOutOfOrder = False
            if iArgPos is not None:
                currentArgName = filterMatchedArgs[self.cursorFilterScriptArgIndex][2]
                if not currentArgName:
                    for item in filterMatchedArgs[:self.cursorFilterScriptArgIndex]:
                        if item[2]:
                            boolOutOfOrder = True
                            break
            # TODO: fix iArgPos to not be None if unfinished arg...?
            # Format the calltip
            splitargs = args.split('\n\n', 1)
            tempList = []
            callTipInfo, hint = self.GetFilterCalltipArgInfo(word=word, calltip=splitargs[0], returnHint=True)
            #~for iTemp, tempInfo in enumerate(self.GetFilterCalltipArgInfo(calltip=splitargs[0])):
            for iTemp, tempInfo in enumerate(callTipInfo):
                cArgTotal, cArgType, cArgName, boolMulti, boolOptional, cArgInfo = tempInfo
                s = '%s %s' % (cArgType, cArgName)
                if iTemp == iArgPos and cArgInfo and not boolOutOfOrder:
                    s += '=%s' % cArgInfo
                if boolMulti:
                    s += ' [, ...]'
                tempList.append(s)
            args0 = '(%s)' % (','.join(tempList))
            args0 = self.app.wrapFilterCalltip(args0)
            args0 = args0.replace('\n', '\n'+spaces)
            if len(splitargs) == 2:
                args = '%s\n\n%s' % (args0, splitargs[1])
            else:
                args = args0
            text = '%s%s' % (word, args)

            # show two times default calltip note
            if not hint and self.hintShown < 2:
                self.hintShown += 1
                hint = _('Note: When clicking on the calltip press Ctrl for file search '
                         'or Shift for web search only.')

            c_text = text + '\n\n' + hint if hint else text

            if self.LineFromPosition(startwordpos) == self.GetCurrentLine():
                showpos = startwordpos
            else:
                showpos = self.PositionFromLine(self.LineFromPosition(caretPos))
            xpoint, ypoint = self.PointFromPosition(showpos)

            if openpos == self.calltipOpenpos or self.flagTextChanged:
                force = True
            if self.app.options['frequentcalltips'] or force:# or (charBefore and unichr(charBefore) == '('):
                if xpoint >= 0:
                    self.CallTipShow(showpos, c_text)
                else:
                    xpoint = self.GetMarginWidth(0) + self.GetMarginWidth(1) + self.GetMarginWidth(2)
                    newpos = self.PositionFromPoint(wx.Point(xpoint, ypoint))
                    self.CallTipShow(newpos, c_text)
            #self.calltiptext = text # never used
            self.calltipFilter = word
        if self.CallTipActive():
            self.calltipOpenpos = openpos
            # BOLD THE CURRENT ARGUMENT
            a, b = 1,1
            if iArgPos is not None and not boolOutOfOrder:
                # Get the calltip arguments text positions
                try:
                    calltiptext = text
                except UnboundLocalError:
                    return
                openpos = calltiptext.find('(')
                if openpos == -1:
                    return
                argPosList = []
                startpos = openpos+1
                stoppos = startpos
                nopenSquare = 0
                argString = calltiptext[stoppos:]
                imax = len(argString)-1
                for i, c in enumerate(argString):
                    if c == '[':
                        nopenSquare += 1
                    if c == ']':
                        nopenSquare -= 1
                    if nopenSquare > 0:
                        c = 'x'
                    if c == ',' or i == imax:
                        argPosList.append((startpos, stoppos))
                        startpos = stoppos + 1
                    stoppos += 1
                if len(argPosList) == 1 and iArgPos == 1:
                    pass
                else:
                    try:
                        a, b = argPosList[iArgPos]
                    except IndexError:
                        if __debug__:
                            print>>sys.stderr, 'Error in UpdateCalltip: invalid iArgPos'
            self.CallTipSetHighlight(a,b)
        else:
            self.calltipOpenpos = None

    # GPo 2022, test to display comments and alternative parameters
    # test with same funktion names and different args returned as list by self.GetFilterCalltipArgInfo
    # but now filterdb.dat type #hint is used
    """
    def UpdateCalltip(self, force=False):
        caretPos = self.GetCurrentPos()
        # Cancel under certain conditions
        boolHasFocus = (self.app.FindFocus() == self)
        boolIsComment = (self.GetStyleAt(caretPos - 1) in self.commentStyle)
        #~if not self.app.options['calltips'] or not boolHasFocus or self.AutoCompActive() or boolIsComment:
        if (not self.app.options['calltips'] and not self.app.calltipstemporal) or not boolHasFocus or self.AutoCompActive() or boolIsComment: # GPo 2020, temporal
            self.CallTipCancelCustom()
            return
        # Determine the positions of the filter within the script
        openpos = self.GetOpenParenthesesPos(caretPos-1)
        if openpos is None:
            if force:
                openpos = self.WordEndPosition(caretPos,1) #+ 1
            else:
                self.CallTipCancelCustom()
                return
        closepos = self.BraceMatch(openpos)
        if closepos == -1:
            closepos = self.GetLength()
        # Set the force flag to true if there's an appropriate highlight
        selA, selB = self.GetSelection()
        if selA != selB:
            if selA >= openpos and selB <= closepos+1:
                force = True
            else:
                self.CallTipCancelCustom()
                return
        startwordpos = self.WordStartPosition(self.WordStartPosition(openpos, 0), 1)
        endwordpos = self.WordEndPosition(startwordpos, 1)
        # Show the calltip
        self.calltipFilter = None
        word = self.GetTextRange(startwordpos, endwordpos)
        iArgPos = None
        if self.GetStyleAt(startwordpos) in self.highlightwordStyleList:
            # Show the calltip
            wordWidth = self.TextWidth(stc.STC_STYLE_DEFAULT, '%s(' % word)
            spaceWidth = self.TextWidth(stc.STC_STYLE_DEFAULT, ' ')
            spaces = ' ' * int(round(wordWidth / float(spaceWidth)))
            args = self.avsfilterdict[word.lower()][0]
            if args  in ('', '()'):
                self.CallTipCancelCustom()
                self.calltipFilter = word
                return
            # Get the argument index based on the cursor position
            self.cursorFilterScriptArgIndex = None
            filterMatchedArgs = self.GetFilterMatchedArgs(startwordpos, args)
            try:
                iArgPos = filterMatchedArgs[self.cursorFilterScriptArgIndex][0]
            except IndexError:
                iArgPos = None
            boolOutOfOrder = False
            if iArgPos is not None:
                currentArgName = filterMatchedArgs[self.cursorFilterScriptArgIndex][2]
                if not currentArgName:
                    for item in filterMatchedArgs[:self.cursorFilterScriptArgIndex]:
                        if item[2]:
                            boolOutOfOrder = True
                            break
            # TODO: fix iArgPos to not be None if unfinished arg...?
            # Format the calltip
            splitargs = args.split('\n\n', 1)
            text = ''
            ex_text = ''
            filterCallTipList, hint = self.GetFilterCalltipArgInfo(word=word, calltip=splitargs[0], returnList=True, returnHint=True)
            for i, callTip in enumerate(filterCallTipList):
                tempList = []
                for iTemp, tempInfo in enumerate(callTip):
                    cArgTotal, cArgType, cArgName, boolMulti, boolOptional, cArgInfo = tempInfo
                    s = '%s %s' % (cArgType, cArgName)
                    if iTemp == iArgPos and cArgInfo and not boolOutOfOrder:
                        s += '=%s' % cArgInfo
                    if boolMulti:
                        s += ' [, ...]'
                    tempList.append(s)
                args0 = '(%s)' % (','.join(tempList))
                args0 = self.app.wrapFilterCalltip(args0)
                args0 = args0.replace('\n', '\n'+spaces)
                if len(splitargs) == 2:
                    args = '%s\n\n%s' % (args0, splitargs[1])
                else:
                    args = args0
                # first filter is used and next filters are alternative parameters
                # but not used, alternative args now from arg #hint
                if i == 0:
                    text += '%s%s' % (word, args)
                else:
                    ex_text += '\n%s%s' % (word, args)
                ###

            if not hint and self.hintShown < 2:
                self.hintShown += 1
                hint = 'Note: For an internet search press Ctrl when clicking on the calltip'

            # join calltips for displaying
            c_text = text + '\n' + ex_text if ex_text else text
            if hint:
                c_text += '\n\n' + hint
            ###

            if self.LineFromPosition(startwordpos) == self.GetCurrentLine():
                showpos = startwordpos
            else:
                showpos = self.PositionFromLine(self.LineFromPosition(caretPos))
            xpoint, ypoint = self.PointFromPosition(showpos)

            if openpos == self.calltipOpenpos or self.flagTextChanged:
                force = True
            if self.app.options['frequentcalltips'] or force:# or (charBefore and unichr(charBefore) == '('):
                if xpoint >= 0:
                    self.CallTipShow(showpos, c_text)
                else:
                    xpoint = self.GetMarginWidth(0) + self.GetMarginWidth(1) + self.GetMarginWidth(2)
                    newpos = self.PositionFromPoint(wx.Point(xpoint, ypoint))
                    self.CallTipShow(newpos, c_text)
            #self.calltiptext = text # GPo ? not used
            self.calltipFilter = word
        if self.CallTipActive():
            self.calltipOpenpos = openpos
            # BOLD THE CURRENT ARGUMENT
            a, b = 1,1
            if iArgPos is not None and not boolOutOfOrder:
                # Get the calltip arguments text positions
                try:
                    calltiptext = text #+ '\n' + ex_text if ex_text else text # use only the real calltip, speedup
                except UnboundLocalError:
                    return
                openpos = calltiptext.find('(')
                if openpos == -1:
                    return
                argPosList = []
                startpos = openpos+1
                stoppos = startpos
                nopenSquare = 0
                argString = calltiptext[stoppos:]
                imax = len(argString)-1
                for i, c in enumerate(argString):
                    if c == '[':
                        nopenSquare += 1
                    if c == ']':
                        nopenSquare -= 1
                    if nopenSquare > 0:
                        c = 'x'
                    if c == ',' or i == imax:
                        argPosList.append((startpos, stoppos))
                        startpos = stoppos + 1
                    stoppos += 1
                if len(argPosList) == 1 and iArgPos == 1:
                    pass
                else:
                    try:
                        a, b = argPosList[iArgPos]
                    except IndexError:
                        if __debug__:
                            print>>sys.stderr, 'Error in UpdateCalltip: invalid iArgPos'
            self.CallTipSetHighlight(a,b)
        else:
            self.calltipOpenpos = None
    """

    def CallTipCancelCustom(self):
        self.CallTipCancel()
        self.calltipFilter = None
        #self.calltiptext = None
        self.calltipOpenpos = None
        #self.app.calltiptemporal = False

    def GetOpenParenthesesPos(self, pos):
        boolInside = False
        nclose = 1
        stylesToSkip = (self.STC_AVS_STRING, self.STC_AVS_TRIPLE, self.STC_AVS_USERSLIDER)
        while pos >= 0:
            c = unichr(self.GetCharAt(pos))
            if self.GetStyleAt(pos) not in stylesToSkip:
                if c == ')':
                    nclose += 1
                if c == '(':
                    nclose -= 1
                if c == '\n':
                    current = self.GetLine(self.LineFromPosition(pos)).strip()
                    next = self.GetLine(self.LineFromPosition(pos+1)).strip()
                    if not current.endswith('\\') and not next.startswith('\\'):
                        # this is a not a multiline statement
                        # either an error or we weren't inside a function call to begin with
                        return None
            if nclose == 0:
                if self.GetStyleAt(pos) in self.commentStyle:
                    return None
                else:
                    return pos
            pos -= 1
        return None

    def GetFilterMatchedArgs(self, startwordpos, calltip=None):
        if calltip is None:
            filterName = self.GetTextRange(startwordpos, self.WordEndPosition(startwordpos, 1))
            if filterName:
                calltip = self.avsfilterdict[filterName.lower()][0].split('\n\n')[0]
            else:
                return [] # GPo 2020
        # Get both argument lists
        filterCalltipArgInfo = self.GetFilterCalltipArgInfo(calltip=calltip)
        filterScriptArgInfo = self.GetFilterScriptArgInfo(startwordpos, calltip=calltip)
        # Determine if clip passed via "dot" operator
        isClipPrePassed = False
        try:
            firstType = filterCalltipArgInfo[0][1]
        except IndexError:
            return []
        if firstType == 'clip':
            preText = self.GetAviSynthLine(startwordpos, preSectionOnly=True)
            if preText.strip().endswith('.'):
                isClipPrePassed = True
            elif filterScriptArgInfo is not None and filterScriptArgInfo[0][1] == '?':
                isClipPrePassed = True
            else:
                lastClipIndex = 0
                for i, argInfo in enumerate(filterCalltipArgInfo):
                    if argInfo[1] != 'clip':
                        break
                    lastClipIndex = i
                try:
                    if filterScriptArgInfo is not None:
                        if filterScriptArgInfo[lastClipIndex][2] not in ('clip', 'var'):
                            isClipPrePassed = True
                    else:
                        isClipPrePassed = True
                except IndexError:
                    pass
        clipOffset = int(isClipPrePassed)
        if filterScriptArgInfo is None:
            return [(clipOffset, '', '', '')]
        # Match arguments
        calltipArgNames = [info[2].strip('"').lower() for info in filterCalltipArgInfo]
        maxCalltipIndex = len(filterCalltipArgInfo) - 1
        multiType = None
        multiIndex = None
        for index, calltipInfo in enumerate(filterCalltipArgInfo):
            cArgTotal, cArgType, cArgName, cBoolMulti, boolOptional, cArgInfo = calltipInfo
            if cBoolMulti:
                multiType = cArgType
                multiIndex = index
                postMultiIndex = index
                # TODO: handle multiple multiTypes...
                break
        filterArgInfo = []
        for scriptArgIndex, argInfo in enumerate(filterScriptArgInfo):
            argname, argvalue, argtype = argInfo
            if argname:
                # Check named arguments
                try:
                    calltipIndex = calltipArgNames.index(argname.lower())
                except ValueError:
                    calltipIndex = None
            else:
                calltipIndex = scriptArgIndex + clipOffset
                # Check for multi-arg possibility
                if multiIndex is not None and calltipIndex > multiIndex:
                    if argtype in (multiType, 'var'):
                        calltipIndex = multiIndex
                    else:
                        multiType = None
                        postMultiIndex += 1
                        calltipIndex = postMultiIndex
                if calltipIndex > maxCalltipIndex:
                    calltipIndex = None
                    continue
            if calltipIndex is not None:
                calltipFilterInfo = filterCalltipArgInfo[calltipIndex][0]
            else:
                calltipFilterInfo = ''
            filterArgInfo.append((calltipIndex, calltipFilterInfo, argname, argvalue))
        return filterArgInfo

    def GetFilterScriptArgInfo(self, startwordpos, calltip=None):
        openpos = self.FindText(startwordpos, self.GetTextLength(), '(')
        if openpos == -1:
            self.cursorFilterScriptArgIndex = 0
            return None
        # Grab the text line from the script
        line = self.LineFromPosition(openpos)
        posStart = openpos - self.PositionFromLine(line)
        iArg = 0
        pos1 = openpos
        posEnd = None
        while pos1 < self.GetLength():
            if unichr(self.GetCharAt(pos1)) == '(':
                posEnd = self.BraceMatch(pos1)
                if posEnd == -1:
                    posEnd = self.GetLineEndPosition(line) #self.GetLength()
                pos1 += 1
                break
            pos1 += 1
        if posEnd is None:
            self.cursorFilterScriptArgIndex = 0
            return None
        if pos1 == posEnd:
            self.cursorFilterScriptArgIndex = 0
            return None
        currentPos = self.GetCurrentPos()
        currentIndex = None
        argsList = []
        counter = 0
        pos2 = self.GetNextValidCommaPos(pos1, allowparentheses=False)
        while pos2 is not None and pos2 <= posEnd:
            txt = self.GetTextRange(pos1,pos2).strip()
            argsList.append(txt)
            if pos2 >= currentPos and currentIndex is None:
                currentIndex = counter
            counter += 1
            pos1 = pos2 + 1
            pos2 = self.GetNextValidCommaPos(pos1, allowparentheses=False)
        if currentIndex is None:
            currentIndex = counter
        txt = self.GetTextRange(pos1,posEnd).strip()
        argsList.append(txt)
        argInfo = []
        for txt in argsList:
            try:
                argname, argvalue = [s.strip() for s in txt.split('=', 1)]
                argname = argname.strip(string.whitespace+'\\')
                argvalue = argvalue.strip(string.whitespace+'\\')
                argtype = 'named'
            except ValueError:
                argname = u''
                argvalue = txt
                argname = argname.strip(string.whitespace+'\\')
                argvalue = argvalue.strip(string.whitespace+'\\')
                argtype = self.GetAviSynthVarType(argvalue)
            argInfo.append((argname, argvalue, argtype))
        self.cursorFilterScriptArgIndex = currentIndex
        return argInfo

     # GPo, added comments (hint)
    def GetFilterCalltipArgInfo(self, word=None, calltip=None, ignore_opt_args=False, returnHint=False):
        if calltip is None:
            # Get the user slider info from the filter's calltip
            try:
                calltip = self.avsfilterdict[word.lower()][0].split('\n\n')[0]
            except KeyError:
                return
        # Delete open and close parentheses
        if calltip.startswith('(') and calltip.endswith(')'):
            calltip = calltip[1:-1]
        elif calltip.startswith('('):
            calltip = calltip[1:]
        elif calltip.endswith(')'):
            calltip = calltip[:-1]

        # Delete/mark optional arguments
        hint = ''
        new_calltip = []
        for arg in calltip.split(','):
            arg = arg.strip()
            # GPo, looking for hint or comment line
            if arg.startswith('#'):
                if returnHint and arg.startswith('#hint'):
                    hint += arg[6:].replace(';',',') + '\n' # TODO cannot find the split for ','
                continue
            if arg.startswith('[') and arg.endswith(']'):
                if not ignore_opt_args:
                    new_calltip.append(arg[1:-1] + 'OPT')
            else:
                new_calltip.append(arg)

        calltip = ', '.join(new_calltip)

        # Get rid of any commas in square brackets
        calltip = re.sub(r'\[.*\]', '[...]', calltip)

        # Split the arguments by commas
        argInfo = []
        for item in calltip.split(','):
            item = item.strip()
            if not item.strip():
                continue
            if item.count('[...]') > 0:
                boolMulti = True
                item = item.replace('[...]', '')
            else:
                boolMulti = False
            if item.endswith('OPT'):
                boolOptional = True
                item = item[:-3]
            else:
                boolOptional = False

            # GPo, replace short colorspace to calltip colorspace or replace to full
            # and change c_string to argtype string
            if item.startswith('c_string'):
                if returnHint: # then calltip
                    item = item[2:].replace('"avsRGBP"', utils.avsRGBP_s, 1).\
                            replace('"avsY"', utils.avsY_s, 1).\
                                replace('"avsYUV"', utils.avsYUV_s, 1)
                else: # then sliders etc.
                    item = item[2:].replace('"avsRGBP"', utils.avsRGBP, 1).\
                            replace('"avsY"', utils.avsY, 1).\
                                replace('"avsYUV"', utils.avsYUV, 1)
            try:
                argtype, nameAndInfo = [s.strip() for s in item.split(' ', 1)]
                try:
                    name, info = [s.strip() for s in nameAndInfo.split('=', 1)]
                except ValueError:
                    name = nameAndInfo
                    info = u''
                argInfo.append((item, argtype.lower(), name, boolMulti, boolOptional, info))
            except ValueError:
                if item.lower() in ('clip', 'int', 'float', 'bool', 'string'):
                    argInfo.append((item, item.lower(), u'', boolMulti, boolOptional, u''))
                else:
                    # Assume it's a clip
                    argInfo.append((item, u'clip', item, boolMulti, boolOptional, u''))
        if returnHint:
            return argInfo, hint.rstrip()
        else:
            return argInfo

    # GPo test, return list with alternative args, but now type #hint is used
    # self.avsfilterdictEx and the functions can be removed
    """
    def GetFilterCalltipArgInfo(self, word=None, calltip=None, ignore_opt_args=False, returnList=False, returnHint=False):
        '''
        # GPo, new get functions alternative args only for calltip, on UpdateCalltip: returnList, returnHint must be True
        # Entries for this can be made in the filterdb.dat. *Filtername_0 to 4
        # this is then displayed as an alternative in the calltip
        # There is a new arg type '#hint' which can be used to display information in the calltip.
        # And now I have changed it and only hint is used for displaying alternative args ( #hint blah blah )
        '''
        calltiplist = []
        hint = ''
        if calltip is None:
            # Get the user slider info from the filter's calltip
            try:
                calltip = self.avsfilterdict[word.lower()][0].split('\n\n')[0]
            except KeyError:
                return
        calltiplist.append(calltip)
        # check for alternative parameters (now changed, hint is used for alternative args)
        '''
        if returnList:
            for i in xrange(4):
                ex_call = '*' + word.lower() + '_' + str(i)
                if ex_call in self.avsfilterdictEx:
                    calltiplist.append(self.avsfilterdictEx[ex_call][0].split('\n\n')[0])
                else:
                    break
        '''

        argInfoList = []
        for i, calltip in enumerate(calltiplist):
            # Delete open and close parentheses
            if calltip.startswith('(') and calltip.endswith(')'):
                calltip = calltip[1:-1]
            elif calltip.startswith('('):
                calltip = calltip[1:]
            elif calltip.endswith(')'):
                calltip = calltip[:-1]

            # Delete/mark optional arguments
            new_calltip = []
            for arg in calltip.split(','):
                arg = arg.strip()
                # looking for hint or comment line
                if arg.startswith('#'):
                    if returnHint and arg.startswith('#hint'):
                        hint += arg[6:].replace(';',',') + '\n' # TODO cannot find the split for ','
                    continue
                if arg.startswith('[') and arg.endswith(']'):
                    if not ignore_opt_args:
                        new_calltip.append(arg[1:-1] + 'OPT')
                else:
                    new_calltip.append(arg)

            calltip = ', '.join(new_calltip)

            # Get rid of any commas in square brackets
            calltip = re.sub(r'\[.*\]', '[...]', calltip)

            # Split the arguments by commas
            argInfo = []
            for item in calltip.split(','):
                item = item.strip()
                if not item.strip():
                    continue
                if item.count('[...]') > 0:
                    boolMulti = True
                    item = item.replace('[...]', '')
                else:
                    boolMulti = False
                if item.endswith('OPT'):
                    boolOptional = True
                    item = item[:-3]
                else:
                    boolOptional = False

                # GPo, replace short colorspace to calltip colorspace or replace to full
                # and change c_string to argtype string
                if item.startswith('c_string'):
                    if returnHint: # then calltip
                        item = item[2:].replace('"avsRGBP"', utils.avsRGBP_s, 1).\
                                replace('"avsY"', utils.avsY_s, 1).\
                                    replace('"avsYUV"', utils.avsYUV_s, 1)
                    else: # then sliders etc.
                        item = item[2:].replace('"avsRGBP"', utils.avsRGBP, 1).\
                                replace('"avsY"', utils.avsY, 1).\
                                    replace('"avsYUV"', utils.avsYUV, 1)

                try:
                    argtype, nameAndInfo = [s.strip() for s in item.split(' ', 1)]
                    try:
                        name, info = [s.strip() for s in nameAndInfo.split('=', 1)]
                    except ValueError:
                        name = nameAndInfo
                        info = u''
                    argInfo.append((item, argtype.lower(), name, boolMulti, boolOptional, info))
                except ValueError:
                    if item.lower() in ('clip', 'int', 'float', 'bool', 'string'):
                        argInfo.append((item, item.lower(), u'', boolMulti, boolOptional, u''))
                    else:
                        # Assume it's a clip
                        argInfo.append((item, u'clip', item, boolMulti, boolOptional, u''))
            argInfoList.append(argInfo)
        if returnHint:
            return argInfoList if returnList else argInfoList[0], hint.rstrip()
        else:
            return argInfoList if returnList else argInfoList[0]
    """

    def CreateDefaultPreset(self, filtername, calltip=None):
        if calltip is None:
            calltip = self.avsfilterdict[filtername.lower()][0].split('\n\n')[0]
        if calltip == '':
            return filtername
        argList = []
        for i, info in enumerate(self.GetFilterCalltipArgInfo(filtername, calltip, ignore_opt_args=True)):
            totalInfo, cArgType, cArgName, boolRepeatArg, boolOptionalArg, cArgInfo = info
            argtype, argname, guitype, defaultValue, other = self.app.ParseCalltipArgInfo(totalInfo)
            namedarg = ''
            if cArgName.startswith('"') and cArgName.endswith('"'):
                namedarg = cArgName.strip('"')+'='
            if defaultValue or defaultValue == 0:
                if guitype == 'color':
                    argList.append('%s$%s' % (namedarg, defaultValue))
                elif argtype in ('float', 'int') and guitype == 'slider' and other is not None:
                    nDecimal = other[2]
                    strTemplate = '%.'+str(nDecimal)+'f'
                    try:
                        argList.append(namedarg+strTemplate % defaultValue)
                    except (TypeError, ValueError):
                        re_clip = re.compile(r'\bclip\b', re.I)
                        defaultValue = re_clip.sub('last', str(defaultValue))
                        argList.append(namedarg+defaultValue)
                else:
                    argList.append(namedarg+str(defaultValue))#.lower())
            elif argtype == 'clip' and i == 0:
                pass
            else:
                argList.append(namedarg+'?')
        return '%s(%s)' % (filtername, ', '.join(argList))

    def GetAviSynthLine(self, pos, preSectionOnly=False, postSectionOnly=False):
        '''Returns the line of text at pos, accommodating for AviSynth line continuations'''
        linenumber = self.LineFromPosition(pos)
        if preSectionOnly:
            lines = [self.GetLine(linenumber)[:pos-self.PositionFromLine(linenumber)]]
        elif postSectionOnly:
            lines = [self.GetLine(linenumber)[pos-self.PositionFromLine(linenumber):]]
        else:
            lines = [self.GetLine(linenumber)]
        if not postSectionOnly:
            iLine = linenumber - 1
            while iLine >= 0:
                linetxt = self.GetLine(iLine)
                if lines[0].strip().startswith('\\') or linetxt.strip().endswith('\\'):
                    lines.insert(0, linetxt)
                else:
                    break
                iLine -= 1
        if not preSectionOnly:
            maxlinenumber = self.GetLineCount() - 1
            iLine = linenumber + 1
            while iLine <= maxlinenumber:
                linetxt = self.GetLine(iLine)
                if lines[-1].strip().endswith('\\') or linetxt.strip().startswith('\\'):
                    lines.append(linetxt)
                else:
                    break
                iLine += 1
        return ' '.join([s.strip().strip('\\') for s in lines])

    def GetAviSynthVarType(self, strVar):
        strVar = strVar.strip()
        if not strVar:
            return 'empty'
        # Check int
        if strVar.isdigit():
            return 'int'
        # Check float
        try:
            float(strVar)
            return 'float'
        except ValueError:
            pass
        # Check hex number
        if strVar.startswith('$'):
            return 'hex'
        # Check boolean
        if strVar.lower() in ('true', 'false'):
            return 'bool'
        # Check string
        if strVar.startswith('"') and strVar.endswith('"'):
            return 'string'
        if strVar.startswith('"'):
            # Incomplete string...
            return 'string'
        # Check if it's a named argument
        if strVar.count('=') > 0:
            return 'named'
        # Check if it's the Avisynth variable last
        if strVar.lower() == 'last':
            return 'clip'
        # Heuristic...
        if strVar.count('.') > 0:
            name = strVar.split('.')[-1].split('(')[0].lower()
            if name in ('width', 'height', 'framecount'):
                return 'int'
            elif name in ('framerate',):
                return 'float'
            elif name.startswith('is'):
                return 'bool'
        # If none of the above, it's a variable name
        if self.AVI is not None:
            vartype = self.AVI.GetVarType(strVar)
            if vartype in ('int', 'float', 'string', 'bool' , 'array', 'func'):
                return vartype
        return 'var'

    def GetNextValidCommaPos(self, pos, checkChar=',', allowparentheses=False):
        nOpen = 0
        while pos <= self.GetLength():
            c = unichr(self.GetCharAt(pos))
            if c == '(' and not allowparentheses:
                pos = self.BraceMatch(pos)
                if pos == wx.NOT_FOUND:
                    return None
                continue
            if c == checkChar:
                if self.GetStyleAt(pos) not in (self.STC_AVS_STRING, self.STC_AVS_TRIPLE,
                        self.STC_AVS_USERSLIDER, self.STC_AVS_COMMENT, self.STC_AVS_COMMENT_2):
                    return pos
            pos += 1
        return None

    def ShowFilterDocumentation(self, name=None, onlyWeb=False):

        def get_names(name):
            name = name.lower()
            if name in self.avsfilterdict:
                display_name = self.avsfilterdict[name][2]
                if self.avsfilterdict[name][1] == AvsStyledTextCtrl.STC_AVS_PLUGIN:
                    is_short = self.avsfilterdict[name][3]
                    if is_short:
                        long_name = self.avsfilterdict[is_short][2]
                        short_name = display_name
                    else:
                        long_name = display_name
                        short_name = self.app.GetPluginFunctionShortName(long_name)
                    yield long_name[:-len(short_name) - 1]
                    yield short_name
                    yield long_name
                else:
                    yield display_name

        if name is None:
            name = self.calltipFilter
        if not name:
            return

        if not onlyWeb:
            docsearchpaths = []
            avisynthdir = self.app.ExpandVars(self.app.avisynthdir)
            docsearchpathstring = self.app.ExpandVars(self.app.options['docsearchpaths'])
            for path in docsearchpathstring.split(';'):
                path = path.strip()
                if os.path.isdir(path):
                    docsearchpaths.append(path)
            extensions = ['.htm', '.html', '.txt', '.lnk', '']

            for find_name in get_names(name):
                for dir in docsearchpaths:
                    filenames = []
                    for filename in os.listdir(dir):
                        base, ext = os.path.splitext(filename)
                        if ext in extensions:
                            if re.findall(r'(\b|[_\W]|readme)%s(\b|[_\W]|readme)' % find_name, base, re.IGNORECASE):
                                filenames.append((extensions.index(ext), filename))
                    if filenames:
                        filenames.sort()
                        filename = os.path.join(dir, filenames[0][1])
                        startfile(filename)
                        return True
        url = self.app.options['docsearchurl'].replace('%filtername%', name.replace('_', '+'))
        startfile(url)
        return False

    def GetFilterNameAtCursor(self, pos=None):
        if self.calltipFilter is not None:
            word = self.calltipFilter
        else:
            if pos is None:
                pos = self.GetCurrentPos()
            posA = self.WordStartPosition(pos, 1)
            posB = self.WordEndPosition(pos, 1)
            word = self.GetTextRange(posA, posB)
        return word

    def IsString(self, pos):
        if pos == self.GetTextLength():
            return self.IsString(pos - 1)
        return self.GetStyleAt(pos) in (self.STC_AVS_STRING, self.STC_AVS_TRIPLE, self.STC_AVS_STRINGEOL)

    def GetStringRange(self, pos):
        if not self.IsString(pos):
            return
        start = end = pos
        last_pos = self.GetTextLength()
        if pos == last_pos:
            start -= 1
        else:
            while end + 1 <= last_pos and self.IsString(end + 1):
                end += 1
        while start - 1 >= 0 and self.IsString(start - 1):
            start -= 1
        if self.GetStyleAt(start) == self.STC_AVS_TRIPLE:
            start += 3
            if self.GetStyleAt(end) != self.STC_AVS_STRINGEOL and end != last_pos:
                end -= 2
        else:
            start += 1
        return start, end

    def GenerateHTML(self, title=None, ext_css=None):
        """Return a HTML version of the text in the stc

        'ext_css' can be a filename for linking to an external style sheet.
        In that case a tuple (html, css) is returned
        """

        # Override face and size with the monospace font if used
        if self.app.options['usemonospacedfont']:
            monospaced = self.GenerateCSSBlock('monospaced', join=False)
            face = monospaced[self.css_properties['face']]
            size = monospaced[self.css_properties['size']]
            monospaced = face, size
        else:
            monospaced = None

        # Generate the body of the html and the style sheet
        # a complete sheet if external, otherwise only the needed styles
        # without inheritable declarations
        body = list()
        if not ext_css:
            default_css = self.GenerateCSSBlock('default', join=False,
                                                monospaced=monospaced)
            css = {'default': self.JoinCSSBlock('default', default_css)}
            default_css = default_css.items()
        last_style = self.GetStyleAt(0)
        style_start = 0
        length = self.GetLength()
        if not length:
            return
        for pos in xrange(0, length + 1):
            if pos != length:
                style = self.GetStyleAt(pos)
                if style == last_style:
                    continue
            style_name = self.styleInfo[last_style][0]
            if not ext_css and style_name not in css:
                css[style_name] = self.GenerateCSSBlock(style_name, default_css,
                                                        monospaced=monospaced)
            text = cgi.escape(self.GetTextRange(style_start, pos), True)
            if style_name != 'default':
                text = u'<span class="{0}">{1}</span>'.format(style_name, text)
            body.append(text)
            last_style = style
            style_start = pos
        body = u'<body>\n<pre class="default">\n{0}\n</pre>\n</body>'.format(
                                                                  ''.join(body))
        css =  self.GenerateCSS(monospaced=monospaced) if ext_css else \
               '\n'.join(css.values())

        # Generate the head, inserting the css if required
        title = cgi.escape(title or _('AviSynth script'), True)
        generator = cgi.escape(u'{0} v{1}'.format(global_vars.name,
                               global_vars.version), True)
        if ext_css:
            head_css = u'<link rel="stylesheet" type="text/css" '\
                        'href="{0}">'.format(ext_css)
        else:
            head_css = u'<style type="text/css">\n{0}\n</style>'.format(css)
        head = textwrap.dedent(u'''\
            <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
            "http://www.w3.org/TR/html4/strict.dtd">
            <html>
            <head>
            <meta http-equiv="content-type" content="text/html; charset=utf-8">
            <meta name="generator" content="{0}">
            <title>{1}</title>
            {2}
            </head>''').format(generator, title, head_css)

        # Return the html file, and optionally the style sheet
        html = u'{0}\n{1}\n</html>'.format(head, body)
        if ext_css:
            return html, css
        return html

    def GenerateCSS(self, monospaced=None):
        """Generate a style sheet from the styled text in the STC

        Override face and size with 'monospaced', if given
        """
        css = []
        for style, (key, extra) in self.styleInfo.iteritems():
            css.append(self.GenerateCSSBlock(key, monospaced=monospaced))
        return '\n'.join(css)

    def GenerateCSSBlock(self, style_name, default=None, monospaced=None, join=True):
        """Return a CSS block from a STC style

        Don't include in the block declarations in 'default', if given
        Override face and size with 'monospaced', if given
        """
        if not style_name in self.app.options['textstyles']:
            return ''
        if style_name == 'default' and default:
            default = None
        declarations = {}
        for attr in self.app.options['textstyles'][style_name].split(','):
            values = None
            splitted_attr = attr.split(':')
            if len(splitted_attr) == 1:
                if attr in self.stc_attr[0]:
                    values = self.css_properties[attr], attr
            elif len(splitted_attr) == 2:
                attr, value = splitted_attr
                if attr in self.stc_attr[1]:
                    if attr == 'face':
                        if monospaced:
                            value = monospaced[0]
                        else: # add fallback
                            if 'monospace' in style_name or 'string' in style_name:
                                fallback = 'monospace'
                            elif 'comment' in style_name or 'comment2' in style_name:
                                fallback = 'serif'
                            else:
                                fallback = 'sans-serif'
                            value = u'"{0}", {1}'.format(value, fallback)
                    elif attr == 'size':
                        if monospaced:
                            value = monospaced[1]
                        else: # specify unit
                            value += 'pt'
                    values = self.css_properties[attr], value
            if values and (not default or values not in default):
                declarations[values[0]] = values[1]
        if join:
            return self.JoinCSSBlock(style_name, declarations)
        return declarations

    @staticmethod
    def JoinCSSBlock(css_class, css):
        """Generate a CSS block from a property: value dict"""
        declarations = []
        for property, value in css.iteritems():
            declarations.append(u"\n\t{0}: {1};".format(property, value))
        return u".{0} {{{1}\n}}".format(css_class, ''.join(declarations))

    # Event functions

    def OnUpdateUI(self, event):
        # Get the character before the caret
        charBefore = None
        caretPos = self.GetCurrentPos()
        if caretPos > 0:
            charBefore = self.GetCharAt(caretPos - 1)
        # Highlight braces
        braceAtCaret = -1
        braceOpposite = -1
        # check before
        if charBefore and unichr(charBefore) in "[]{}()":# and styleBefore == stc.STC_P_OPERATOR:
            braceAtCaret = caretPos - 1
        # check after
        if braceAtCaret < 0:
            charAfter = self.GetCharAt(caretPos)
            if charAfter and unichr(charAfter) in "[]{}()":# and styleAfter == stc.STC_P_OPERATOR:
                braceAtCaret = caretPos
        if braceAtCaret >= 0:
            braceOpposite = self.BraceMatch(braceAtCaret)
        if braceOpposite == -1:
            self.BraceBadLight(braceAtCaret)
        else:
            self.BraceHighlight(braceAtCaret, braceOpposite)
        if self.GetStyleAt(braceAtCaret) in self.nonBraceStyles or self.GetStyleAt(braceOpposite) in self.nonBraceStyles:
            self.BraceHighlight(-1, -1)
        # Display call tips
        self.UpdateCalltip()
        self.flagTextChanged = False

    def x_CodeFolding(self):    # update folding level
        lineCount = self.GetLineCount()
        line = 0
        while line < lineCount:
            if self.GetFoldLevel(line) & stc.STC_FOLDLEVELHEADERFLAG:
                hasBrace = False
                hasBlock = False
                for pos in range(self.PositionFromLine(line), self.GetLineEndPosition(line)+1):
                    if unichr(self.GetCharAt(pos)) == '{' and self.GetStyleAt(pos) == self.STC_AVS_OPERATOR:
                        hasBrace = True
                        break
                if not hasBrace:
                    for pos in range(self.GetLineEndPosition(line), self.PositionFromLine(line)-1, -1):
                        if self.GetStyleAt(pos) == self.STC_AVS_BLOCKCOMMENT and self.GetStyleAt(pos-1) != self.STC_AVS_BLOCKCOMMENT:
                            hasBlock = True
                            break
                if hasBrace:
                    posMatch = self.BraceMatch(pos)
                    if posMatch != stc.STC_INVALID_POSITION:
                        lineEnd = self.LineFromPosition(posMatch) + 1
                        lastChild = self.GetLastChild(line, -1) + 1
                        if line+1 == lineEnd:
                            if not self.GetFoldExpanded(line):
                                self.SetFoldExpanded(line, True)
                                self.Expand(line, True)
                            self.SetFoldLevel(line, self.GetFoldLevel(line) & stc.STC_FOLDLEVELNUMBERMASK)
                    else:
                        lineEnd = lastChild = lineCount
                    level = (self.GetFoldLevel(line) & stc.STC_FOLDLEVELNUMBERMASK) + 1
                    for lineNum in range(line+1, lineEnd):
                        self.SetFoldLevel(lineNum, self.GetFoldLevel(lineNum) & 0xF000 | level)
                    for lineNum in range(lineEnd, lastChild):
                        self.SetFoldLevel(lineNum, self.GetFoldLevel(lineNum)-1)
                elif hasBlock:
                    end = pos
                    while self.GetStyleAt(end+1) == self.STC_AVS_BLOCKCOMMENT:
                        end += 1
                    lineEnd = self.LineFromPosition(end) + 1
                    lastChild = self.GetLastChild(line, -1) + 1
                    if line+1 == lineEnd:
                        if not self.GetFoldExpanded(line):
                            self.SetFoldExpanded(line, True)
                            self.Expand(line, True)
                        self.SetFoldLevel(line, self.GetFoldLevel(line) & stc.STC_FOLDLEVELNUMBERMASK)
                    else:
                        for lineNum in range(line+1, self.LineFromPosition(end)+1):
                            if self.GetFoldLevel(lineNum) & stc.STC_FOLDLEVELHEADERFLAG and not self.GetFoldExpanded(lineNum):
                                self.SetFoldExpanded(lineNum, True)
                                self.Expand(lineNum, True)
                        level = (self.GetFoldLevel(line) & stc.STC_FOLDLEVELNUMBERMASK) + 1
                        for lineNum in range(line+1, lineEnd):
                            self.SetFoldLevel(lineNum, self.GetFoldLevel(lineNum) & 0xF000 | level)
                        for lineNum in range(lineEnd, lastChild):
                            self.SetFoldLevel(lineNum, self.GetFoldLevel(lineNum)-1)
                elif self.GetStyleAt(self.PositionFromLine(line)) != self.STC_AVS_ENDCOMMENT and self.GetStyleAt(self.PositionFromLine(line+1)) == self.STC_AVS_ENDCOMMENT:
                    for lineNum in range(line+1, lineCount):
                        if self.GetFoldLevel(lineNum) & stc.STC_FOLDLEVELHEADERFLAG and not self.GetFoldExpanded(lineNum):
                            self.SetFoldExpanded(lineNum, True)
                            self.Expand(lineNum, True)
                        level = (self.GetFoldLevel(line) & stc.STC_FOLDLEVELNUMBERMASK) + 1
                    for lineNum in range(line+1, lineCount):
                        self.SetFoldLevel(lineNum, self.GetFoldLevel(lineNum) & 0xF000 | level)
                else:
                    if not self.GetFoldExpanded(line):
                        self.SetFoldExpanded(line, True)
                        self.Expand(line, True)
                    for lineNum in range(line+1, self.GetLastChild(line, -1)+1):
                        self.SetFoldLevel(lineNum, self.GetFoldLevel(lineNum)-1)
                    self.SetFoldLevel(line, self.GetFoldLevel(line)&stc.STC_FOLDLEVELNUMBERMASK)
            line += 1

    def OnTextChange(self, event):
        # GPo new, needed for autosnapshot
        if not self.flagModified:
            self.lastText = self.GetText()
            self.flagModified = self.lastText != ''
        ###
        if self.app.options['numlinechars']:
            self.fitNumberMarginWidth()
        self.flagTextChanged = True
        # Now OnContextMenu and MenuBar
        #self.app.currentScript.refreshAVI = True # this place is bad for preview filter

    def OnTextCharAdded(self, event):
        if unichr(event.GetKey()) == '\n':
            line = self.GetCurrentLine() - 1
            indentText = self.GetTextRange(self.PositionFromLine(line), self.GetLineIndentPosition(line))
            self.AddText(indentText)
            level = self.GetFoldLevel(line)
            if level & stc.STC_FOLDLEVELHEADERFLAG:
                self.SetFoldLevel(line + 1, level & stc.STC_FOLDLEVELNUMBERMASK)

    def OnNeedShown(self, event):
        line = self.LineFromPosition(event.GetPosition())
        lineEnd = self.LineFromPosition(event.GetPosition()+event.GetLength())
        while line < lineEnd:
            level = self.GetFoldLevel(line)
            if level & stc.STC_FOLDLEVELHEADERFLAG and not self.GetFoldExpanded(line):
                self.SetFoldExpanded(line, True)
                self.Expand(line, True)
            line += 1

    def OnKeyUp(self, event):
        keycode = event.GetKeyCode()
        # exit IsDClicked and selection (true/false/number process), see OnKeyDown
        if self.IsDClicked and self.GetSelections() > 0:
            if keycode in (wx.WXK_LEFT, wx.WXK_RIGHT):
                return
        pos = self.GetCurrentPos()
        keys = (wx.WXK_ESCAPE, wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER, wx.WXK_TAB)
        if keycode not in keys\
        and not self.AutoCompActive()\
        and not (self.CallTipActive() and self.app.options['calltipsoverautocomplete'])\
        and self.GetStyleAt(pos-1) not in self.nonBraceStyles:
            start = self.WordStartPosition(pos,1)
            end = self.WordEndPosition(pos,1)
            char = unichr(self.GetCharAt(start))
            if pos == end:
                if self.app.options['autocomplete']\
                and (char.isalpha() and char.isupper() or char == '_')\
                and pos - start == self.app.options['autocompletelength']:
                    wx.CallAfter(self.ShowAutocomplete, auto=1)
                elif self.app.options['autocompletesingle'] and char.isalpha():
                    wx.CallAfter(self.ShowAutocomplete, auto=2)
        event.Skip()

    def OnKeyDown(self,event):
        key = event.GetKeyCode()
        if self.IsDClicked and self.GetSelections() > 0:
            if key in (wx.WXK_LEFT, wx.WXK_RIGHT):
                self.app.OnMouseWheelScriptWindow(rotation = key != wx.WXK_LEFT, dec_first=False)
                return
        if (self.AutoCompActive() and self.autocomplete_case == 'function' and
            key in (wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER, wx.WXK_TAB) and
            not (event.ControlDown() or event.AltDown() or event.ShiftDown())):
                self.FinishAutocomplete(key=key)
        else:
            event.Skip()

    def OnMiddleDown(self,event):
        if self.app.options['numberwheel'] and not self.GetSelectedText().isdigit():
            self.IsDClicked = False
        xypos = event.GetPosition()
        self.GotoPos(self.PositionFromPoint(xypos))

    def OnMouseMotion(self,event):
        if event.MiddleIsDown():
            self.OnMiddleDown(event)
        elif event.LeftIsDown():
            xypos = event.GetPosition()
            self.SetCurrentPos(self.PositionFromPoint(xypos))

    def OnLeftMouseDown(self, event):
        #~ self.CallTipCancelCustom()
        self.IsDClicked = False
        event.Skip()

    def OnAutocompleteSelection(self, event):
        if self.autocomplete_case == 'function':
            event.Skip() # processing on EVT_KEY_DOWN, because we need event.GetKeyCode()
        elif self.autocomplete_case == 'parameter name':
            self.BeginUndoAction()
            event.Skip()
            def post_autocomplete(arg_name):
                # add an equals sign
                pos = self.GetCurrentPos()
                if unichr(self.GetCharAt(pos)) == '=':
                    self.GotoPos(pos + 1)
                else:
                    self.AddText('=')
                self.EndUndoAction()
                # autocomplete parameter value
                matched_args = self.autocomplete_params
                self.AutocompleteParameterValue(*matched_args[arg_name])
            wx.CallAfter(post_autocomplete, event.GetText())
        elif self.autocomplete_case == 'parameter value':
            # AutoCompSetDropRestOfWord doesn't include quotes
            pos = self.GetCurrentPos()
            self.SetTargetStart(pos)
            while unichr(self.GetCharAt(pos)) in (' ', '?') or self.IsString(pos):
                pos += 1
            self.SetTargetEnd(pos)
            self.BeginUndoAction()
            self.ReplaceTarget('')
            event.Skip()
            wx.CallAfter(self.EndUndoAction)
        elif self.autocomplete_case == 'filename':
            self.AutoCompCancel()
            pos0, start, end0, prefix, dir = self.autocomplete_params
            self.AutocompleteReplaceText(start, end0 + self.GetCurrentPos() - pos0,
                                         prefix, os.path.join(dir, event.GetText()))

    def OnUserListSelection(self, event):
        if self.autocomplete_case == 'snippet':
            start, end = self.autocomplete_params, self.GetCurrentPos()
            self.SetTargetStart(start)
            self.SetTargetEnd(end)
            self.GotoPos(start + self.ReplaceTarget(self.app.options['snippets'][event.GetText()]))

    def OnCalltipClick(self, event):
        if wx.GetKeyState(wx.WXK_CONTROL) or wx.GetKeyState(wx.WXK_SHIFT):
            self.ShowFilterDocumentation(onlyWeb=wx.GetKeyState(wx.WXK_SHIFT))
        else:
            self.CallTipCancelCustom()

    def OnKillFocus(self, event):
        self.CallTipCancelCustom()
        self.AutoCompCancel()
        event.Skip()

    def OnSetFocus(self, event):
        self.UpdateCalltip()
        event.Skip()

    def OnLeftDClick(self, event):
        if self.app.options['numberwheel']:
            self.IsDClicked = True
        event.Skip()

    def OnStyleNeeded(self, event, forceAll=False):
        if forceAll:
            start = -1
            line = 0
            isCommentNest = 0
            end = self.GetLength()
        else:
            pos = self.GetEndStyled()
            line = self.LineFromPosition(pos)
            start = self.PositionFromLine(line) - 1
            if self.GetStyleAt(start) == self.STC_AVS_BLOCKCOMMENT:
                isCommentNest = self.GetLineState(line - 1)
            else:
                isCommentNest = 0
            if self.app.options['wrap']: # workaround
                end = self.GetLineEndPosition(line + self.LinesOnScreen()) + 1
            else:
                end = event.GetPosition()
        if start < 1:
            start = 0
            state = self.STC_AVS_DEFAULT
        else:
            state = self.GetStyleAt(start)
            if state == self.STC_AVS_STRINGEOL:
                start += 1
                state = self.STC_AVS_DEFAULT
        isLoadPlugin = False
        flag = None # True -> start, False -> end
        if line and self.GetFoldLevel(line - 1) & stc.STC_FOLDLEVELHEADERFLAG:
            prev_flag = True
        else:
            prev_flag = None
        self.endstyled = pos = start
        fragment = []
        hexfragment = []
        triple_start = None
        # vpy hack, remove when VapourSynth is supported (with a custom Python lexer)
        string_delimiters = ['"', "'"] if self.filename.endswith('.vpy') else '"'
        self.StartStyling(pos, 31)
        while pos <= end:
            ch = unichr(self.GetCharAt(pos))
            isEOD = (ch == unichr(0))
            isEOL = (ch == '\n' or ch == '\r' or isEOD)
            if state == self.STC_AVS_DEFAULT:
                if ch == '#':
                    if unichr(self.GetCharAt(pos+1)) == '>':
                        state = self.STC_AVS_COMMENT_2
                    else: state = self.STC_AVS_COMMENT
                elif ch == '*' and unichr(self.GetCharAt(pos+1)) == '*' and unichr(self.GetCharAt(pos+2)) == '/': # GPo
                    state = self.STC_AVS_PREVIEWFILTER_END
                    pos += 2
                elif ch == '*' and unichr(self.GetCharAt(pos+1)) == '/': # GPo
                    state = self.STC_AVS_BLOCKCOMMENT
                    pos -= 1
                    #self.ColourTo(pos + 1, self.STC_AVS_BLOCKCOMMENT)
                    #pos += 1
                    #state = self.STC_AVS_DEFAULT
                    """
                    elif ch == '/' and unichr(self.GetCharAt(pos+1)) == '*' and unichr(self.GetCharAt(pos+2)) == '*':
                        line = self.LineFromPosition(pos)
                        txt = self.GetLine(line)
                        if txt.startswith('/**avsp_filter'):
                            state = self.STC_AVS_PREVIEWFILTER
                            #pFilter = True
                            pos += len(txt)-3
                        else:
                            pos += 1
                            flag = True
                            state = self.STC_AVS_BLOCKCOMMENT
                    """
                elif ch == '/' and unichr(self.GetCharAt(pos+1)) == '*':
                    # GPo
                    if unichr(self.GetCharAt(pos+2)) == '*':
                        line = self.LineFromPosition(pos)
                        txt = self.GetLine(line)
                        if txt.startswith('/**avsp_filter'):
                            state = self.STC_AVS_PREVIEWFILTER
                            #pFilter = True
                            pos += len(txt)-3
                        elif txt.startswith('/**avsp_split'):
                            #extra_flag = True
                            state = self.STC_AVS_SPLITCLIP
                            pos += 11
                        else:
                            pos += 4
                            flag = True
                            state = self.STC_AVS_BLOCKCOMMENT
                    else: # org
                        pos += 1
                        flag = True
                        state = self.STC_AVS_BLOCKCOMMENT
                elif ch in string_delimiters:
                    self.ColourTo(pos-1, state)
                    if unichr(self.GetCharAt(pos+1)) in string_delimiters and unichr(self.GetCharAt(pos+2)) in string_delimiters:
                        pos += 2
                        if self.app.options['syntaxhighlight_styleinsidetriplequotes']:
                            self.ColourTo(pos, self.STC_AVS_TRIPLE)
                        else:
                            triple_start = pos
                            state = self.STC_AVS_TRIPLE
                    else:
                        state = self.STC_AVS_STRING
                    if isLoadPlugin:
                        isLoadPlugin = pos
                elif ch == '$':
                    hexfragment = []
                    state = self.STC_AVS_NUMBERBAD
                elif ch == '[' and unichr(self.GetCharAt(pos+1)) == '*':
                    pos += 1
                    isCommentNest += 1
                    self.SetLineState(self.LineFromPosition(pos), isCommentNest)
                    flag = True
                    state = self.STC_AVS_BLOCKCOMMENT
                elif ch == '[' and unichr(self.GetCharAt(pos+1)) == '<':
                    pos += 1
                    state = self.STC_AVS_USERSLIDER
                elif ch.isalpha() or ch == '_' or ch in self.app.avssingleletters:
                    fragment = [ch]
                    state = self.STC_AVS_IDENTIFIER
                elif ch.isdigit():
                    state = self.STC_AVS_NUMBER
                elif ch in self.app.avsoperators:
                    self.ColourTo(pos - 1, state)
                    self.ColourTo(pos, self.STC_AVS_OPERATOR)
                    if ch == '{':
                        flag = True
                    elif ch == '}':
                        flag = None if flag else False
                else:
                    if isEOD:
                        self.ColourTo(pos - 1, self.STC_AVS_DEFAULT)
                    else:
                        self.ColourTo(pos, self.STC_AVS_DEFAULT)

            elif state == self.STC_AVS_COMMENT:
                if isEOL:
                    if isEOD:
                        self.ColourTo(pos - 1, self.STC_AVS_COMMENT)
                    else:
                        self.ColourTo(pos, self.STC_AVS_COMMENT)
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_COMMENT_2:
                """
                self.ColourTo(pos, self.STC_AVS_COMMENT_2)
                state = self.STC_AVS_DEFAULT
                """
                if isEOL:
                    if isEOD:
                        self.ColourTo(pos - 1, self.STC_AVS_COMMENT_2)
                    else:
                        self.ColourTo(pos, self.STC_AVS_COMMENT_2)
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_PREVIEWFILTER_END: # GPo
                #pFilter = False
                if isEOL:
                    if isEOD:
                        #if not extra_flag:
                        self.ColourTo(pos-1, self.STC_AVS_PREVIEWFILTER_END)
                        #else:
                            #self.ColourTo(pos-1, self.STC_AVS_DEFAULT)
                    else:
                        #if not extra_flag:
                        self.ColourTo(pos, self.STC_AVS_PREVIEWFILTER_END)
                        #else:
                            #self.ColourTo(pos, self.STC_AVS_DEFAULT)
                    #extra_flag = False
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_PREVIEWFILTER: # GPo
                if isEOL:
                    if isEOD:
                        self.ColourTo(pos - 1, self.STC_AVS_PREVIEWFILTER)
                    else:
                        self.ColourTo(pos, self.STC_AVS_PREVIEWFILTER)
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_SPLITCLIP:
                #if isEOL: # then for the complete line
                    if isEOD:
                        self.ColourTo(pos - 1, self.STC_AVS_SPLITCLIP)
                    else:
                        self.ColourTo(pos, self.STC_AVS_SPLITCLIP)
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_BLOCKCOMMENT:
                if isEOD or pos == end:
                    self.ColourTo(pos - 1, self.STC_AVS_BLOCKCOMMENT)
                elif isEOL:
                    self.SetLineState(self.LineFromPosition(pos), isCommentNest)
                elif isCommentNest:
                    if ch == '*' and unichr(self.GetCharAt(pos+1)) == ']':
                        pos += 1
                        isCommentNest -= 1
                        self.SetLineState(self.LineFromPosition(pos), isCommentNest)
                        flag = None if flag else False
                        if not isCommentNest:
                            self.ColourTo(pos, self.STC_AVS_BLOCKCOMMENT)
                            state = self.STC_AVS_DEFAULT
                    elif ch == '[' and unichr(self.GetCharAt(pos+1)) == '*':
                        pos += 1
                        isCommentNest += 1
                        self.SetLineState(self.LineFromPosition(pos), isCommentNest)
                        flag = True
                elif ch == '*' and unichr(self.GetCharAt(pos+1)) == '/':
                    pos += 1
                    self.ColourTo(pos, self.STC_AVS_BLOCKCOMMENT)
                    flag = None if flag else False
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_IDENTIFIER:
                if fragment[0] not in self.app.avssingleletters and (ch.isalnum() or ch == '_'):
                    fragment.append(ch)
                else:
                    pos2 = pos
                    pos -= 1
                    word =''.join(fragment).lower()
                    while unichr(self.GetCharAt(pos2)) in (u' ', u'\t'):
                        pos2 += 1
                    ch2 = unichr(self.GetCharAt(pos2))
                    if word in self.app.avsdatatypes and unichr(self.GetCharAt(pos+1)).isspace():
                        self.ColourTo(pos, self.STC_AVS_DATATYPE)
                    elif word in self.app.avskeywords:
                        self.ColourTo(pos, self.STC_AVS_KEYWORD)
                    elif word in self.app.avsmiscwords:
                        self.ColourTo(pos, self.STC_AVS_MISCWORD)
                        if word == '__end__':
                            line = self.LineFromPosition(pos)
                            self.UpdateFolding(line, True, prev_flag)
                            level = (self.GetFoldLevel(line) & stc.STC_FOLDLEVELNUMBERMASK) + 1
                            for line in range(line + 1, self.LineFromPosition(end) + 1):
                                self.SetFoldLevel(line, level)
                            self.ColourTo(end, self.STC_AVS_ENDCOMMENT)
                            break
                    elif ch2 == u'(':
                        if word in self.avsfilterdict:
                            #~ self.ColourTo(pos, self.keywordstyles[word])
                            self.ColourTo(pos, self.avsfilterdict[word][1])
                            if word == 'loadplugin':
                                isLoadPlugin = True
                        else:
                            self.ColourTo(pos, self.STC_AVS_UNKNOWNFUNCTION)
                    elif ch2 == u'=' and unichr(self.GetCharAt(pos2 + 1)) != '=':
                        if self.GetOpenParenthesesPos(pos - len(word)):
                            self.ColourTo(pos, self.STC_AVS_PARAMETER)
                        else:
                            self.ColourTo(pos, self.STC_AVS_ASSIGN)
                    else:
                        if self.app.options['syntaxhighlight_preferfunctions'] and \
                                word in self.avsfilterdict:
                            self.ColourTo(pos, self.avsfilterdict[word][1])
                        else:
                            self.ColourTo(pos, self.STC_AVS_DEFAULT)
                    fragment = []
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_STRING:
                if self.app.options['usestringeol']:
                    if unichr(self.GetCharAt(pos-1)) in string_delimiters and unichr(self.GetCharAt(pos)) in string_delimiters and unichr(self.GetCharAt(pos+1)) in string_delimiters:
                        state = self.STC_AVS_TRIPLE
                        pos += 1
                    elif ch in string_delimiters or isEOL:
                        if isEOL:
                            if isEOD:
                                self.ColourTo(pos - 1, self.STC_AVS_STRINGEOL)
                            else:
                                self.ColourTo(pos, self.STC_AVS_STRINGEOL)
                            isLoadPlugin = False
                        else:
                            self.ColourTo(pos, self.STC_AVS_STRING)
                            if isLoadPlugin:
                                self.parseDllname(isLoadPlugin, pos)
                                isLoadPlugin = False
                        state = self.STC_AVS_DEFAULT
                else:
                    if unichr(self.GetCharAt(pos-1)) in string_delimiters and unichr(self.GetCharAt(pos)) in string_delimiters and unichr(self.GetCharAt(pos+1)) in string_delimiters:
                        state = self.STC_AVS_TRIPLE
                        pos += 1
                    elif ch in string_delimiters:
                        self.ColourTo(pos, self.STC_AVS_STRING)
                        state = self.STC_AVS_DEFAULT
                        if isLoadPlugin:
                            self.parseDllname(isLoadPlugin, pos)
                            isLoadPlugin = False
                    elif isEOD:
                        self.ColourTo(pos - 1, self.STC_AVS_STRING)
                        state = self.STC_AVS_DEFAULT
                        isLoadPlugin = False
            elif state == self.STC_AVS_TRIPLE:
                if triple_start is None:
                    triple_start = self.GetStringRange(pos)[0]
                # AviSynth interprets """"""" as '"' etc.
                triple_quote_quirk = False
                if ch == '"' and pos - triple_start == 1:
                    last_quote_pos = pos
                    while unichr(self.GetCharAt(last_quote_pos)) == '"':
                        last_quote_pos += 1
                    quote_number = last_quote_pos - pos
                    if quote_number > 3:
                        pos += quote_number - 1 - 1
                        triple_quote_quirk = True
                if not triple_quote_quirk:
                    if isEOD or ((pos - triple_start > 2) and ch in string_delimiters and unichr(self.GetCharAt(pos-1)) in string_delimiters and unichr(self.GetCharAt(pos-2)) in string_delimiters):
                        self.ColourTo(pos, self.STC_AVS_TRIPLE)
                        state = self.STC_AVS_DEFAULT
                        triple_start = None
                        if isLoadPlugin:
                            if not isEOD:
                                self.parseDllname(isLoadPlugin, pos)
                            isLoadPlugin = False
                    elif isEOL:
                        self.ColourTo(pos, self.STC_AVS_TRIPLE)
            elif state == self.STC_AVS_NUMBER:
                if not ch.isdigit():
                    pos -= 1
                    self.ColourTo(pos, self.STC_AVS_NUMBER)
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_NUMBERBAD:
                if ch.isalnum() or ch == '_':
                    hexfragment.append(ch)
                else:
                    pos -= 1
                    try:
                        int(''.join(hexfragment), 16)
                        self.ColourTo(pos, self.STC_AVS_NUMBER)
                    except:
                        self.ColourTo(pos, self.STC_AVS_NUMBERBAD)
                    hexfragment = []
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_USERSLIDER:
                if isEOL or (ch == ']' and unichr(self.GetCharAt(pos-1)) == '>'):
                    if isEOL:
                        self.ColourTo(pos, self.STC_AVS_NUMBERBAD)
                    else:
                        self.ColourTo(pos, self.STC_AVS_USERSLIDER)
                    state = self.STC_AVS_DEFAULT
            elif state == self.STC_AVS_ENDCOMMENT:
                line = self.LineFromPosition(pos)
                if self.GetStyleAt(self.PositionFromLine(line)) != self.STC_AVS_ENDCOMMENT:
                    line += 1
                level = (self.GetFoldLevel(line) & stc.STC_FOLDLEVELNUMBERMASK)
                for line in range(line, self.LineFromPosition(end) + 1):
                    self.SetFoldLevel(line, level)
                self.ColourTo(end, self.STC_AVS_ENDCOMMENT)
                break

            ch = unichr(self.GetCharAt(pos))
            if pos != start and (ch == unichr(0) or ch == '\n' or ch == '\r'):
                self.UpdateFolding(self.LineFromPosition(pos), flag, prev_flag)
                prev_flag = flag
                flag = None
            pos += 1

        if wx.VERSION > (2, 9):
            wx.CallAfter(self.Refresh)

    def ColourTo(self, pos, style):
        self.SetStyling(pos +1 - self.endstyled, style)
        self.endstyled = pos+1

    def parseDllname(self, start, end):
        path = self.GetTextRange(start, end).lower().strip('"')
        #~ print path
        ext = os.path.splitext(path)[1]
        if ext in ('.dll', '.so'):
            dllname = os.path.basename(path[:-len(ext)])
            if dllname.count('_') and dllname not in self.app.dllnameunderscored:
                self.app.dllnameunderscored.add(dllname)
                self.app.defineScriptFilterInfo()

    def UpdateFolding(self, line, flag, prev_flag):
        if line == 0:
            level = stc.STC_FOLDLEVELBASE
        else:
            level = self.GetFoldLevel(line - 1) & stc.STC_FOLDLEVELNUMBERMASK
            if prev_flag:
                level += 1
        if flag == True:
            level |= stc.STC_FOLDLEVELHEADERFLAG
        elif flag == False:
            level = max(stc.STC_FOLDLEVELBASE, level - 1)
        elif not self.GetLine(line).strip():
            level |=  stc.STC_FOLDLEVELWHITEFLAG
        self.SetFoldLevel(line, level)

    def OnMarginClick(self, evt):
        # fold and unfold as needed
        if evt.GetMargin() == 2:
            if evt.GetShift() and evt.GetControl():
                self.FoldAll()
            else:
                lineClicked = self.LineFromPosition(evt.GetPosition())

                if self.GetFoldLevel(lineClicked) & stc.STC_FOLDLEVELHEADERFLAG:
                    if evt.GetShift():
                        self.SetFoldExpanded(lineClicked, True)
                        self.Expand(lineClicked, True, True, 1)
                    elif evt.GetControl():
                        if self.GetFoldExpanded(lineClicked):
                            self.SetFoldExpanded(lineClicked, False)
                            self.Expand(lineClicked, False, True, 0)
                        else:
                            self.SetFoldExpanded(lineClicked, True)
                            self.Expand(lineClicked, True, True, 100)
                    else:
                        self.ToggleFold(lineClicked)

    def FoldAll(self):
        if self.GetEndStyled() != self.GetLength():
            self.OnStyleNeeded(None, forceAll=True)
        lineCount = self.GetLineCount()
        expanding = True

        # find out if we are folding or unfolding
        for lineNum in range(lineCount):
            if self.GetFoldLevel(lineNum) & stc.STC_FOLDLEVELHEADERFLAG:
                expanding = not self.GetFoldExpanded(lineNum)
                break

        lineNum = 0

        while lineNum < lineCount:
            level = self.GetFoldLevel(lineNum)
            if level & stc.STC_FOLDLEVELHEADERFLAG and \
               (level & stc.STC_FOLDLEVELNUMBERMASK) == stc.STC_FOLDLEVELBASE:

                if expanding:
                    self.SetFoldExpanded(lineNum, True)
                    lineNum = self.Expand(lineNum, True)
                    lineNum = lineNum - 1
                else:
                    lastChild = self.GetLastChild(lineNum, -1)
                    self.SetFoldExpanded(lineNum, False)

                    if lastChild > lineNum:
                        self.HideLines(lineNum+1, lastChild)

            lineNum = lineNum + 1

    def Expand(self, line, doExpand, force=False, visLevels=0, level=-1):
        lastChild = self.GetLastChild(line, level)
        line = line + 1

        while line <= lastChild:
            if force:
                if visLevels > 0:
                    self.ShowLines(line, line)
                else:
                    self.HideLines(line, line)
            else:
                if doExpand:
                    self.ShowLines(line, line)

            if level == -1:
                level = self.GetFoldLevel(line)

            if level & stc.STC_FOLDLEVELHEADERFLAG:
                if force:
                    if visLevels > 1:
                        self.SetFoldExpanded(line, True)
                    else:
                        self.SetFoldExpanded(line, False)

                    line = self.Expand(line, doExpand, force, visLevels-1)

                else:
                    if doExpand and self.GetFoldExpanded(line):
                        line = self.Expand(line, True, force, visLevels-1)
                    else:
                        line = self.Expand(line, False, force, visLevels-1)
            else:
                line = line + 1

        return line

# Dialog for choosing AviSynth specific fonts and colors
class AvsStyleDialog(wx.Dialog):
    # TODO: add export and import styles, macros to import...
    def __init__(self, parent, dlgInfo, options, defaults, colour_data=None, extra=None, title=_('AviSynth fonts and colors')):
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title)
        SetFontPPI(self)
        self.dlgInfo = dlgInfo
        for key in parent.defaulttextstylesDict['Default'].keys(): # GPo 2021, make sure all new colors added
            if not key in options:
                options[key] = parent.defaulttextstylesDict['Default'][key]
        self.options = options.copy()
        self.defaults = defaults
        self.colour_data = colour_data
        # Create the font buttons
        self.controls = {}
        self.controls2 = {}
        self.notebook = wxp.Notebook(self, wx.ID_ANY, style=wx.NO_BORDER,
                                     invert_scroll=self.GetParent().options['invertscrolling'])
        if ppi_factor > 1:
            self.notebook.SetTabSize((-1, intPPI(23)))
            SetFontPPI(self.notebook)
        """ not used! Check and Remove
        def OnNotebookPageChanged(event):
            event.GetEventObject().GetCurrentPage().SetFocus()
            event.Skip()
        """
        for tabLabel, tabInfo in dlgInfo:
            tabPanel = wx.Panel(self.notebook, wx.ID_ANY)
            self.notebook.AddPage(tabPanel, tabLabel)
            sizer = wx.FlexGridSizer(cols=4, hgap=intPPI(20), vgap=intPPI(5))
            sizer.Add((0,0), 0)
            for label in ( _('Font'), _('Text color'), _('Background')):
                staticText = wx.StaticText(tabPanel, wx.ID_ANY, label)
                font = staticText.GetFont()
                font.SetUnderlined(True)
                font.SetWeight(wx.FONTWEIGHT_BOLD)
                font.SetPointSize(intPPI(font.GetPointSize())) # leave PointSize !!
                staticText.SetFont(font)
                sizer.Add(staticText, flag=wx.ALIGN_CENTER)
            for label, key in tabInfo:
                (fontSize, fontStyle, fontWeight, fontUnderline,
                fontFace, fontFore, fontBack) = self.ParseStyleInfo(options[key].split(','))
                if fontFace is not None:
                    font = wx.Font(fontSize, wx.FONTFAMILY_DEFAULT, fontStyle, fontWeight, fontUnderline, faceName=fontFace)
                else:
                    font = None
                # Create the controls
                if type(label) is tuple:
                    label, optKey, tip = label
                    staticText = checkbox = wx.CheckBox(tabPanel, wx.ID_ANY, label)
                    checkbox.SetValue(parent.options[optKey])
                    checkbox.SetToolTipString(tip)
                    self.controls2[optKey] = checkbox
                else:
                    staticText = wx.StaticText(tabPanel, wx.ID_ANY, label)
                if font is not None:
                    fontLabel = '%s, %d' % (fontFace, fontSize)
                    fontButton = wxButtons.GenButton(tabPanel, wx.ID_ANY, label=fontLabel)
                    fontButton.SetUseFocusIndicator(False)
                    fontButton.SetFont(font)
                    self.Bind(wx.EVT_BUTTON, self.OnButtonFont, fontButton)
                else:
                    fontButton = None
                if fontFore is not None:
                    foreButton = wxp.ColourSelect(tabPanel, wx.ID_ANY, colour=wx.Colour(*fontFore), size=tuplePPI(50,23), colour_data=self.colour_data)
                else:
                    foreButton = None
                if fontBack is not None:
                    backButton = wxp.ColourSelect(tabPanel, wx.ID_ANY, colour=wx.Colour(*fontBack), size=tuplePPI(50,23), colour_data=self.colour_data)
                else:
                    backButton = None
                sizer.Add(staticText, flag=wx.ALIGN_CENTER)
                if fontButton is not None:
                    sizer.Add(fontButton, flag=wx.ALIGN_CENTER)
                else:
                    sizer.Add((0,0), flag=wx.ALIGN_CENTER)
                if foreButton is not None:
                    sizer.Add(foreButton, flag=wx.ALIGN_CENTER)
                else:
                    sizer.Add((0,0), flag=wx.ALIGN_CENTER)
                if backButton is not None:
                    sizer.Add(backButton, flag=wx.ALIGN_CENTER)
                else:
                    sizer.Add((0,0), flag=wx.ALIGN_CENTER)
                self.controls[key] = (fontButton, foreButton, backButton)
            tabSizer = wx.BoxSizer(wx.VERTICAL)
            tabSizer.Add(sizer, 0, wx.ALL, intPPI(10))
            tabPanel.SetSizerAndFit(tabSizer)
        self.notebook.SetSelection(0)
        # Standard (and not standard) buttons
        themes = [_('Select a predefined theme')] + parent.defaulttextstylesDict.keys()
        theme_choice = wx.Choice(self, choices=themes)
        theme_choice.SetSelection(0)
        self.Bind(wx.EVT_CHOICE, self.OnSelectTheme, theme_choice)
        only_colors_checkbox = wx.CheckBox(self, wx.ID_ANY, _('Only change colours'))
        only_colors_checkbox.SetValue(parent.options['theme_set_only_colors'])
        only_colors_checkbox.SetToolTipString(_("When selecting a theme, don't change current fonts"))
        self.controls2['theme_set_only_colors'] = only_colors_checkbox
        okay = wx.Button(self, wx.ID_OK, _('OK'))
        self.Bind(wx.EVT_BUTTON, self.OnButtonOK, okay)
        cancel = wx.Button(self, wx.ID_CANCEL, _('Cancel'))
        btns = wx.StdDialogButtonSizer()
        if extra: # single CheckBox
            label, optKey, tip = extra
            checkbox = wx.CheckBox(self, wx.ID_ANY, label)
            checkbox.SetValue(parent.options[optKey])
            checkbox.SetToolTipString(tip)
            self.controls2[optKey] = checkbox
            btns.Add(checkbox, 0, wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, intPPI(3))
        btns.Add(theme_choice, 0, wx.LEFT | wx.RIGHT, intPPI(3))
        btns.Add(only_colors_checkbox, 0, wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, intPPI(3))
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        # Size the elements
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add(self.notebook, 0, wx.EXPAND|wx.ALL, intPPI(5))
        dlgSizer.Add(btns, 0, wx.EXPAND|wx.ALL, intPPI(10))
        self.SetSizer(dlgSizer)
        dlgSizer.Fit(self)
        self.sizer = dlgSizer
        # Misc
        okay.SetDefault()
        self.Centre(wx.CENTRE_ON_SCREEN)

    @staticmethod
    def ParseStyleInfo(styleInfo):
        # Get the style info (face, size, bold/italic/underline, color, background)
        (fontSize, fontStyle, fontWeight, fontUnderline,
        fontFace, fontFore, fontBack) = (intPPI(10), wx.FONTSTYLE_NORMAL,
        wx.FONTWEIGHT_NORMAL, False, None, None, None)
        for info in styleInfo:
            infolower = info.lower().strip()
            if infolower.startswith('face:'):
                fontFace = info[5:]
            elif infolower.startswith('size:'):
                fontSize = int(info[5:])
            elif infolower.startswith('fore:'):
                color = info.split(':')[1].strip().lstrip('#')
                r = int(color[0:2], 16)
                g = int(color[2:4], 16)
                b = int(color[4:6], 16)
                fontFore = (r, g, b)
            elif infolower.startswith('back:'):
                color = info.split(':')[1].strip().lstrip('#')
                r = int(color[0:2], 16)
                g = int(color[2:4], 16)
                b = int(color[4:6], 16)
                fontBack = (r, g, b)
            elif infolower =='bold':
                fontWeight = wx.FONTWEIGHT_BOLD
            elif infolower =='italic':
                fontStyle = wx.FONTSTYLE_ITALIC
            elif infolower =='underline':
                fontUnderline = True
        return (fontSize, fontStyle, fontWeight, fontUnderline,
                fontFace, fontFore, fontBack)

    def OnSelectTheme(self, event):
        theme = event.GetEventObject().GetStringSelection()
        if theme != _('Select a predefined theme'):
            return self.SetTheme(theme, only_colors=
                            self.controls2['theme_set_only_colors'].GetValue())

    def SetTheme(self, theme, only_colors=False):
        for tabLabel, tabInfo in self.dlgInfo:
            for label, key in tabInfo:
                fontButton, foreButton, backButton = self.controls[key]
                (fontSize, fontStyle, fontWeight, fontUnderline,
                fontFace, fontFore, fontBack) = self.ParseStyleInfo(self.defaults[theme][key].split(','))
                if not only_colors and fontButton is not None and fontFace is not None:
                    font = wx.Font(fontSize, wx.FONTFAMILY_DEFAULT, fontStyle,
                                   fontWeight, fontUnderline, faceName=fontFace)
                    fontButton.SetLabel('%s, %d' % (fontFace, fontSize))
                    fontButton.SetFont(font)
                    fontButton.SetBestSize()
                    fontButton.Refresh()
                if foreButton is not None and fontFore is not None:
                    foreButton.SetColour(wx.Colour(*fontFore))
                if backButton is not None and fontBack is not None:
                    backButton.SetColour(wx.Colour(*fontBack))
            self.sizer.Fit(self)

    def OnButtonOK(self, event):
        if self.UpdateDict():
            event.Skip()

    def OnButtonFont(self, event):
        button = event.GetEventObject()
        font = button.GetFont()
        # Show the font dialog
        data = wx.FontData()
        data.EnableEffects(False)
        data.SetInitialFont(font)
        dlg = wx.FontDialog(self, data)
        if dlg.ShowModal() == wx.ID_OK:
            data = dlg.GetFontData()
            font = data.GetChosenFont()
            fontFace = font.GetFaceName()
            fontSize = font.GetPointSize()
            fontLabel = '%s, %d' % (fontFace, fontSize)
            button.SetLabel(fontLabel)
        button.SetFont(font)
        button.SetBestSize()
        button.Refresh()
        self.sizer.Fit(self)
        dlg.Destroy()

    def GetDict(self):
        return self.options

    def GetDict2(self):
        for key in self.controls2:
            self.controls2[key] = self.controls2[key].GetValue()
        return self.controls2

    def UpdateDict(self):
        for key, value in self.controls.items():
            styleList = []
            fontButton, foreButton, backButton = value
            if fontButton is not None:
                font = fontButton.GetFont()
                styleList.append('face:%s' % font.GetFaceName())
                styleList.append('size:%i' % font.GetPointSize())
            if foreButton is not None:
                styleList.append('fore:#%02x%02x%02x' % foreButton.GetColour().Get())
            if backButton is not None:
                styleList.append('back:#%02x%02x%02x' % backButton.GetColour().Get())
            if fontButton is not None:
                if font.GetWeight() == wx.FONTWEIGHT_BOLD:
                    styleList.append('bold')
                if font.GetStyle() == wx.FONTSTYLE_ITALIC:
                    styleList.append('italic')
                if font.GetUnderlined():
                    styleList.append('underlined')
            stylestring = ','.join(styleList)
            self.options[key] = stylestring
        return True

# Printing
class STCPrintout(wx.Printout):
    """Specific printing support of the wx.StyledTextCtrl for the wxPython
    framework

    This class can be used for both printing to a printer and for print
    preview functions.

    """
    debuglevel = 0

    def __init__(self, stc, page_setup_data, print_mode=None, header=True,
                 title='', job_title='', border=False, zoom=False,
                 wrap=None):
        """Constructor.

        stc: wx.StyledTextCtrl to print

        page_setup_data: wx.PageSetupDialogData instance that
        is used to determine the margins of the page.

        print_mode: optional; of the wx.stc.STC_PRINT_* flags indicating
        how to render color text.  Defaults to
        wx.stc.STC_PRINT_COLOURONWHITEDEFAULTBG

        header: optional flag indicating whether or not to include a header
        on every page with the title and page number

        title: optional text string to use as the title, if header is True

        job_title: optional text string used to identify the job in the
        printing list

        border: optional flag indicating whether or not to draw a black
        border around the text on each page

        zoom: optional flag indicating whether or not to apply stc's
        current magnification to the output

        wrap: optional flag indicating whether or not to word-wrap long lines

        """
        if not job_title:
            job_title = wx.PrintoutTitleStr
        wx.Printout.__init__(self, job_title)
        self.stc = stc
        self.page_setup_data = page_setup_data
        if print_mode:
            self.print_mode = print_mode
        else:
            self.print_mode = wx.stc.STC_PRINT_COLOURONWHITEDEFAULTBG
        self.header = header
        if self.header:
            self.setHeaderFont()
            self.title = title
        self.stc.SetPrintMagnification(self.stc.GetZoom() if zoom else 0)
        if wrap is not None:
            self.stc.SetPrintWrapMode(wx.stc.STC_WRAP_WORD if wrap else
                                      wx.stc.STC_WRAP_NONE)
        self.border_around_text = border

    def OnPreparePrinting(self):
        """Called once before a print job is started to set up any defaults."""
        self.MapScreenSizeToPageMargins(self.page_setup_data)
        dc = self.GetDC()
        self._calculatePageStarts(dc)

    def _calculatePageStarts(self, dc):
        """Calculates offsets into the STC for each page

        This pre-calculates the page offsets for each page to support print
        preview being able to seek backwards and forwards.
        """
        if self.header:
            # Set font for title/page number rendering
            dc.SetFont(self.getHeaderFont())
            # Title
            self.header_height = dc.GetTextExtent(self.title)[1]
            # Page Number
            page_lbl = _("Page:")
            self.header_height = 1.5 * max(self.header_height,
                                           dc.GetTextExtent(page_lbl)[1])
        else:
            self.header_height = 0

        self.stc.SetPrintColourMode(self.print_mode)
        edge_mode = self.stc.GetEdgeMode()
        self.stc.SetEdgeMode(wx.stc.STC_EDGE_NONE)
        stc_len = self.stc.GetLength()
        self.start_points = [0]
        rect = self.GetLogicalPageMarginsRect(self.page_setup_data)
        rect[2] -= self.stc.GetMarginWidth(0)
        rect[1] += self.header_height
        rect[3] -= self.header_height
        if self.debuglevel > 0:
            print("prepare rect: ", rect)
        while self.start_points[-1] < stc_len:
            self.start_points.append(self.stc.FormatRange(False,
                                    self.start_points[-1], stc_len,
                                    dc, dc, rect, rect))
            if self.debuglevel > 0:
                if self.start_points[-1] == stc_len:
                    print("prepare printing - reached end of document: %d" % stc_len)
                else:
                    print ("prepare printing - page %d first line: %d" % (
                           len(self.start_points), self.start_points[-1]))
        self.stc.SetEdgeMode(edge_mode)

    def GetPageInfo(self):
        """Return the valid page ranges. Note that pages are numbered starting from one."""
        return (1, len(self.start_points) - 1, 1, len(self.start_points) - 1)

    def HasPage(self, page):
        """Returns True if the specified page is within the page range"""
        return page < len(self.start_points)

    def OnPrintPage(self, page):
        """Draws the specified page to the DC. page: page number to render"""
        self.MapScreenSizeToPageMargins(self.page_setup_data)
        dc = self.GetDC()
        self._drawPageContents(dc, page)
        if self.header:
            self._drawPageHeader(dc, page)
        if self.border_around_text:
            self._drawPageBorder(dc)
        return True

    def _drawPageContents(self, dc, page):
        """Render the STC window into a DC for printing.

        dc: the device context representing the page
        page: page number
        """
        self.stc.SetPrintColourMode(self.print_mode)
        edge_mode = self.stc.GetEdgeMode()
        self.stc.SetEdgeMode(wx.stc.STC_EDGE_NONE)
        stc_len = self.stc.GetLength()
        rect = self.GetLogicalPageMarginsRect(self.page_setup_data)
        rect[2] -= self.stc.GetMarginWidth(0)
        rect[1] += self.header_height
        rect[3] -= self.header_height
        next = self.stc.FormatRange(True, self.start_points[page-1], stc_len,
                                    dc, dc, rect, rect)
        self.stc.SetEdgeMode(edge_mode)
        if self.debuglevel > 0:
            print("print rect: ", rect)
            if next == stc_len:
                print("printing - reached end of document: %d" % stc_len)
            else:
                print("printing - page %d first line: %d" % (page + 1, next))

    def _drawPageHeader(self, dc, page):
        """Draw the page header into the DC for printing
        dc: the device context representing the page
        page: page number
        """
        rect = self.GetLogicalPageMarginsRect(self.page_setup_data)
        # Set font for title/page number rendering
        dc.SetFont(self.getHeaderFont())
        dc.SetTextForeground ("black")
        # Title
        if self.title:
            dc.DrawText(self.title, rect[0], rect[1])
        # Page Number
        page_lbl = _("Page: %d") % page
        pg_lbl_w, pg_lbl_h = dc.GetTextExtent(page_lbl)
        dc.DrawText(page_lbl, rect[2] - pg_lbl_w, rect[1])

    def setHeaderFont(self, point_size=intPPI(10), family=wx.FONTFAMILY_SWISS,
                      style=wx.FONTSTYLE_NORMAL, weight=wx.FONTWEIGHT_NORMAL):
        """Set the font to be used as the header font

        point_size: point size of the font

        family: one of the wx.FONTFAMILY_* values, e.g.
        wx.FONTFAMILY_SWISS, wx.FONTFAMILY_ROMAN, etc.

        style: one of the wx.FONTSTYLE_* values, e.g.
        wxFONTSTYLE_NORMAL, wxFONTSTYLE_ITALIC, etc.

        weight: one of the wx.FONTWEIGHT_* values, e.g.
        wx.FONTWEIGHT_NORMAL, wx.FONTWEIGHT_LIGHT, etc.

        """
        self.header_font_point_size = point_size
        self.header_font_family = family
        self.header_font_style = style
        self.header_font_weight = weight

    def getHeaderFont(self):
        """Returns the font to be used to draw the page header text
        returns: wx.Font instance
        """
        point_size = self.header_font_point_size
        font = wx.Font(point_size, self.header_font_family,
                       self.header_font_style, self.header_font_weight)
        return font

    def _drawPageBorder(self, dc):
        """Draw the page border into the DC for printing
        dc: the device context representing the page
        """
        dc.SetPen(wx.BLACK_PEN)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.DrawRectangleRect(self.GetLogicalPageMarginsRect(self.page_setup_data))

# SplitClip Control test with slider
"""
class SplitClipCtrl(wx.Dialog):
    def __init__(self, parent, title=_('SplitClip'), pos=wx.DefaultPosition, size=tuplePPI(600,300)):
        style = wx.DEFAULT_DIALOG_STYLE | wx.STAY_ON_TOP | wx.RESIZE_BORDER | wx.FRAME_FLOAT_ON_PARENT# | wx.NO_FULL_REPAINT_ON_RESIZE | wx.CLIP_CHILDREN
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title, pos, size, style=style)
        dpi.SetFontPPI(self)
        self.parent = parent
        self.Bind(wx.EVT_CLOSE, self.Close)
        #factor = 1.0
        self.videoWindow = wx.ScrolledWindow(self, wx.ID_ANY)
        self.videoWindow.SetBackgroundColour(wx.BLACK)
        #self.videoSlider = SliderPlus(self, parent, wx.ID_ANY, 0, 0, 240-1, dpiScale=factor, titleDict=None)
        self.videoSlider = wx.Slider(self, wx.ID_ANY)
        #self.videoSlider.Bind(wx.EVT_SCROLL_THUMBTRACK, self.OnSliderMove)
        self.videoSlider.Bind(wx.EVT_SCROLL, self.OnSliderMove)
        #self.videoSlider.SetTickFreq(10)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.videoWindow, 1, wx.EXPAND)
        sizer.Add(self.videoSlider, 0, wx.EXPAND)
        self.SetSizer(sizer)
        sizer.Layout()
        self.IsActive = False
        self.Hide()

    def Activate(self, showFrame=True):
        self.videoSlider.Enable(False)
        script = self.parent.currentScript
        if script.AVI and script.AVI.split_clip:  # do not use: script.AVI.IsSplitClip !
            if not wx.IsBusy():
                wx.BeginBusyCursor()
            try:
                re = script.AVI.SetSplitClip(True)
            finally:
                if wx.IsBusy():
                    wx.EndBusyCursor()
            if re:
                self.IsActive = True
                self.videoSlider.SetMax(script.AVI.Framecount)
                self.videoSlider.SetValue(self.parent.videoSlider.GetValue())
                self.videoSlider.Enable(True)
                for slider in self.parent.GetVideoSliderList():
                    slider.AVI_SplitClip = True
                    slider.Refresh()
                if showFrame:
                    self.parent.ShowVideoFrame(forceCursor=True)
        #super(SplitClipCtrl, self).Show()


    def Close(self, event=None, showFrame=True):
        self.IsActive = False
        self.Hide()
        for slider in self.parent.GetVideoSliderList():
            slider.AVI_SplitClip = False
            slider.Refresh()
        script = self.parent.currentScript
        if script.AVI and script.AVI.split_clip: # do not use: script.AVI.IsSplitClip !
            if not wx.IsBusy():
                wx.BeginBusyCursor()
            try:
                if not script.AVI.SetSplitClip(False):
                    pass
            finally:
                if wx.IsBusy():
                    wx.EndBusyCursor()
        if showFrame:
            self.parent.ShowVideoFrame(forceCursor=True)

    def Toggle(self, event=None):
        if self.IsActive:
            self.Close()
        else:
            self.Activate()
    def OnSliderMove(self, event):
        script = self.parent.currentScript
        if script.AVI:
            self.parent.ShowVideoFrame(self.videoSlider.GetValue())
"""

# SplitClip Control with dialog, but dialog not used... later?
class SplitClipCtrl(wx.Dialog):
    def __init__(self, parent, title=_('SplitClip'), pos=wx.DefaultPosition, size=tuplePPI(600,300)):
        style = wx.DEFAULT_DIALOG_STYLE | wx.STAY_ON_TOP | wx.RESIZE_BORDER | wx.FRAME_FLOAT_ON_PARENT# | wx.NO_FULL_REPAINT_ON_RESIZE | wx.CLIP_CHILDREN
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title, pos, size, style=style)
        dpi.SetFontPPI(self)
        self.parent = parent
        #self.Bind(wx.EVT_CLOSE, self.Close)
        self.IsActive = False
        self.Hide()

    def CheckResizeNeeded(self, script):
        value = 0
        if not self.parent.separatevideowindow and not self.parent.zoomwindow and self.parent.options['resizevideowindow'] and \
            script.AVI and (self.lastShownVideoSize != (script.AVI.DisplayWidth, script.AVI.DisplayHeight)):
                value = script.GetSize().height if self.parent.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL else script.GetSize().width
        if value > 5:
            script.lastSplitVideoPos = None
            self.parent.SetMinimumScriptPaneSize()

    def Activate(self, showFrame=False):
        def _setSplitClip(script, q):
            re = script.AVI.SetSplitClip(True)
            q.put(re)
        if self.IsActive:
            return
        script = self.parent.currentScript
        if self.parent.AviThread_Running(script, prompt=True):
            return
        if script.AVI and script.AVI.split_clip:  # do not use: script.AVI.IsSplitClip !
            self.parent.CheckPlayback()
            busy = False
            re = False
            if not wx.IsBusy():
                busy = True
                wx.BeginBusyCursor()
            try:
                if showFrame: # it's only on Toggle
                    self.lastShownVideoSize = (script.AVI.DisplayWidth, script.AVI.DisplayHeight)
                    idx = script.previewFilterIdx
                    if idx > 0 and script.AVI.preview_filter: # restore the preview filter
                        d = dict(self.parent.previewFilterDict)
                        self.parent.ParseScriptPreviewFilters()
                        if idx in self.parent.previewFilterDict.keys():
                            script.AVI.preview_filter = self.parent.previewFilterDict[idx][1]
                            if not self.parent.ComparePreviewFilterDict(d):
                                self.parent.UpdateUserSliders()
                        else:
                            self.parent.KillFilterClip()

                    if self.parent.UseAviThread:
                        q = queue.Queue()
                        th = threading.Thread(target=_setSplitClip, args=(script, q,))
                        th.daemon = True
                        th.name = 'clip'
                        script.AviThread = th
                        th.start()
                        th.join(self.parent.progressDelayTime)
                        if th.isAlive():
                            self.parent.TH_WaitForFrame(script, th, self.parent.currentframenum)
                        else: script.AviThread = None
                        try:
                            re = q.get(True, 0.1)
                        except:
                            wx.MessageBox(_('Some variables are not set correctly\nYou should restart the program!'), _('Split Clip Error'))
                    else:
                        re = script.AVI.SetSplitClip(True)
                else:
                    re = True
            finally:
                if busy and wx.IsBusy():
                    wx.EndBusyCursor()
            if re:
                self.IsActive = True
                for slider in self.parent.GetVideoSliderList():
                    slider.AVI_SplitClip = True
                    slider.Refresh()
                if showFrame:
                    self.CheckResizeNeeded(script)
                    self.parent.zoom_antialias = False
                    self.parent.ShowVideoFrame(forceCursor=True)
                    self.parent.ResetZoomAntialias()
                    self.parent.CheckPlayback()
                #super(SplitClipCtrl, self).Show()

    def Close(self, event=None, showFrame=False):
        def _setSplitClip(script, q):
            re = script.AVI.SetSplitClip(False)
            q.put(re)

        script = self.parent.currentScript
        if showFrame:
            self.parent.CheckPlayback()

        for slider in self.parent.GetVideoSliderList():
            slider.AVI_SplitClip = False
            slider.Refresh()
        if not self.IsActive:
            if showFrame:
                self.parent.CheckPlayback()
            return
        self.IsActive = False
        self.Hide()

        if script.AVI and script.AVI.split_clip: # do not use: script.AVI.IsSplitClip here
            busy = False
            if not wx.IsBusy():
                busy = True
                wx.BeginBusyCursor()
            try:
                if showFrame: # it's only on Toggle
                    self.lastShownVideoSize = (script.AVI.DisplayWidth, script.AVI.DisplayHeight)
                    idx = script.previewFilterIdx
                    if idx > 0 and script.AVI.preview_filter: # restore the preview filter
                        d = dict(self.parent.previewFilterDict)
                        self.parent.ParseScriptPreviewFilters()
                        if idx in self.parent.previewFilterDict.keys():
                            script.AVI.preview_filter = self.parent.previewFilterDict[idx][1]
                            if not self.parent.ComparePreviewFilterDict(d):
                                self.parent.UpdateUserSliders()
                        else:
                            script.AVI.preview_filter = None # not kill needed, kills on SetSplitClip

                if script.AVI.IsSplitClip: # on AVICallBack it's False, so we do nothing here
                    if self.parent.AviThread_Running(script, prompt=True):
                        return
                    if self.parent.UseAviThread:
                        q = queue.Queue()
                        th = threading.Thread(target=_setSplitClip, args=(script, q,))
                        th.daemon = True
                        th.name = 'clip'
                        script.AviThread = th
                        th.start()
                        th.join(self.parent.progressDelayTime)
                        if th.isAlive():
                            self.parent.TH_WaitForFrame(script, th, self.parent.currentframenum)
                        else: script.AviThread = None
                        try:
                            re = q.get(True, 0.1)
                        except:
                            wx.MessageBox(_('Some variables are not set correctly\nYou should restart the program!'), _('Split Clip Error'))
                            return
                    else:
                        if not script.AVI.SetSplitClip(False):
                            pass
            finally:
                if busy and wx.IsBusy():
                    wx.EndBusyCursor()
            if showFrame:
                self.CheckResizeNeeded(script)
                self.parent.zoom_antialias = False
                self.parent.ShowVideoFrame(forceCursor=True)
                self.parent.ResetZoomAntialias()
                self.parent.CheckPlayback()

    def Toggle(self, event=None):
        if self.IsActive:
            self.Close(showFrame=True)
        else:
            self.Activate(showFrame=True)

# test anti flicker
"""
class StaticTextEx(wx.StaticText):
    def __init__(self, parent, id=-1, label="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, name="staticText"):
        wx.StaticText.__init__(self, parent, id, label, pos, size,
                            style, name)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnErase)
    def OnErase(self, evt):
        pass
"""

# Dialog for property window
class PropWindow(wx.Dialog):
    def __init__(self, parent, title=_('Frame properties'), pos=wx.DefaultPosition, size=tuplePPI(190,260)):
        style = wx.DEFAULT_DIALOG_STYLE | wx.STAY_ON_TOP | wx.RESIZE_BORDER | wx.FRAME_FLOAT_ON_PARENT# | wx.NO_FULL_REPAINT_ON_RESIZE | wx.CLIP_CHILDREN
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title, pos, size, style=style)
        SetFontPPI(self)
        self.parent = parent
        self.SetDoubleBuffered(True)
        self.Active = False
        # store it, must restored on program exit
        self.parentDefHeight = self.parent.options['propwindowparentsize']
        # StyledTextCtrl
        self.textCtrl = stc.StyledTextCtrl(self, wx.ID_ANY, size=tuplePPI(250,250), style=wx.NO_BORDER)
        self.textCtrl.Hide()
        #self.textCtrl.SetBufferedDraw(True)
        #self.textCtrl.SetTwoPhaseDraw(True)
        self.textCtrl.SetCaretStyle(stc.STC_CARETSTYLE_INVISIBLE)
        self.textCtrl.SetMarginWidth(1, 0)
        self.textCtrl.SetUseHorizontalScrollBar(self.parent.options['propwinhorzscroll'])
        self.textCtrl.SetWrapMode(stc.STC_WRAP_WORD if self.parent.options['propwinwordwarp'] else stc.STC_WRAP_NONE)
        self.textCtrl.UsePopUp(0)
        self.textCtrl.SetEOLMode(stc.STC_EOL_LF)
        if wx.VERSION > (2, 9):
            self.textCtrl.SetScrollWidth(intPPI(300))
            #self.textCtrl.SetScrollWidthTracking(True)
        self.Style()
        self.zoom = (1,1)
        #self.textCtrl.SetZoom(0)
        #self.textCtrl.ZoomIn()
        #self.textCtrl.ZoomOut()
        self.Bind(wx.EVT_CLOSE, self.Close)
        menuInfo = (
            (_('Word warp'), self.OnWarpMode, wx.ITEM_CHECK, self.textCtrl.GetWrapMode() == stc.STC_WRAP_WORD),
            (_('Horz scroll'), self.OnHorzScroll, wx.ITEM_CHECK, self.textCtrl.GetUseHorizontalScrollBar()),
            #(_('Change Parent'), self.OnChangeParent, wx.ITEM_NORMAL),
        )
        if self.parent.propWindowParent > 0: # then slider window
            menuInfo += ((''), (_('Change height...'), self.OnChangeHeight, wx.ITEM_NORMAL),)
        else: # only if parent self
            sizer = wx.BoxSizer()
            sizer.Add(self.textCtrl, 1, wx.EXPAND)
            self.SetSizer(sizer)

        self.textCtrl.contextMenu = menu = wx.Menu()
        for eachMenuInfo in menuInfo:
            # Define optional arguments
            if not eachMenuInfo:
                menu.AppendSeparator()
            else:
                label = eachMenuInfo[0]
                handler = eachMenuInfo[1]
                kind = eachMenuInfo[2]
                menuItem = menu.Append(wx.ID_ANY, label, '', kind)
                if kind == wx.ITEM_CHECK:
                    menuItem.Check(eachMenuInfo[3])
                self.textCtrl.Bind(wx.EVT_MENU, handler, menuItem)
        self.textCtrl.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)
        def OnFocus(event):
            self.Update()
            event.Skip()
        self.textCtrl.Bind(wx.EVT_SET_FOCUS, OnFocus)
        #def OnLeaveWindow(event):
            #event.Skip()
        #self.textCtrl.Bind(wx.EVT_LEAVE_WINDOW, OnLeaveWindow)
        if self.parent.propWindowParent > 0:
            def OnDbClick(event):
                if self.textCtrl.GetParent() != self:
                    h = self.parentDefHeight
                    if self.textCtrl.GetSize()[1] + 10 < self.parentDefHeight + int(h/2.0):
                        h += int(h/2.0)
                    self.OnChangeHeight(None, h)
                event.Skip()
            self.textCtrl.Bind(wx.EVT_LEFT_DCLICK, OnDbClick)
        def OnMouseAux1Down(event, isAux2=False):
            if wx.GetKeyState(wx.WXK_SHIFT):
                self.parent.GotoNextBookmark(reverse=not isAux2, forceCursor=True, bmtype=[1,2])
            elif wx.GetKeyState(wx.WXK_ALT):
                self.parent.GotoNextBookmark(reverse=not isAux2, forceCursor=True, bmtype=[3]) # titled bookmarks
            elif wx.GetKeyState(wx.WXK_CONTROL):
                self.parent.JumpToNext_I_Frame(reverse=not isAux2, maxLoop=350)
            else:
                self.parent.GotoNextBookmark(reverse=not isAux2, forceCursor=True)
        def OnMouseAux2Down(event):
            OnMouseAux1Down(event, True)
        self.textCtrl.Bind(wx.EVT_MOUSE_AUX1_DOWN, OnMouseAux1Down)
        self.textCtrl.Bind(wx.EVT_MOUSE_AUX2_DOWN, OnMouseAux2Down)

        """
        def OnMouseWheel(event):
            if event.LeftIsDown():
                rotation = event.GetWheelRotation()
                #self.parent.OnMenuNext_I_Frame(reverse=rotation<0)
                x,y,w,h = self.GetRect()
                z = round((y/100.0)*10)
                if rotation > 0:
                    y = y - z
                    self.SetRect(wx.Rect(x,y,w,h+z))
                else:
                    y = y + z
                    self.SetRect(wx.Rect(x,y,w,h-z))
            else:
                event.Skip()
        self.textCtrl.Bind(wx.EVT_MOUSEWHEEL, OnMouseWheel)
        """

    # only if displaying on slider window
    def OnChangeHeight(self, event, newHeight=None):
        def UpdateSliderWnd(script, h):
            script.sliderWindow.Freeze()
            script.propertySizer.SetMinSize((50,h))
            script.propertySizer.SetDimension((0,0), (50,h))
            script.propertySizer.Layout()
            script.videoSidebarSizer.Layout()
            script.sliderWindow.FitInside()
            self.parent.TryThaw(script.sliderWindow)
        if newHeight is None:
            dlg = wx.TextEntryDialog(self, _('New height in pixels (50 to 1600):'), _('Frame properties'), str(self.textCtrl.GetSize()[1]))
            ID = dlg.ShowModal()
            s = dlg.GetValue()
            dlg.Destroy()
            if ID == wx.ID_OK and s.isdigit():
                newHeight = min(max(50, int(s)), 1600)
                self.parentDefHeight = newHeight
        if newHeight:
            self.parent.options['propwindowparentsize'] = newHeight
            parentScript = self.parent.currentScript
            for i in xrange(self.parent.scriptNotebook.GetPageCount()):
                script = self.parent.scriptNotebook.GetPage(i)
                if script != parentScript:
                    UpdateSliderWnd(script, newHeight)
            script = parentScript
            self.textCtrl.Hide()
            self.textCtrl.SetMinSize((50, newHeight))
            self.textCtrl.Show()
            UpdateSliderWnd(script, newHeight)
    def OnContextMenu(self, event):
        win = event.GetEventObject()
        pos = win.ScreenToClient(event.GetPosition())
        win.PopupMenu(win.contextMenu, pos)
    def OnWarpMode(self, event):
        if self.textCtrl.GetWrapMode() == stc.STC_WRAP_WORD:
            self.textCtrl.SetWrapMode(stc.STC_WRAP_NONE)
        else: self.textCtrl.SetWrapMode(stc.STC_WRAP_WORD)
        self.parent.options['propwinwordwarp'] = self.textCtrl.GetWrapMode() == stc.STC_WRAP_WORD
        self.textCtrl.Update()
    def OnHorzScroll(self, event):
        self.textCtrl.SetUseHorizontalScrollBar(not self.textCtrl.GetUseHorizontalScrollBar())
        self.textCtrl.Update()
        self.parent.options['propwinhorzscroll'] = self.textCtrl.GetUseHorizontalScrollBar()
    def Style(self):
        textstyles = self.parent.options['textstyles']
        self.textCtrl.StyleSetSpec(stc.STC_STYLE_DEFAULT, textstyles['propwindow'])
        self.textCtrl.StyleClearAll()
        for elem in textstyles['propwindow'].split(','):
            if elem.startswith('fore:'):
                self.textCtrl.SetSelForeground(True, elem.split(':')[1].strip())
            elif elem.startswith('back:'):
                self.textCtrl.SetSelBackground(True, elem.split(':')[1].strip())
    def Clear(self):
        self.textCtrl.SetReadOnly(False)
        self.textCtrl.ClearAll()
        self.textCtrl.EmptyUndoBuffer()
        self.textCtrl.SetReadOnly(True)
        self.textCtrl.Update()
    def SetText(self, txt):
        self.textCtrl.SetReadOnly(False)
        self.textCtrl.SetText(txt)
        self.textCtrl.Update()
        self.textCtrl.SetReadOnly(True)
    def OnShow(self):
        if self.parent.previewWindowVisible:
            ctrl = self.parent.videoWindow
        else:
            ctrl = self.parent
        self.parent.SetReadFrameProps(True)
        self.Active = True
        if self.textCtrl.GetParent() != self:
            script = self.parent.currentScript
            script.sliderWindow.Freeze()
            script.propertySizer.Show(0)
            script.propertySizer.Layout()
            #if self.propWindowParent == 1:
                #script.videoSidebarSizer.Layout()
            script.sliderWindow.FitInside()
            self.parent.TryThaw(script.sliderWindow)
            return
        if not self.textCtrl.IsShown():
            self.textCtrl.Show()
        super(PropWindow, self).Show()
        if ctrl:
            ctrl.SetFocus()
    def Close(self, event=None):
        self.Hide()
        self.Clear()
        self.parent.SetReadFrameProps(False)
        self.Active = False
        if self.textCtrl.GetParent() != self:
            script = self.parent.currentScript
            script.sliderWindow.Freeze()
            script.propertySizer.Hide(0)
            script.propertySizer.Layout()
            #if self.propWindowParent == 1:
                #script.videoSidebarSizer.Layout()
            script.sliderWindow.FitInside()
            self.parent.TryThaw(script.sliderWindow)
    def Toggle(self):
        if self.IsShown() or self.Active:
            self.Close()
        else:
            self.OnShow()

# Dialog for scrap window
class ScrapWindow(wx.Dialog): # PPI Font Size set under Font and Colors
    def __init__(self, parent, title=_('Scrap Window'), pos=wx.DefaultPosition, size=tuplePPI(250,250)):
        style = wx.DEFAULT_DIALOG_STYLE | wx.STAY_ON_TOP | wx.RESIZE_BORDER
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title, pos, size, style=style)
        self.parent = parent
        # Create the stc control
        self.textCtrl = self.createTextCtrl()
        self.Style()
        self.textCtrl.nInserted = 0
        # Add the text from the previous session
        txt, anchor, pos = self.parent.options['scraptext']
        self.textCtrl.SetText(txt)
        self.textCtrl.SetAnchor(anchor)
        self.textCtrl.SetCurrentPos(pos)
        self.textCtrl.EnsureCaretVisible()
        self.neverShown = True
        self.textCtrl.EmptyUndoBuffer()
        # Set the width for the horizontal scrollbar
        maxWidth = intPPI(50)
        if wx.VERSION > (2, 9):
            self.textCtrl.SetScrollWidth(maxWidth)
            self.textCtrl.SetScrollWidthTracking(True)
        else:
            for line in txt.split('\n'):
                width = self.textCtrl.TextWidth(stc.STC_STYLE_DEFAULT, line)
                if width > maxWidth:
                    maxWidth = width
            self.textCtrl.SetScrollWidth(maxWidth)
        # Event binding
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        # Misc
        sizer = wx.BoxSizer()
        sizer.Add(self.textCtrl, 1, wx.EXPAND)
        self.SetSizerAndFit(sizer)

    def createTextCtrl(self):
        textCtrl = stc.StyledTextCtrl(self, wx.ID_ANY, size=tuplePPI(250,250), style=wx.SIMPLE_BORDER)
        # Define the context menu
        textCtrl.UsePopUp(0)
        self.idInsertFrame = wx.NewId()
        self.idGetStatusText = wx.NewId()
        self.idToggleScrapWindow = wx.NewId()
        menuInfo = (
            (_('Undo')+'\tCtrl+Z', lambda event: textCtrl.Undo(), wx.ID_ANY),
            (_('Redo')+'\tCtrl+Y', lambda event: textCtrl.Redo(), wx.ID_ANY),
            (''),
            (_('Cut')+'\tCtrl+X', lambda event: textCtrl.Cut(), wx.ID_ANY),
            (_('Copy')+'\tCtrl+C', lambda event: textCtrl.Copy(), wx.ID_ANY),
            (_('Paste')+'\tCtrl+V', lambda event: textCtrl.Paste(), wx.ID_ANY),
            (''),
            (_('Select all')+'\tCtrl+A', lambda event: textCtrl.SelectAll(), wx.ID_ANY),
            (''),
            (_('Refresh'), self.OnRefresh, wx.ID_ANY),
            (_('Insert frame #'), self.OnInsertFrameNumber, self.idInsertFrame),
            (_('Save to file...'), self.OnSave, wx.ID_SAVE),
            (_('Clear all'), self.OnClearAll, wx.ID_ANY),
            (_('Toggle scrap window'), self.OnToggleScrapWindow, self.idToggleScrapWindow),
        )
        self.contextMenu = menu = wx.Menu()
        for eachMenuInfo in menuInfo:
            # Define optional arguments
            if not eachMenuInfo:
                menu.AppendSeparator()
            else:
                label = eachMenuInfo[0]
                handler = eachMenuInfo[1]
                status = ''
                id = eachMenuInfo[2]
                menuItem = menu.Append(id, label, status)
                textCtrl.Bind(wx.EVT_MENU, handler, menuItem)
        textCtrl.contextMenu = menu
        textCtrl.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)
        # Misc properties
        textCtrl.SetMarginWidth(1, 0)
        textCtrl.SetEOLMode(stc.STC_EOL_LF)
        return textCtrl

    def Style(self):
        textstyles = self.parent.options['textstyles']
        # Define the default style
        self.textCtrl.StyleSetSpec(stc.STC_STYLE_DEFAULT, textstyles['scrapwindow'])
        self.textCtrl.StyleClearAll()
        # Set a style to use for text flashing upon insertion
        self.textCtrl.StyleSetSpec(stc.STC_P_WORD, "fore:#FF0000,bold")
        # Set a style for selected text
        self.textCtrl.SetCaretForeground(textstyles['cursor'].split(':')[1])
        for elem in textstyles['highlight'].split(','):
            if elem.startswith('fore:'):
                if self.parent.options['highlight_fore']:
                    self.textCtrl.SetSelForeground(True, elem.split(':')[1].strip())
                else:
                    self.textCtrl.SetSelForeground(False, wx.WHITE)
            elif elem.startswith('back:'):
                self.textCtrl.SetSelBackground(True, elem.split(':')[1].strip())

    def BindShortcuts(self):
        menuInfo = (
            (_('Insert frame #'), self.idInsertFrame),
            (_('Save script'), wx.ID_SAVE),
            (_('Toggle scrap window'), self.idToggleScrapWindow),
        )
        menu = self.contextMenu
        counter = 0
        accList = []
        for itemName, shortcut, id in self.parent.options['shortcuts']:
            for label, id in menuInfo:
                if itemName.endswith(label):
                    counter += 1
                    accel = wx.GetAccelFromString('\t'+shortcut)
                    if accel and accel.IsOk():
                        accList.append((accel.GetFlags(), accel.GetKeyCode(), id))
                    menuItem = menu.FindItemById(id)
                    label = '%s\t%s' % (menuItem.GetItemLabelText(), shortcut)
                    menuItem.SetItemLabel(label)
                    break
            if counter == len(menuInfo):
                break
        accTable = wx.AcceleratorTable(accList)
        self.textCtrl.SetAcceleratorTable(accTable)

    def OnClose(self, event):
        self.Hide()

    def OnContextMenu(self, event):
        win = event.GetEventObject()
        pos = win.ScreenToClient(event.GetPosition())
        try:
            win.PopupMenu(win.contextMenu, pos)
        except AttributeError:
            print>>sys.stderr, _('Error: no contextMenu variable defined for window')

    def OnRefresh(self, event):
        scrap = self.textCtrl
        scrap.StartStyling(0, 31)
        scrap.SetStyling(scrap.GetTextLength(), stc.STC_STYLE_DEFAULT)
        self.Refresh()

    def OnInsertFrameNumber(self, event):
        frame = self.parent.GetFrameNumber()
        self.textCtrl.ReplaceSelection(str(frame))

    def OnSave(self, event):
        filefilter = (_('Text document') + ' (*.txt)|*.txt|' +
                      _('All files') + ' (*.*)|*.*')
        initialdir = self.parent.GetProposedPath(only='dir')
        dlg = wx.FileDialog(self,_('Save scrap text'),
            initialdir, '', filefilter, wx.SAVE | wx.OVERWRITE_PROMPT)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            filename = dlg.GetPath()
            self.textCtrl.SaveFile(filename)
            self.parent.options['recentdir'] = os.path.dirname(filename)
        dlg.Destroy()

    def OnClearAll(self, event):
        self.textCtrl.ClearAll()

    def OnToggleScrapWindow(self, event):
        self.Hide()

    def GetText(self):
        return self.textCtrl.GetText()

    def SetText(self, txt):
        return self.textCtrl.SetText(txt)

    def Show(self):
        if self.neverShown:
            xp, yp = self.parent.GetPositionTuple()
            wp, hp = self.parent.GetSizeTuple()
            wd, hd = wx.ScreenDC().GetSizeTuple()
            ws, hs = self.GetSizeTuple()
            self.SetPosition((min(xp+wp-50, wd-ws),-1))
        super(ScrapWindow, self).Show()
        if self.neverShown:
            self.Refresh()
            self.neverShown = False

    def write(self, msg):
        self.parent.MacroWriteToScrap(msg)

# Make safe calls to the main thread from other threads
# Adapted from <http://thread.gmane.org/gmane.comp.python.wxpython/54892/focus=55223>
class AsyncCall:
    ''' Queues a func to run in thread of MainLoop.
    Code may wait() on self.complete for self.result to contain
    the result of func(*ar,**kwar).  It is set upon completion.
    Wait() does this.'''
    def __init__(self, func, *ar, **kwar):
        self.result = self.noresult = object()
        self.complete = threading.Event()
        self.func, self.ar, self.kwar = func, ar, kwar
        if threading.current_thread().name == 'MainThread':
            self.TimeToRun()
        else:
            wx.CallAfter(self.TimeToRun)
    def TimeToRun(self):
        try:
            self.result = self.func(*self.ar, **self.kwar)
        except:
            self.exception = sys.exc_info()
        else:
            self.exception = None
        self.complete.set()
    def Wait(self, timeout=None, failval=None):
        self.complete.wait(timeout)
        if self.exception:
            # Python2:
            # raise self.exception[0], self.exception[1], self.exception[2]
            # port to Python3: https://portingguide.readthedocs.io/en/latest/exceptions.html
            import six
            six.reraise(self.exception[0], self.exception[1], self.exception[2])
        if self.result is self.noresult:
            return failval
        return self.result

# Decorator for AsyncCall class
def AsyncCallWrapper(wrapped):
    '''Decorator for AsyncCall class'''
    def wrapper(*args, **kwargs):
        return AsyncCall(wrapped, *args, **kwargs).Wait()
    functools.update_wrapper(wrapper, wrapped)
    return wrapper

# Generate macros_readme.txt
def GenerateMacroReadme(file=None):
    ''' Return the macros_readme.txt content as a single string.  Additionally, if 'file'
    is not None, write the string to 'file' if it's a string, 'macros/macros_readme.txt'
    otherwise.

    '''
    doc = MainFrame.AvsP_functions(MainFrame).__doc__
    if file:
        if not isinstance(file, basestring):
            file = os.path.join('macros', 'macros_readme.txt')
        dir = os.path.dirname(file)
        if not os.path.isdir(dir):
            os.makedirs(dir)
        file = open(file, 'w')
        file.write(doc)
        file.close()
    return doc

# Open a file or directory with its associate program
def startfile(path, prefer_dir=True):
    '''Open a file or directory with its associate program

    'prefer_dir': If True, ensure to open a dir and not an executable with
    the same name on Windows (ignore PATHEXT)
    '''
    if os.name == 'nt':
        if prefer_dir and os.path.isdir(path):  path += os.sep
        os.startfile(path)
    else:
        os.system('xdg-open "{0}"'.format(path))

# Dialog and validator for defining user slider
class UserSliderValidator(wx.PyValidator):
    def __init__(self, ctrlDict, labels):
        wx.PyValidator.__init__(self)
        self.ctrlDict = ctrlDict
        self.labels = labels

    def Clone(self):
        return UserSliderValidator(self.ctrlDict, self.labels)

    def Validate(self, parent):
        textCtrl = self.GetWindow()
        text = textCtrl.GetValue()
        if len(text) == 0:
            self.ShowWarning(textCtrl, _('This field must contain a value!'))
            return False
        elif textCtrl == self.ctrlDict['label']:
            try:
                temp  = str(text)
            except UnicodeEncodeError:
                temp = text
            if temp in self.labels:
                self.ShowWarning(textCtrl, _('This slider label already exists!'))
                return False
            if self.getModFromLabel(text) == -1:
                self.ShowWarning(textCtrl, _('Invalid slider label modulo syntax!'))
                return False
            return True
        else:
            try:
                float(text)
            except ValueError:
                self.ShowWarning(textCtrl, _('This field must contain a number!'))
                return False
            try:
                minValue = float(self.ctrlDict['min'].GetValue())
                maxValue = float(self.ctrlDict['max'].GetValue())
                value = float(self.ctrlDict['val'].GetValue())
                # Validate ranges
                if minValue >= maxValue and textCtrl == self.ctrlDict['min']:
                    self.ShowWarning(textCtrl, _('The min value must be less than the max!'))
                    return False
                if value < minValue or value > maxValue and textCtrl == self.ctrlDict['val']:
                    self.ShowWarning(textCtrl, _('The initial value must be between the min and the max!'))
                    return False
                # Validate modulo divisibility
                mod = self.getModFromLabel(self.ctrlDict['label'].GetValue())
                if mod == -1:
                    self.ShowWarning(textCtrl, _('Invalid slider label modulo syntax!'))
                    return False
                if mod is not None:
                    if int(minValue) % mod != 0 and textCtrl == self.ctrlDict['min']:
                        self.ShowWarning(textCtrl, _('The min value must be a multiple of %(mod)s!') % locals())
                        return False
                    if int(maxValue) % mod != 0 and textCtrl == self.ctrlDict['max']:
                        self.ShowWarning(textCtrl, _('The max value must be a multiple of %(mod)s!') % locals())
                        return False
                    if int(value) % mod != 0 and textCtrl == self.ctrlDict['val']:
                        self.ShowWarning(textCtrl, _('The initial value must be a multiple of %(mod)s!') % locals())
                        return False
                    if mod > (maxValue - minValue):
                        self.ShowWarning(self.ctrlDict['min'], _('The difference between the min and max must be greater than %(mod)s!') % locals())
                        return False
            except ValueError:
                pass
            return True

    def getModFromLabel(self, label):
        mod = None
        label = self.ctrlDict['label'].GetValue()
        splitlabel = label.split('%', 1)
        if len(splitlabel) == 2:
            try:
                mod = int(splitlabel[1])
                if mod <= 0:
                    mod = -1
            except ValueError:
                mod = -1
        return mod

    def ShowWarning(self, textCtrl, message):
        color = textCtrl.GetBackgroundColour()
        textCtrl.SetBackgroundColour('pink')
        textCtrl.Refresh()
        wx.MessageBox(message, _('Error'), style=wx.OK|wx.ICON_ERROR)
        textCtrl.SetBackgroundColour(color)
        textCtrl.SetSelection(-1,-1)
        textCtrl.SetFocus()
        textCtrl.Refresh()

    def TransferToWindow(self):
        return True

    def TransferFromWindow(self):
        return True

class UserSliderDialog(wx.Dialog):
    def __init__(self, parent, labels, initialValueText=''):
        wx.Dialog.__init__(self, None, wx.ID_ANY, _('Define user slider'))
        SetFontPPI(self)
        self.parent = parent
        # Entry fields
        gridSizer = wx.FlexGridSizer(cols=2, hgap=intPPI(10), vgap=intPPI(5))
        gridSizer.AddGrowableCol(1)
        self.ctrlDict = {}
        for eachKey, eachLabel in self.fieldInfo():
            textCtrl = wx.TextCtrl(self, validator=UserSliderValidator(self.ctrlDict, labels))
            #SetFontPPI(textCtrl)
            staticText = wx.StaticText(self, wx.ID_ANY, eachLabel)
            #SetFontPPI(staticText)
            gridSizer.Add(staticText, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL)
            gridSizer.Add(textCtrl, 0, wx.EXPAND)
            self.ctrlDict[eachKey] = textCtrl
        if initialValueText:
            self.ctrlDict['val'].SetValue(initialValueText)
        # Standard buttons
        okay  = wx.Button(self, wx.ID_OK, _('OK'))
        #SetFontPPI(okay)
        okay.SetDefault()
        cancel = wx.Button(self, wx.ID_CANCEL, _('Cancel'))
        #SetFontPPI(cancel)
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        # Set the sizer
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(gridSizer, 0, wx.EXPAND|wx.ALL, intPPI(20))
        sizer.Add(btns, 0, wx.EXPAND|wx.ALL, intPPI(5))
        self.SetSizer(sizer)
        sizer.Fit(self)

    def fieldInfo(self):
        return (
            ('label', _('Slider label:')),
            ('min', _('Min value:')),
            ('max', _('Max value:')),
            ('val', _('Initial value:')),
        )

    def GetSliderText(self):
        textDict = dict([(k, v.GetValue()) for k,v in self.ctrlDict.items()])
        textDict['open'] = self.parent.sliderOpenString
        textDict['close'] = self.parent.sliderCloseString
        return '%(open)s"%(label)s", %(min)s, %(max)s, %(val)s%(close)s' % textDict

# Dialog for AviSynth filter information
class AvsFunctionDialog(wx.Dialog): # PPI set
    def __init__(self, parent, filterDict, overrideDict, avsfilterdict,
                       presetDict, removedSet, pluginDict, shortnamesDict,
                       installed_plugins_filternames,
                       installed_avsi_filternames, functionName=None,
                       functionArgs=None, CreateDefaultPreset=None,
                       ExportFilterData=None, nag=True):
        wx.Dialog.__init__(
            self, parent, wx.ID_ANY,
            _('Add or override AviSynth functions in the database'),
            size=tuplePPI(500, 300), style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER
        )
        #SetFontPPI(self)
        self.parent = parent
        self.filterDict = filterDict.copy()
        self.overrideDict = overrideDict.copy()
        self.avsfilterdict = avsfilterdict.copy()
        self.presetDict = presetDict.copy()
        self.removedSet = removedSet.copy()
        self.pluginDict = pluginDict.copy()
        self.shortnamesDict = shortnamesDict.copy()
        self.installed_plugins_filternames = installed_plugins_filternames
        self.installed_avsi_filternames = installed_avsi_filternames
        self.CreateDefaultPreset = CreateDefaultPreset
        self.ExportFilterData = ExportFilterData
        self.nag = nag
        self.CreateWindowElements()
        self.CreateFilterInfoDialog()
        if functionName is not None:
            wx.FutureCall(100, self.HighlightFunction, functionName, functionArgs)

    def HighlightFunction(self, functionName, functionArgs):
        lowername = functionName.lower()
        if lowername in self.avsfilterdict:
            lowername = self.avsfilterdict[lowername][3] or lowername
            for index in xrange(self.notebook.GetPageCount()):
                panel = self.notebook.GetPage(index)
                listbox = panel.listbox
                for i in xrange(listbox.GetCount()):
                    label = listbox.GetString(i)
                    if label.split()[0].lower() == lowername:
                        self.notebook.SetSelection(index)
                        listbox.SetSelection(i)
                        self.EditFunctionInfo(arg=functionArgs, prompt=True)
                        return
        else: # functionName was not found, show dialog to define new function
            self.AddNewFunction(functionName, arg=functionArgs, prompt=True)

    def CreateWindowElements(self):
        int5 = intPPI(5)
        int10 = intPPI(10)
        self.notebook = wxp.Notebook(self, wx.ID_ANY, style=wx.NO_BORDER,
                                     invert_scroll=self.GetParent().options['invertscrolling'])
        if ppi_factor > 1:
            self.notebook.SetTabSize((-1, intPPI(23)))
            SetFontPPI(self.notebook)

        class CheckListBox(wx.CheckListBox):
            def __init__(self, *args, **kwargs):
                wx.CheckListBox.__init__(self, *args, **kwargs)
                #SetFontPPI(self)
                self.Bind(wx.EVT_CHECKLISTBOX, self.OnCheckListBox)
                self.removedSet = self.GetTopLevelParent().removedSet

            def Check(self, item, check=True):
                wx.CheckListBox.Check(self, item, check)
                self.UpdateRemovedSet(item)

            def OnCheckListBox(self, event):
                self.UpdateRemovedSet(event.GetInt())
                event.Skip()

            def UpdateRemovedSet(self, item):
                name = self.GetString(item).split()[0].lower()
                if self.IsChecked(item):
                    if name in self.removedSet:
                        self.removedSet.remove(name)
                else:
                    self.removedSet.add(name)

        pageInfo = (
            (_('Core filters'), 0),
            (_('Plugins'), 2),
            (_('User functions'), 3),
            (_('Script functions'), 4),
            (_('Clip properties'), 1),
        )
        pageDict = collections.defaultdict(list)
        for key in set(self.filterDict.keys()+self.overrideDict.keys()):
            name, args, ftype = self.overrideDict.get(key, (None, None, None))
            extra = ' '
            if name is None:
                try:
                    name, args, ftype = self.filterDict[key]
                except:
                    continue
            else:
                extra += '*'
            if key in self.presetDict:
                extra += '~'
            pageDict[ftype].append(name + extra)
        for title, index in pageInfo:
            panel = wx.Panel(self.notebook, wx.ID_ANY, size=(intPPI(700),-1))
            #SetFontPPI(panel)
            self.notebook.AddPage(panel, title)

            choices = pageDict[index]
            listbox = CheckListBox(panel, wx.ID_ANY, choices=choices, size=(-1,intPPI(300)), style=wx.LB_SORT)
            if dpi.ppi_factor > 1:
                font = listbox.GetFont()
                font.SetPointSize(10)
                listbox.SetFont(font)
            #self.parent.SendMessage(listbox.GetHandle(), 61856, -1, 100)

            if choices:
                listbox.SetSelection(0)
            listbox.Bind(wx.EVT_LISTBOX_DCLICK, lambda event: self.EditFunctionInfo())
            for i in xrange(listbox.GetCount()):
                name = listbox.GetString(i).split()[0]
                if name.lower() not in self.removedSet:
                    listbox.Check(i)
            title = title.lower()
            # Buttons
            buttonadd = wx.Button(panel, wx.ID_ANY, _('New function'))#, size=(100, -1))
            buttonedit = wx.Button(panel, wx.ID_ANY, _('Edit selected'))
            buttondelete = wx.Button(panel, wx.ID_ANY, _('Delete selected'))
            buttoncheckall = wx.Button(panel, wx.ID_ANY, _('Select all'))
            buttonuncheckall = wx.Button(panel, wx.ID_ANY, _('Clear all'))
            panel.Bind(wx.EVT_BUTTON, lambda event: self.AddNewFunction(ftype=-1), buttonadd)
            panel.Bind(wx.EVT_BUTTON, lambda event: self.EditFunctionInfo(), buttonedit)
            panel.Bind(wx.EVT_BUTTON, lambda event: self.DeleteFunction(), buttondelete)
            panel.Bind(wx.EVT_BUTTON, lambda event: self.CheckAllFunctions(True), buttoncheckall)
            panel.Bind(wx.EVT_BUTTON, lambda event: self.CheckAllFunctions(False), buttonuncheckall)
            buttonSizer = wx.BoxSizer(wx.VERTICAL)
            buttonSizer.Add(buttonadd, 0, wx.EXPAND|wx.TOP|wx.BOTTOM, int5)
            buttonSizer.Add(buttonedit, 0, wx.EXPAND|wx.BOTTOM, int5)
            buttonSizer.Add(buttondelete, 0, wx.EXPAND|wx.BOTTOM, int5)
            buttonSizer.Add(wx.StaticLine(panel, wx.ID_ANY, style=wx.HORIZONTAL), 0, wx.EXPAND|wx.TOP|wx.BOTTOM, int5)
            buttonSizer.Add(buttonuncheckall, 0, wx.EXPAND|wx.TOP|wx.BOTTOM, int5)
            buttonSizer.Add(buttoncheckall, 0, wx.EXPAND|wx.BOTTOM, int5)
            if index in (2, 3):
                buttonselectinstalled = wx.Button(panel, wx.ID_ANY, _('Select installed'))
                panel.Bind(wx.EVT_BUTTON, lambda event: self.SelectInstalledFilters(), buttonselectinstalled)
                buttonSizer.Add(buttonselectinstalled, 0, wx.EXPAND|wx.BOTTOM, int5)
            # Size the elements in the panel
            listboxSizer = wx.BoxSizer(wx.HORIZONTAL)
            listboxSizer.Add(listbox, 1, wx.EXPAND|wx.RIGHT, int10)
            listboxSizer.Add(buttonSizer, 0, wx.EXPAND|wx.RIGHT, int5)
            panelSizer = wx.BoxSizer(wx.VERTICAL)
            panelSizer.Add(listboxSizer, 1, wx.EXPAND|wx.ALL, int5)
            panel.SetSizer(panelSizer)
            panelSizer.Layout()
            # Bind items to the panel itself
            panel.listbox = listbox
            panel.functiontype = index
        self.CreatePluginsContextMenu()
        # Buttons
        button0 = wx.Button(self, wx.ID_ANY, _('Import'))
        SetFontPPI(button0)
        menu0 = wx.Menu()
        menuItem = menu0.Append(wx.ID_ANY, _('Import from files'))
        self.Bind(wx.EVT_MENU, lambda event: self.ImportFromFiles(), menuItem)
        menuItem = menu0.Append(wx.ID_ANY, _('Import from wiki'))
        self.Bind(wx.EVT_MENU, lambda event: self.ImportFromFiles(wiki=True), menuItem)
        self.Bind(wx.EVT_BUTTON, lambda event: button0.PopupMenu(
                    menu0, (1, button0.GetSizeTuple()[1])), button0)
        button1 = wx.Button(self, wx.ID_ANY, _('Export customizations'))
        SetFontPPI(button1)
        self.Bind(wx.EVT_BUTTON, lambda event: self.ExportCustomizations(), button1)
        button2 = wx.Button(self, wx.ID_ANY, _('Clear customizations'))
        SetFontPPI(button2)
        self.Bind(wx.EVT_BUTTON, lambda event: self.ClearCustomizations(), button2)
        button3 = wx.Button(self, wx.ID_ANY, _('Clear manual presets'))
        SetFontPPI(button3)
        self.Bind(wx.EVT_BUTTON, lambda event: self.ClearPresets(), button3)
        buttonSizer = wx.BoxSizer(wx.HORIZONTAL)
        buttonSizer.Add(button0, 0, wx.RIGHT, int5)
        buttonSizer.Add(button1, 0, wx.RIGHT, int5)
        buttonSizer.Add(button2, 0, wx.RIGHT, int5)
        buttonSizer.Add(button3, 0, wx.RIGHT, int5)
        self.checkBox = wx.CheckBox(self, wx.ID_ANY, _("When importing, don't show the choice dialog"))
        SetFontPPI(self.checkBox)
        # Standard buttons
        okay  = wx.Button(self, wx.ID_OK, _('OK'))
        SetFontPPI(okay)
        #~ self.Bind(wx.EVT_BUTTON, self.OnButtonOK, okay)
        cancel = wx.Button(self, wx.ID_CANCEL, _('Cancel'))
        SetFontPPI(cancel)
        sdtbtns = wx.StdDialogButtonSizer()
        sdtbtns.Add(self.checkBox)
        sdtbtns.AddButton(okay)
        sdtbtns.AddButton(cancel)
        sdtbtns.Realize()
        # Size the elements
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add(self.notebook, 1, wx.EXPAND|wx.ALL, int5)
        dlgSizer.Add(buttonSizer, 0, wx.LEFT, int5)
        dlgSizer.Add(wx.StaticLine(self, style=wx.HORIZONTAL), 0, wx.EXPAND|wx.TOP|wx.BOTTOM, int5)
        dlgSizer.Add(sdtbtns, 0, wx.EXPAND|wx.ALL, int5)
        self.SetSizer(dlgSizer)
        dlgSizer.SetSizeHints(self)
        dlgSizer.Layout()
        # Misc
        def OnPageChanged(event):
            event.GetEventObject().GetCurrentPage().SetFocus()
            event.Skip()
        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, OnPageChanged)
        self.notebook.GetCurrentPage().listbox.SetFocus()
        okay.SetDefault()

    def CreateFilterInfoDialog(self, resetargsbutton=True):
        int5 = intPPI(5)
        int10 = intPPI(10)                                               # GPo new, style
        dlg = wx.Dialog(self, wx.ID_ANY, _('Edit function information'), style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        dlg.SetMinSize(tuplePPI(380,380))
        SetFontPPI(dlg)
        staticText0 = wx.StaticText(dlg, wx.ID_ANY, _('Name:'))
        textCtrl0 = wx.TextCtrl(dlg, wx.ID_ANY, size=(intPPI(200),-1))
        staticText1 = wx.StaticText(dlg, wx.ID_ANY, _('Type:'))
        choices = [_('core filter'), _('clip property'), _('plugin'), _('user function'), _('script function')]
        choiceBox1 = wx.Choice(dlg, wx.ID_ANY, choices=choices)
        staticText2 = wx.StaticText(dlg, wx.ID_ANY, _('Arguments:'))
        staticText2_4 = wx.StaticText(dlg, wx.ID_ANY, _('define sliders'))
        staticText2_5 = wx.StaticText(dlg, wx.ID_ANY, _('reset to default'))
        for eachCtrl in (staticText2_4, staticText2_5):
            font = eachCtrl.GetFont()
            font.SetUnderlined(True)
            eachCtrl.SetFont(font)
            eachCtrl.SetForegroundColour(wx.Colour(0,0,255))
            eachCtrl.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        def OnArgsEditSliders(event):
            name = textCtrl0.GetValue()
            dlg2 = AvsFilterAutoSliderInfo(dlg, self.GetParent(), name, textCtrl2.GetValue(), title=_('Slider information'))
            SetFontPPI(dlg2)
            ID = dlg2.ShowModal()
            if ID == wx.ID_OK:
                textCtrl2.SetValue(dlg2.GetNewFilterInfo())
            dlg2.Destroy()
        staticText2_4.Bind(wx.EVT_LEFT_DOWN, OnArgsEditSliders)
        def OnClickSetToDefault(event):
            textCtrl0.SetValue(dlg.defaultName)
            textCtrl2.SetValue(dlg.defaultArgs)
        staticText2_5.Bind(wx.EVT_LEFT_DOWN, OnClickSetToDefault)
        textCtrl2 = wxp.TextCtrl(dlg, wx.ID_ANY, size=tuplePPI(200,220), style=wx.TE_MULTILINE|wx.HSCROLL)
        def OnArgsChange(event):
            if checkBox3.IsChecked():
                name = textCtrl0.GetValue() #dlg.defaultName
                args= textCtrl2.GetValue()
                textCtrl3.SetValue(self.CreateDefaultPreset(name, args))
        textCtrl0.Bind(wx.EVT_TEXT, OnArgsChange)
        textCtrl2.Bind(wx.EVT_TEXT, OnArgsChange)
        #~ textCtrl2.Bind(wx.EVT_LEFT_DCLICK, OnArgsEditSliders)
        staticText3 = wx.StaticText(dlg, wx.ID_ANY, _('Preset:'))
        checkBox3 = wx.CheckBox(dlg, wx.ID_ANY, _('Auto-generate'))
        def OnCheck(event):
            if checkBox3.IsChecked():
                textCtrl3.SetEditable(False)
                colour = self.GetBackgroundColour()
                textCtrl3.SetBackgroundColour(colour)
                OnArgsChange(None)
            else:
                textCtrl3.SetEditable(True)
                textCtrl3.SetBackgroundColour(wx.WHITE)
        checkBox3.Bind(wx.EVT_CHECKBOX, OnCheck)
        textCtrl3 = wxp.TextCtrl(dlg, wx.ID_ANY, size=(-1,intPPI(50)), style=wx.TE_MULTILINE|wx.HSCROLL)
        # Standard buttons
        okay  = wx.Button(dlg, wx.ID_OK, _('OK'))
        def OnFilterInfoDialogButtonOK(event):
            newName = textCtrl0.GetValue()
            enteredName = dlg.enteredName
            if enteredName is None:
                lowername = newName.lower()
                if lowername in self.overrideDict or lowername in self.filterDict:
                    wx.MessageBox(_('Filter name already exists!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
                    textCtrl0.SetFocus()
                    return
                if not newName or newName[0].isdigit() or re.findall('\W', newName):
                    wx.MessageBox(_('Invalid filter name!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
                    textCtrl0.SetFocus()
                    return
            elif newName.lower() != enteredName.lower():
                wx.MessageBox(_('Renaming not allowed!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
                textCtrl0.SetFocus()
                return
            if dlg.typeBox.GetCurrentSelection() == 2 and newName.count('_') == 0:
                wx.MessageBox(_('You must use dllname_function naming format for plugins!'),
                              _('Error'), style=wx.OK|wx.ICON_ERROR)
                textCtrl0.SetFocus()
                return
            event.Skip()
        dlg.Bind(wx.EVT_BUTTON, OnFilterInfoDialogButtonOK, okay)
        cancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        # Size the elements
        sizer01 = wx.FlexGridSizer(cols=4, hgap=int5, vgap=int5)
        sizer01.Add(staticText0, 0, wx.ALIGN_CENTER_VERTICAL)
        sizer01.Add(textCtrl0, 0, wx.EXPAND|wx.RIGHT, int10)
        sizer01.Add(staticText1, 0, wx.ALIGN_CENTER_VERTICAL)
        sizer01.Add(choiceBox1, 0, wx.EXPAND)
        sizer2 = wx.BoxSizer(wx.HORIZONTAL)
        sizer2.Add(staticText2, 0, wx.ALL, 0)
        sizer2.Add((-1,-1), 1, wx.EXPAND|wx.ALL, 0)
        sizer2.Add(staticText2_5, 0, wx.RIGHT, int10)
        sizer2.Add(staticText2_4, 0, wx.LEFT|wx.RIGHT, int10)
        sizer3 = wx.BoxSizer(wx.HORIZONTAL)
        sizer3.Add(staticText3, 0, wx.ALL, 0)
        sizer3.Add((-1,-1), 1, wx.EXPAND|wx.ALL, 0)
        sizer3.Add(checkBox3, 0, wx.RIGHT, intPPI(10))
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add((-1,int5), 0, wx.EXPAND|wx.ALL, 0)
        dlgSizer.Add(sizer01, 0, wx.EXPAND|wx.ALL, int5)
        dlgSizer.Add(wx.StaticLine(dlg, style=wx.HORIZONTAL), 0, wx.EXPAND|wx.TOP|wx.BOTTOM, int5)
        dlgSizer.Add(sizer2, 0, wx.EXPAND|wx.TOP|wx.LEFT, int5)
        dlgSizer.Add(textCtrl2, 1, wx.EXPAND|wx.ALL, int5)
        dlgSizer.Add(sizer3, 0, wx.EXPAND|wx.TOP|wx.LEFT, int5)
        dlgSizer.Add(textCtrl3, 0, wx.EXPAND|wx.ALL, int5)
        dlgSizer.Add(btns, 0, wx.EXPAND|wx.ALL, int5)
        dlg.SetSizer(dlgSizer)
        if not resetargsbutton:
            staticText2_5.Hide()
        def SetAutopreset(on=True):
            if on:
                checkBox3.SetValue(True)
                textCtrl3.SetEditable(False)
                colour = self.GetBackgroundColour()
                textCtrl3.SetBackgroundColour(colour)
            else:
                checkBox3.SetValue(False)
                textCtrl3.SetEditable(True)
                textCtrl3.SetBackgroundColour(wx.WHITE)
        dlg.SetAutopreset = SetAutopreset
        dlg.Fit()
        dlgSizer.Layout()
        # Bind variables
        dlg.nameBox = textCtrl0
        dlg.typeBox = choiceBox1
        dlg.argsBox = textCtrl2
        dlg.presetBox = textCtrl3
        dlg.resetCtrl = staticText2_5
        dlg.autopresetCheckbox = checkBox3
        dlg.cancelButton = cancel
        dlg.defaultArgs = ''
        dlg.defaultName = ''
        dlg.enteredName = ''
        self.FilterInfoDialog = dlg


    def CreatePluginsContextMenu(self):
        """Chose between long and short names"""

        def OnPluginsContextMenu(event):
            name = listbox.GetString(listbox.GetSelection()).split()[0].lower()
            item = menu.FindItemByPosition((self.pluginDict[name] + 2) % 3)
            item.Check()
            listbox.PopupMenu(menu)

        def OnContextMenuItem(event):
            id = event.GetId()
            if id in [idLong, idShort, idBoth]:
                if id == idLong:
                    value = 1
                elif id == idShort:
                    value = 2
                elif id == idBoth:
                    value = 0
                name = listbox.GetString(listbox.GetSelection())
                self.pluginDict[name.split()[0].lower()] = value
            else:
                if id == idLongOnly:
                    value = 1
                elif id == idShortOnly:
                    value = 2
                elif id == idAll:
                    value = 0
                for name in self.pluginDict:
                    self.pluginDict[name] = value

        listbox = self.notebook.GetPage(1).listbox
        listbox.Bind(wx.EVT_CONTEXT_MENU, OnPluginsContextMenu)
        idLong = wx.NewId()
        idShort = wx.NewId()
        idBoth = wx.NewId()
        idLongOnly = wx.NewId()
        idShortOnly = wx.NewId()
        idAll = wx.NewId()
        menu = wx.Menu()
        menu.AppendRadioItem(idLong, _('Long name'))
        menu.AppendRadioItem(idShort, _('Short name'))
        menu.AppendRadioItem(idBoth, _('Both'))
        menu.AppendSeparator()
        menu.Append(idLongOnly, _('Only long names'))
        menu.Append(idShortOnly, _('Only short names'))
        menu.Append(idAll, _('All names'))
        listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idLong)
        listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idShort)
        listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idBoth)
        listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idLongOnly)
        listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idShortOnly)
        listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idAll)

    def CheckAllFunctions(self, check=True):
        listbox = self.notebook.GetCurrentPage().listbox
        for i in xrange(listbox.GetCount()):
            listbox.Check(i, check)

    def SelectInstalledFilters(self):
        index = self.notebook.GetSelection()
        if index == 1:
            filters = self.installed_plugins_filternames
        elif index == 2:
            filters = self.installed_avsi_filternames
        else: return
        listbox = self.notebook.GetCurrentPage().listbox
        for i in xrange(listbox.GetCount()):
            boolCheck = (listbox.GetString(i).split()[0].lower() in filters)
            listbox.Check(i, boolCheck)

    def ImportFromFiles(self, wiki=False):
        filenames, filterInfo, unrecognized = [], [], []
        if wiki:
            filenames = (self.GetParent().filterdbremote_plugins,
                         self.GetParent().filterdbremote_scripts)
        else:
            title = _('Open Customization files, Avisynth scripts or Avsp options files')
            initial_dir = self.GetParent().ExpandVars(self.GetParent().options['pluginsdir'])
            filefilter = (_('All supported') + '|*.txt;*.md;*.avsi;*.avs;*.dat|' +
                          _('Customization file') + ' (*.txt, *.md)|*.txt;*.md|' +
                          _('AviSynth script') + ' (*.avs, *.avsi)|*.avs;*.avsi|' +
                          _('AvsP data') + ' (*.dat)|*.dat|' +
                          _('All files') + ' (*.*)|*.*')
            dlg = wx.FileDialog(self, title, initial_dir, '', filefilter,
                                wx.OPEN|wx.MULTIPLE|wx.FILE_MUST_EXIST)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filenames = dlg.GetPaths()
            dlg.Destroy()
            if not filenames:
                return

        for filename in filenames:
            ext = os.path.splitext(filename)[1]
            try:
                if ext in ['.avs', '.avsi']:
                    info = self.ParseAvisynthScript(filename)
                elif ext in ['.txt', '.md']:
                    info = self.ParseCustomizations(filename)
                elif ext == '.dat':
                    if filename.startswith('http'):
                        f = urllib2.urlopen(filename)
                    else:
                        f = open(filename, 'rb')
                    data = cPickle.load(f)
                    f.close()
                    info = []
                    for filtername, filterargs, ftype in data['filteroverrides'].values():
                        info.append((filename, filtername, filterargs, ftype))
                else:
                    info = None
            except (urllib2.URLError, urllib2.HTTPError) as err:
                wx.MessageBox(u'\n\n'.join((os.path.basename(filename), unicode(err))),
                              _('Error'), style=wx.OK|wx.ICON_ERROR)
                continue
            except:
                info = None
            if not info:
                unrecognized.append(filename)
            else:
                filterInfo += info
        if filterInfo and (wiki or not self.checkBox.IsChecked()):
            self.SelectImportFilters(filterInfo)
        for filename, filtername, filterargs, ftype in filterInfo:
            self.EditFunctionInfo(filtername, filterargs, ftype)
        if unrecognized:
            wx.MessageBox('\n'.join(unrecognized), _('Unrecognized files'))

    def SelectImportFilters(self, filterInfo):
        choices = []
        filterInfo.sort(key=lambda fi:
                    [i.lower() if isinstance(i, basestring) else i for i in fi])
        for filename, filtername, filterargs, ftype in filterInfo:
            choices.append(os.path.basename(filename) + ' -> ' + filtername)
        dlg = wx.Dialog(self, wx.ID_ANY, _('Select the functions to import'),
                        style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        SetFontPPI(dlg)
        listbox = wx.CheckListBox(dlg, wx.ID_ANY, choices=choices, style=wx.LB_EXTENDED)
        customized, not_customized = [], []
        for i in range(len(choices)):
            filename, filtername = choices[i].lower().split(' -> ')
            if filtername in self.overrideDict:
                listbox.SetItemForegroundColour(i, wx.RED)
                customized.append(i)
            else:
                not_customized.append(i)
                if filename.find(filtername) != -1:
                    listbox.Check(i)
        idSelectionAll = wx.NewId()
        idAll = wx.NewId()
        idFileAll = wx.NewId()
        idNotCustomizedAll = wx.NewId()
        idSelectionNone = wx.NewId()
        idNone = wx.NewId()
        idFileNone = wx.NewId()
        idCustomizedNone = wx.NewId()

        def OnContextMenuItem(event):
            id = event.GetId()
            value = id in (idSelectionAll, idAll, idFileAll, idNotCustomizedAll)
            if id in [idSelectionAll, idSelectionNone]:
                listbox_range = listbox.GetSelections()
            elif id in [idAll, idNone]:
                listbox_range = range(len(filterInfo))
            elif id in [idFileAll, idFileNone]:
                pos = listbox.GetSelections()
                if not pos:
                    return
                filename = filterInfo[pos[0]][0]
                listbox_range = (i for i in range(len(filterInfo))
                                 if filename == filterInfo[i][0])
            elif id == idNotCustomizedAll:
                listbox_range = not_customized
            elif id == idCustomizedNone:
                listbox_range = customized
            for i in listbox_range:
                listbox.Check(i, value)

        def OnContextMenu(event):
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idSelectionAll)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idAll)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idFileAll)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idNotCustomizedAll)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idSelectionNone)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idNone)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idFileNone)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idCustomizedNone)
            menu = wx.Menu()
            menu.Append(idSelectionAll, _('Check selected'))
            menu.Append(idAll, _('Check all'))
            menu.Append(idFileAll, _('Check all in this file'))
            menu.Append(idNotCustomizedAll, _('Check all not customized'))
            menu.AppendSeparator()
            menu.Append(idSelectionNone, _('Uncheck selected'))
            menu.Append(idNone, _('Uncheck all'))
            menu.Append(idFileNone, _('Uncheck all in this file'))
            menu.Append(idCustomizedNone, _('Uncheck all customized'))
            listbox.PopupMenu(menu)
            menu.Destroy()

        listbox.Bind(wx.EVT_CONTEXT_MENU, OnContextMenu)
        message = wx.StaticText(dlg, wx.ID_ANY, _('Red - a customized function already exists.'))
        okay  = wx.Button(dlg, wx.ID_OK, _('OK'))
        cancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(listbox, 1, wx.EXPAND|wx.ALL,intPPI(5))
        sizer.Add(message, 0, wx.LEFT, intPPI(5))
        sizer.Add(btns, 0, wx.EXPAND|wx.ALL,intPPI(5))
        dlg.SetSizerAndFit(sizer)
        ID = dlg.ShowModal()
        for i in range(len(choices)-1, -1, -1):
            if ID != wx.ID_OK or not listbox.IsChecked(i):
                del filterInfo[i]
        dlg.Destroy()

    def ParseAvisynthScript(self, *args, **kwargs):
        return self.GetParent().ParseAvisynthScript(*args, **kwargs)

    def ParseCustomizations(self, filename):
        if filename.startswith('http'):
            f = urllib2.urlopen(filename)
        else:
            f = open(filename)
        text = '\n'.join([line.strip() for line in f.readlines()])
        f.close()
        if filename.endswith('.md'):
            text = text.split('```text\n', 1)[1].rsplit('```', 1)[0]
        filterInfo = []
        for section in text.split('\n\n['):
            title, data = section.split(']\n',1)
            title = title.strip('[]').lower()
            if title == 'clipproperties':
                for item in data.split('\n'):
                    if not item.strip():
                        continue
                    splitstring = item.split('(', 1)
                    if len(splitstring) == 2:
                        filtername = splitstring[0].strip()
                        filterargs = '('+splitstring[1].strip(' ')
                    else:
                        filtername = item
                        filterargs = ''
                    filterInfo.append((filename, filtername, filterargs, 1))
            elif title == 'scriptfunctions':
                for item in data.split('\n'):
                    if not item.strip():
                        continue
                    splitstring = item.split('(', 1)
                    if len(splitstring) == 2:
                        filtername = splitstring[0].strip()
                        filterargs = '('+splitstring[1].strip(' ')
                    else:
                        filtername = item
                        filterargs = ''
                    filterInfo.append((filename, filtername, filterargs, 4))
            elif title == 'corefilters':
                for s in data.split('\n\n'):
                    splitstring = s.split('(', 1)
                    if len(splitstring) == 2:
                        filtername = splitstring[0].strip()
                        filterargs = '('+splitstring[1].strip(' ')
                        filterInfo.append((filename, filtername, filterargs, 0))
            elif title == 'plugins':
                for s in data.split('\n\n'):
                    splitstring = s.split('(', 1)
                    if len(splitstring) == 2:
                        filtername = splitstring[0].strip()
                        if not self.parent.GetPluginFunctionShortName(filtername.lower()):
                            print>>sys.stderr, '{0}: {1}'.format(_('Error'), _('Invalid plugin '
                                'function name "{name}". Must be "pluginname_functionname".').format(name=filtername))
                            continue
                        filterargs = '('+splitstring[1].strip(' ')
                        filterInfo.append((filename, filtername, filterargs, 2))
            elif title == 'userfunctions':
                for s in data.split('\n\n'):
                    splitstring = s.split('(', 1)
                    if len(splitstring) == 2:
                        filtername = splitstring[0].strip()
                        filterargs = '('+splitstring[1].strip(' ')
                        filterInfo.append((filename, filtername, filterargs, 3))
        return filterInfo

    def ExportCustomizations(self):
        if len(self.overrideDict) == 0:
            wx.MessageBox(_('No customizations to export!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return
        title = _('Save filter customizations')
        initial_dir = self.GetParent().programdir
        filefilter = _('Customization file') + ' (*.txt)|*.txt|' + _('All files') + ' (*.*)|*.*'
        dlg = wx.FileDialog(self, title, initial_dir, '', filefilter, wx.SAVE|wx.OVERWRITE_PROMPT)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            filename = dlg.GetPath()
            self.ExportFilterData(self.overrideDict, filename)
        dlg.Destroy()

    def ClearCustomizations(self):
        dlg = wx.MessageDialog(self, _('This will delete all filter customizations. Continue?'), _('Warning'), wx.YES_NO)
        ID = dlg.ShowModal()
        if ID == wx.ID_YES:
            for lowername, (name, args, ftype) in self.overrideDict.iteritems():
                if ftype == 2 and lowername not in self.filterDict:
                    shortname = self.parent.GetPluginFunctionShortName(lowername)
                    if len(self.shortnamesDict[shortname]) == 1:
                        del self.shortnamesDict[shortname]
                    else:
                        self.shortnamesDict[shortname].remove(lowername)
            self.overrideDict = {}
            self.RefreshListNames()
        dlg.Destroy()

    def ClearPresets(self):
        dlg = wx.MessageDialog(self, _('This will delete all manually defined presets. Continue?'), _('Warning'), wx.YES_NO)
        ID = dlg.ShowModal()
        if ID == wx.ID_YES:
            self.presetDict = {}
            self.RefreshListNames()
        dlg.Destroy()

    def RefreshListNames(self):
        for index in xrange(self.notebook.GetPageCount()):
            panel = self.notebook.GetPage(index)
            listbox = panel.listbox
            deleteIndices = []
            for i in xrange(listbox.GetCount()):
                name = listbox.GetString(i).split()[0]
                lowername = name.lower()
                extra = ' '
                if lowername in self.overrideDict:
                    extra += '*'
                elif lowername not in self.filterDict:
                    deleteIndices.append(i)
                    continue
                if lowername in self.presetDict:
                    extra += '~'
                newname = name+extra
                if listbox.GetString(i) != newname:
                    listbox.SetString(i, newname)
            deleteIndices.reverse()
            for i in deleteIndices:
                listbox.Delete(i)

    def AddNewFunction(self, name='', ftype=3, arg=None, prompt=None):
        dlg = self.FilterInfoDialog
        if ftype == -1:
            index = self.notebook.GetSelection()
            if index != wx.NOT_FOUND:
                ftype = self.notebook.GetPage(index).functiontype
            else:
                ftype = 3
        else:
            for index in xrange(self.notebook.GetPageCount()):
                panel = self.notebook.GetPage(index)
                if panel.functiontype == ftype:
                    self.notebook.SetSelection(index)
                    break
        defaultName = name
        defaultArgs = '()' if not arg else arg
        dlg.nameBox.SetValue(defaultName)
        dlg.typeBox.SetSelection(ftype)
        dlg.typeBox.Enable()
        dlg.argsBox.SetValue(defaultArgs)
        dlg.presetBox.SetValue('')
        dlg.resetCtrl.Hide()
        dlg.SetAutopreset(True)
        dlg.cancelButton.SetFocus()
        dlg.defaultArgs = defaultArgs
        dlg.defaultName = defaultName
        dlg.enteredName = None
        if prompt is None:
            prompt = not bool(arg)
        if not prompt: ID = wx.ID_OK
        else: ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            newName = dlg.nameBox.GetValue()
            newType = dlg.typeBox.GetSelection()
            newArgs = dlg.argsBox.GetValue()
            newPreset = dlg.presetBox.GetValue()
            boolAutoPreset = dlg.autopresetCheckbox.GetValue()
            for index in xrange(self.notebook.GetPageCount()):
                panel = self.notebook.GetPage(index)
                if panel.functiontype == newType:
                    self.notebook.SetSelection(index)
                    listbox = panel.listbox
                    break

            extra = ' '
            # Update the override dict
            lowername = newName.lower()
            self.overrideDict[lowername] = (newName, newArgs, newType)
            if newType == 2:
                self.pluginDict[lowername] = 0
                self.shortnamesDict[self.parent.GetPluginFunctionShortName(lowername)].append(lowername)
            extra += '*'
            # Update the preset dict
            if boolAutoPreset:
                if lowername in self.presetDict:
                    del self.presetDict[lowername]
            else:
                self.presetDict[lowername] = newPreset
                extra += '~'
            index = listbox.Append(newName+extra)
            listbox.Check(index)
            listbox.SetSelection(index)
            listbox.SetFirstItem(index)

    def EditFunctionInfo(self, name=None, arg=None, ftype=None, prompt=None):
        dlg = self.FilterInfoDialog
        if arg and ftype is not None:
            arg = arg.strip()
            name = unicode(name)
            for index in xrange(self.notebook.GetPageCount()):
                panel = self.notebook.GetPage(index)
                if panel.functiontype == ftype:
                    break
        else:
            panel = self.notebook.GetCurrentPage()
        listbox = panel.listbox
        functiontype = panel.functiontype
        if name is None:
            name = listbox.GetStringSelection().split()[0]
        if not name:
            return
        lowername = name.lower()
        if lowername not in self.filterDict and lowername not in self.overrideDict:
            if not ftype:
                self.AddNewFunction(name)
            else:
                self.AddNewFunction(name, ftype, arg)
            return
        # Fill out default values
        defaultName, defaultArgs, defaultType = self.filterDict.get(lowername, ('', '', None))
        countHint = defaultArgs.count('#hint')
        if defaultArgs.find('c_string ') > -1:
            msd = wx.MessageDialog(self, 'Args containing type c_string.\nWarning! do not change the c_string arg\n\n'+
                                     'Note:\navsYUV stands for all YUV types\n'+
                                     'avsRGBP for all RGBP types\n\nThis information may be incomplete.',
                                      _('Warning'), wx.OK|wx.ICON_INFORMATION)
            ID = msd.ShowModal()
            msd.Destroy()

        enteredName = name
        enteredType = functiontype
        enteredArgs = self.overrideDict.get(lowername, (None, defaultArgs, None))[1] if not arg else arg
        enteredPreset = self.presetDict.get(lowername)#, defaultPreset)
        if enteredPreset is not None:
            dlg.SetAutopreset(False)
        else:
            dlg.SetAutopreset(True)
            enteredPreset = self.CreateDefaultPreset(name, enteredArgs)
        dlg.nameBox.SetValue(enteredName)
        dlg.typeBox.SetSelection(enteredType)
        dlg.argsBox.SetValue(enteredArgs)
        dlg.presetBox.SetValue(enteredPreset)
        if lowername in self.filterDict:
            dlg.typeBox.Disable()
            dlg.resetCtrl.Show()
        else:
            dlg.typeBox.Enable()
            dlg.resetCtrl.Hide()
        dlg.cancelButton.SetFocus()
        dlg.defaultArgs = defaultArgs
        #~ self.defaultPreset = defaultPreset
        dlg.defaultName = defaultName
        dlg.enteredName = enteredName
        if prompt is None:
            prompt = not bool(arg)
        if not prompt: ID = wx.ID_OK
        else: ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            newName = dlg.nameBox.GetValue()
            newType = dlg.typeBox.GetSelection()
            newArgs = dlg.argsBox.GetValue()
            newPreset = dlg.presetBox.GetValue()
            boolAutoPreset = dlg.autopresetCheckbox.GetValue()
            extra = ' '
            if countHint > newArgs.count('#hint'):
                msd = wx.MessageDialog(self, 'Arg #hint has been removed, are you sure?',
                                    _('Question'), wx.YES_NO|wx.ICON_QUESTION)
                ID = msd.ShowModal()
                msd.Destroy()
                if ID != wx.ID_YES:
                    return
            # Update the override dict
            if (newName != defaultName) or (newArgs != defaultArgs):
                self.overrideDict[lowername] = (newName, newArgs, newType)
                extra += '*'
            else:
                if lowername in self.overrideDict:
                    del self.overrideDict[lowername]
            # Update the preset dict
            if boolAutoPreset:
                if lowername in self.presetDict:
                    del self.presetDict[lowername]
            else:
                self.presetDict[lowername] = newPreset
                extra += '~'
            if newType == enteredType:
                if arg and ftype is not None:
                    for i in xrange(listbox.GetCount()):
                        if newName == listbox.GetString(i).split()[0]:
                            listbox.SetSelection(i)
                            break
                listbox.SetString(listbox.GetSelection(), newName+extra)
            else:
                shortname = self.parent.GetPluginFunctionShortName(lowername)
                if newType == 2:
                    self.pluginDict[lowername] = 0
                    self.shortnamesDict[shortname].append(lowername)
                elif enteredType == 2:
                    del self.pluginDict[lowername]
                    if len(self.shortnamesDict[shortname]) == 1:
                        del self.shortnamesDict[shortname]
                    else:
                        self.shortnamesDict[shortname].remove(lowername)
                for index in xrange(self.notebook.GetPageCount()):
                    panel = self.notebook.GetPage(index)
                    if panel.functiontype == newType:
                        listindex = listbox.GetSelection()
                        ischecked = listbox.IsChecked(listindex)
                        listbox.Delete(listindex)
                        listindex = panel.listbox.Append(newName+extra)
                        panel.listbox.SetSelection(listindex)
                        panel.listbox.SetFirstItem(listindex)
                        panel.listbox.Check(listindex, ischecked)
                        self.notebook.SetSelection(index)
                        break
                else:
                    return

    def DeleteFunction(self):
        panel = self.notebook.GetCurrentPage()
        listbox = panel.listbox
        index = listbox.GetSelection()
        if index == wx.NOT_FOUND:
            return
        complete_string = listbox.GetString(index)
        name = complete_string.split()[0]
        lowername = name.lower()
        added_by_user = lowername not in self.filterDict
        modified = lowername != complete_string.rstrip().lower()
        if not added_by_user and not modified:
            return
        delete = not self.nag
        if self.nag:
            if added_by_user:
                message = _('Do you really want to delete this custom filter?')
            else:
                message = _('Do you really want to reset this filter?')
            dlg = wx.MessageDialog(self, message, _('Warning'), wx.YES_NO)
            ID = dlg.ShowModal()
            if ID == wx.ID_YES:
                delete = True
            dlg.Destroy()
        if delete:
            if lowername in self.overrideDict:
                del self.overrideDict[lowername]
            if lowername in self.presetDict:
                del self.presetDict[lowername]
            if added_by_user:
                if panel.functiontype == 2:
                    del self.pluginDict[lowername]
                    shortname = self.parent.GetPluginFunctionShortName(lowername)
                    if len(self.shortnamesDict[shortname]) == 1:
                        del self.shortnamesDict[shortname]
                    else:
                        self.shortnamesDict[shortname].remove(lowername)
                if lowername in self.removedSet:
                    self.removedSet.remove(lowername)
                listbox.Delete(index)
            else:
                listbox.SetString(index, name)

    def GetOverrideDict(self):
        return self.overrideDict

    def GetPresetDict(self):
        return self.presetDict

    def GetRemovedSet(self):
        return self.removedSet

    def GetAutocompletePluginNames(self):
        return self.pluginDict

    def GetPluginShortNames(self):
        return self.shortnamesDict


# Dialog specifically for AviSynth filter auto-slider information
class AvsFilterAutoSliderInfo(wx.Dialog):
    def __init__(self, parent, mainFrame, filterName, filterInfo, title=_('Edit filter database')):
        int5 = intPPI(5)
        int10 = intPPI(10)
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title, style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        self.mainFrame = mainFrame
        self.newFilterInfo = None
        # Filter name label
        filterLabel = wx.StaticText(self, wx.ID_ANY, filterName)
        font = filterLabel.GetFont()
        font.SetPointSize(int10)
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        filterLabel.SetFont(font)
        # Arguments
        argWindow = wx.ScrolledWindow(self, wx.ID_ANY, style=wx.TAB_TRAVERSAL)
        SetFontPPI(argWindow)
        argWindow.SetScrollRate(10, 10)
        argSizer = wx.GridBagSizer(hgap=0, vgap=int10)
        row = 0
        growable = False
        self.argctrls = []
        for argInfo in self.mainFrame.currentScript.GetFilterCalltipArgInfo(calltip=filterInfo):
            totalInfo, cArgType, cArgName, boolRepeatArg, boolOptionalArg, cArgInfo = argInfo
            argtype, argname, guitype, defaultValue, other = self.mainFrame.ParseCalltipArgInfo(totalInfo)
            #~ if guitype is None or argname is None or argtype not in ('int', 'float', 'bool', 'string'):
            if argname is None or argtype not in ('int', 'float', 'bool', 'string'):
                self.argctrls.append((argtype, argname, None, boolRepeatArg, boolOptionalArg))
            else:
                argLabel = wx.StaticText(argWindow, wx.ID_ANY, '%(argtype)s %(argname)s' % locals())
                argLabel.controls = []
                argSizer.Add(argLabel, (row,0), wx.DefaultSpan, wx.ALIGN_RIGHT|wx.ALIGN_BOTTOM|wx.BOTTOM|wx.RIGHT, int5)
                if argtype in ('int', 'float') and guitype != 'intlist':
                    strDefaultValue = strMinValue = strMaxValue = strMod = ''
                    if other is not None:
                        minValue, maxValue, nDecimal, mod = other
                        if nDecimal is None:
                            nDecimal = 0
                        strTemplate = '%.'+str(nDecimal)+'f'
                        if defaultValue is not None:
                            try:
                                strDefaultValue = strTemplate % defaultValue
                            except TypeError:
                                strDefaultValue = defaultValue
                        if minValue is not None:
                            try:
                                strMinValue = strTemplate % minValue
                            except TypeError:
                                strMinValue = minValue
                        if maxValue is not None:
                            try:
                                strMaxValue = strTemplate % maxValue
                            except TypeError:
                                strMaxValue = maxValue
                        if mod is not None:
                            try:
                                strMod = '%i' % mod
                            except TypeError:
                                strMod = mod
                    elif guitype == 'color':
                        strDefaultValue = '$%s' % defaultValue
                    itemData = (
                        (strDefaultValue, _('Default')),
                        (strMinValue, _('Min value')),
                        (strMaxValue, _('Max value')),
                        (strMod, _('Step size')),
                    )
                    hsizer = wx.BoxSizer(wx.HORIZONTAL)
                    for itemValue, itemName in itemData:
                        itemLabel = wx.StaticText(argWindow, wx.ID_ANY, itemName)
                        itemTextCtrl = wx.TextCtrl(argWindow, wx.ID_ANY, itemValue,size=(intPPI(75),-1))
                        vsizer = wx.BoxSizer(wx.VERTICAL)
                        vsizer.Add(itemLabel, 0, wx.LEFT, intPPI(2))
                        vsizer.Add(itemTextCtrl, 0, wx.ALL, 0)
                        hsizer.Add(vsizer, 0, wx.EXPAND|wx.RIGHT,int5)
                        argLabel.controls.append(itemTextCtrl)
                    argSizer.Add(hsizer, (row,1), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 0)
                elif argtype == 'bool':
                    strDefaultValue = ''
                    if defaultValue is not None:
                        if defaultValue.lower() == 'true':
                            strDefaultValue = 'True'
                        if defaultValue.lower() == 'false':
                            strDefaultValue = 'False'
                    itemLabel = wx.StaticText(argWindow, wx.ID_ANY, _('Default'))
                    itemTextCtrl = wx.ComboBox(argWindow, wx.ID_ANY, strDefaultValue, choices=['True', 'False'], style=wx.CB_DROPDOWN, size=(intPPI(75),-1))
                    vsizer = wx.BoxSizer(wx.VERTICAL)
                    vsizer.Add(itemLabel, 0, wx.LEFT, intPPI(2))
                    vsizer.Add(itemTextCtrl, 0, wx.ALL, 0)
                    argLabel.controls.append(itemTextCtrl)
                    argSizer.Add(vsizer, (row,1), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 0)
                elif argtype == 'string' or argtype == 'int' and guitype == 'intlist':
                    strDefaultValue = strValuesList = ''
                    if defaultValue is not None:
                        if defaultValue:
                            if argtype == 'string':
                                strDefaultValue = '"%s"' % defaultValue.strip('"')
                            else:
                                strDefaultValue = str(defaultValue)
                    if other is not None:
                        strValuesList = ', '.join(other)
                    hsizer = wx.BoxSizer(wx.HORIZONTAL)
                    # Default control
                    itemLabel = wx.StaticText(argWindow, wx.ID_ANY, _('Default'))
                    itemTextCtrl = wx.TextCtrl(argWindow, wx.ID_ANY, strDefaultValue, size=(intPPI(75),-1))
                    vsizer = wx.BoxSizer(wx.VERTICAL)
                    vsizer.Add(itemLabel, 0, wx.LEFT, intPPI(2))
                    vsizer.Add(itemTextCtrl, 0, wx.ALL, 0)
                    argLabel.controls.append(itemTextCtrl)
                    hsizer.Add(vsizer, 0, wx.EXPAND|wx.RIGHT,intPPI(5))
                    # Values control
                    itemLabel = wx.StaticText(argWindow, wx.ID_ANY, _('Value list (comma separated)'))
                    itemTextCtrl = wx.TextCtrl(argWindow, wx.ID_ANY, strValuesList, size=(intPPI(200),-1))
                    vsizer = wx.BoxSizer(wx.VERTICAL)
                    vsizer.Add(itemLabel, 0, wx.LEFT, intPPI(2))
                    vsizer.Add(itemTextCtrl, 1, wx.EXPAND|wx.ALL, 0)
                    argLabel.controls.append(itemTextCtrl)
                    hsizer.Add(vsizer, 1, wx.EXPAND|wx.RIGHT,int5)

                    argSizer.Add(hsizer, (row,1), wx.DefaultSpan, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 0)
                    if wx.VERSION > (2, 9):
                        if not argSizer.IsColGrowable(1):
                            argSizer.AddGrowableCol(1)
                    else:
                        if not growable:
                            argSizer.AddGrowableCol(1)
                            growable = True
                row += 1
                self.argctrls.append((argtype, argname, argLabel, boolRepeatArg, boolOptionalArg))
        argWindow.SetSizer(argSizer)
        # Standard buttons
        okay  = wx.Button(self, wx.ID_OK, _('OK'))
        SetFontPPI(okay)
        self.Bind(wx.EVT_BUTTON, self.OnButtonOK, okay)
        okay.SetDefault()
        cancel = wx.Button(self, wx.ID_CANCEL, _('Cancel'))
        SetFontPPI(cancel)
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        # Set the sizer
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add((-1,-1), 0, wx.TOP, int10)
        sizer.Add(filterLabel, 0, wx.EXPAND|wx.ALL, int5)
        sizer.Add(wx.StaticLine(self, wx.ID_ANY), 0, wx.EXPAND|wx.LEFT|wx.RIGHT, int5)
        sizer.Add(argWindow, 1, wx.EXPAND|wx.ALL, int5)
        sizer.Add(wx.StaticLine(self, wx.ID_ANY), 0, wx.EXPAND|wx.LEFT|wx.RIGHT, int5)
        #~ sizer.Add(wx.StaticText(self,wx.ID_ANY, _('* optional value')), 0, wx.EXPAND|wx.ALL, 10)
        sizer.Add(btns, 0, wx.EXPAND|wx.ALL, int5)
        self.SetSizer(sizer)
        sizer.Layout()
        argWindow.FitInside()
        w, h = argSizer.GetMinSize()
        w = max(intPPI(w + 10), intPPI(400))
        h = min(intPPI(h + 100), intPPI(700))
        self.SetSize(self.ClientToWindowSize((w, h)))
        if argWindow.HasScrollbar(wx.HORIZONTAL):
            scrollbar_w = wx.SystemSettings_GetMetric(wx.SYS_VSCROLL_X)
            self.SetSize(self.ClientToWindowSize((w + scrollbar_w, -1)))

    def OnButtonOK(self, event):
        strList = []
        for argtype, argname, argLabel, boolRepeatArg, boolOptionalArg in self.argctrls:
            if argtype is None and argname is None:
                continue
            strBase = '%(argtype)s %(argname)s' % locals()
            strInfoNew = strBase
            if argLabel is None:
                if argname is None:
                    strInfoNew = argtype
            else:
                strDef = argLabel.controls[0].GetValue().strip()
                is_list = argtype == 'int' and argLabel.controls[1].GetValue().count(',')
                #~ strList.append('%(strBase)s=%(strDefaultValue)s' % locals())
                if argtype in ('int', 'float') and not is_list:
                    strMin = argLabel.controls[1].GetValue().strip()
                    strMax = argLabel.controls[2].GetValue().strip()
                    strMod = argLabel.controls[3].GetValue().strip()
                    # Validate if any field has input
                    sliderValues = None
                    if strDef or strMin or strMax or strMod:
                        errorType, errorMessage, sliderValues = self.mainFrame.ValidateAvsSliderInputs(strDef, strMin, strMax, strMod)
                        if errorType is not None and errorType != -1:
                            self.ShowWarning(argLabel.controls[errorType], '%(argtype)s %(argname)s: %(errorMessage)s' % locals())
                            return
                    # Create the new string info
                    if strDef and not strMin and not strMax:
                        strInfoNew = '%(strBase)s=%(strDef)s' % locals()
                    elif not strMin and not strMax:
                        strInfoNew = strBase
                    elif strMod:
                        strInfoNew = '%(strBase)s=%(strDef)s (%(strMin)s to %(strMax)s by %(strMod)s)' % locals()
                    else:
                        strInfoNew = '%(strBase)s=%(strDef)s (%(strMin)s to %(strMax)s)' % locals()
                elif argtype == 'bool':
                    if strDef:
                        if strDef.lower() not in ('true', 'false'):
                            self.ShowWarning(argLabel.controls[0], '%s %s: %s' % (argtype, argname, _('Value must be True or False!')), comboBox=True)
                            return
                        strInfoNew = '%(strBase)s=%(strDef)s' % locals()
                elif argtype == 'string' or argtype == 'int' and is_list:
                    strValues = argLabel.controls[1].GetValue().strip()
                    if strDef or strValues:
                        if not strValues:
                            strValuesNew = ''
                            pass
                        else:
                            if argtype == 'int':
                                strValuesNew = ' (%s)' % ' / '.join([s.strip() for s in strValues.split(',')])
                            else:
                                strValuesNew = ' (%s)' % '/ '.join(['"%s"' % s.strip(' "') for s in strValues.split(',')])
                        if strDef and argtype == 'string':
                            strDef = '"%s"' % strDef.strip('"')
                        strInfoNew = '%(strBase)s=%(strDef)s%(strValuesNew)s' % locals()
            strRepeatArg = ''
            if boolRepeatArg:
                strRepeatArg = ' [, ...]'
            if boolOptionalArg:
                strInfoNew = '[{0}]'.format(strInfoNew)
            strList.append(strInfoNew+strRepeatArg)
        self.newFilterInfo = '(\n%s\n)' % ',\n'.join(strList)
        event.Skip()

    def GetNewFilterInfo(self):
        return self.newFilterInfo

    def ShowWarning(self, textCtrl, message, comboBox=False):
        color = textCtrl.GetBackgroundColour()
        textCtrl.SetBackgroundColour('pink')
        textCtrl.Refresh()
        wx.MessageBox(message, _('Error'), style=wx.OK|wx.ICON_ERROR)
        textCtrl.SetBackgroundColour(color)
        textCtrl.Refresh()
        textCtrl.GetParent().Refresh()
        if comboBox:
            textCtrl.SetMark(-1,-1)
        else:
            textCtrl.SetSelection(-1,-1)
        textCtrl.SetFocus()
        textCtrl.Refresh()

# Dialog for filter customization exporting/importing
class AvsFunctionExportImportDialog(wx.Dialog):
    def __init__(self, parent, infoDict, export=True):
        int5 = intPPI(5)
        self.export = export
        if export:
            title = _('Export filter customizations')
        else:
            title = _('Import filter customizations')
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title, size=tuplePPI(500,300), style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        SetFontPPI(self)
        self.calltipDict = infoDict[0]
        self.presetDict = infoDict[1]
        self.docpathDict = infoDict[2]
        self.functiontypeDict = infoDict[3]

        # Create the list control using the dictionary
        decList = [(s.lower(), s) for s in self.calltipDict.keys()]
        decList.sort()
        self.names = [s[1] for s in decList]
        self.checkListBox = wx.CheckListBox(self, wx.ID_ANY, choices=self.names)

        # Create extra control buttons
        def OnButtonSelectAll(event):
            for index in xrange(len(self.names)):
                self.checkListBox.Check(index, True)
        def OnButtonClearAll(event):
            for index in xrange(len(self.names)):
                self.checkListBox.Check(index, False)
        buttonSelectAll = wx.Button(self, wx.ID_ANY, _('Select all'))
        self.Bind(wx.EVT_BUTTON, OnButtonSelectAll, buttonSelectAll)
        buttonClearAll = wx.Button(self, wx.ID_ANY, _('Clear all'))
        self.Bind(wx.EVT_BUTTON, OnButtonClearAll, buttonClearAll)

        if export:
            staticText = wx.StaticText(self, wx.ID_ANY, _('Select filters to export:'))
            extraItem = (-1, intPPI(20))
        else:
            staticText = wx.StaticText(self, wx.ID_ANY, _('Select filters to import from the file:'))
            # Import dialog, check all names by default
            for index in xrange(len(self.names)):
                self.checkListBox.Check(index)
            self.checkBoxOverwriteAll = wx.CheckBox(self, wx.ID_ANY, _('Overwrite all data'))
            self.checkBoxOverwriteAll.SetValue(True)
            extraItem = wx.BoxSizer(wx.VERTICAL)
            extraItem.Add(self.checkBoxOverwriteAll, 0, wx.LEFT|wx.BOTTOM, int5)

        # Standard buttons
        okay  = wx.Button(self, wx.ID_OK, _('OK'))
        SetFontPPI(okay)
        self.Bind(wx.EVT_BUTTON, self.OnButtonOK, okay)
        cancel = wx.Button(self, wx.ID_CANCEL, _('Cancel'))
        SetFontPPI(cancel)
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()

        # Size the elements
        buttonSizer = wx.BoxSizer(wx.VERTICAL)
        buttonSizer.Add(buttonSelectAll, 0, wx.ALL, int5)
        buttonSizer.Add(buttonClearAll, 0, wx.ALL, int5)
        listSizer = wx.BoxSizer(wx.HORIZONTAL)
        listSizer.Add(self.checkListBox, 1, wx.EXPAND|wx.ALL, int5)
        listSizer.Add(buttonSizer, 0, wx.ALL, intPPI(5))
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add((-1,int5))
        dlgSizer.Add(staticText, 0, wx.ALL, int5)
        dlgSizer.Add(listSizer, 1, wx.EXPAND|wx.LEFT|wx.RIGHT, int5)
        dlgSizer.Add(extraItem, 0, wx.ALL, int5)
        dlgSizer.Add(btns, 0, wx.EXPAND|wx.ALL, int5)
        self.SetSizer(dlgSizer)
        dlgSizer.SetSizeHints(self)
        # Misc
        okay.SetDefault()

    def OnButtonOK(self, event):
        self.dlgDataDict = {}
        # Build the dictionnary from the checked filters
        for i, name in enumerate(self.names):
            if self.checkListBox.IsChecked(i):
                calltip = self.calltipDict.get(name, '')
                preset = self.presetDict.get(name, '')
                docpath = self.docpathDict.get(name, '')
                ftype = self.functiontypeDict.get(name, '')
                self.dlgDataDict[name] = (calltip, preset, docpath, ftype)
        if not self.dlgDataDict:
            wx.MessageBox(_('You must select at least one filter!'), _('Warning'))
            return
        event.Skip()

    def GetData(self):
        return self.dlgDataDict

    def GetOverwriteAll(self):
        return self.checkBoxOverwriteAll.GetValue()

# Custom slider
class SliderPlus(wx.Panel):
    def __init__(self, parent, app, id, value=0, minValue=0, maxValue=100, size=(-1, 28), dpiScale=1.0, titleDict={}):
        self.dpiScale = dpiScale
        _size = size[0], int(size[1]*dpiScale)
        wx.Panel.__init__(self, parent, id, size=_size, style=wx.WANTS_CHARS)
        self.titleDict = titleDict # GPo TODO, remove it and store the titles in the bookmarks
        self.selectionsDict = {}
        self.childSelectionsDict = None  # Update this dict on create selections
        self.parent = parent
        self.app = app
        self.minValue = minValue
        self.maxValue = maxValue
        self.startOffset = 0
        self.endOffset = 0
        self.offsetSet = False
        self.showTime = False
        self.showNumbers = True
        self.numDivisor = 5
        self.value = max(min(value, self.maxValue), self.minValue)
        self.bookmarks = {}
        #~self.mouse_wheel_rotation = 0  # GPo, not used
        # Internal display variables
        self.isclicked = False
        self.xdelta = None
        self.selections = None
        self.selmode = 0
        self.xo = int(15*dpiScale)
        self.yo = int(5*dpiScale)
        self.yo2 = int(10*dpiScale)
        self.wT = int(22*dpiScale)
        self.wH = int(10*dpiScale)
        # GPo
        self.hilightBookmarks = False
        self.bookmarksHilightColor = wx.Brush(wx.RED)
        self.selectionsHilightColor = wx.Brush(wx.BLUE)
        self.paintWait = False
        self.AVI_SplitClip = False
        ###
        self._DefineBrushes()
        # Event binding
        self.Bind(wx.EVT_PAINT, self._OnPaint)
        self.Bind(wx.EVT_SIZE, self._OnSize)
        self.Bind(wx.EVT_LEFT_DOWN, self._OnLeftDown)
        self.Bind(wx.EVT_MOTION, self._OnMouseMotion)
        self.Bind(wx.EVT_LEFT_UP, self._OnLeftUp)
        #~self.Bind(wx.EVT_MOUSEWHEEL, self._OnMouseWheel)  # GPo, in this version not used
        #self.Bind(wx.EVT_KEY_DOWN, self._OnKeyDown)
        def OnSetFocus(event):
            if not self.HasCapture():
                try:
                    event.GetWindow().SetFocus()
                except AttributeError:
                    event.Skip()
        self.Bind(wx.EVT_SET_FOCUS, OnSetFocus)

    def intPPI(self, n):
        return int(self.dpiScale * n)

    def _DefineBrushes(self):
        self.colorBackground = self.GetBackgroundColour() # GPo
        #self.colorBackground = (43,43,43)
        colorHighlight = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DLIGHT)
        colorHighlight2 = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DHILIGHT)
        colorShadow = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DSHADOW)
        colorDarkShadow = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)
        colorWindow = colorHighlight2#wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)
        colorHandle = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNFACE)
        #r,g,b = colorHandle.Red(), colorHandle.Green(), colorHandle.Blue()
        colorHandle2 = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNHIGHLIGHT)
        colorGrayText = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)
        # GPo 2020
        self.penWindowBackground = wx.Pen(self.colorBackground)
        if self.hilightBookmarks or self.selmode == 1:
            if self.value in self.selectionsDict:
                self.brushWindowBackground = self.selectionsHilightColor
            elif self.value in self.bookmarks:
                self.brushWindowBackground = self.bookmarksHilightColor
            else:
                self.brushWindowBackground = wx.Brush(self.colorBackground)
        else:
            self.brushWindowBackground = wx.Brush(self.colorBackground)

        # test
        """
        colorHighlight = (100,100,100)
        colorHighlight2 = (140,140,140)
        colorShadow = (130,130,130)
        colorDarkShadow = (100,100,100)
        colorWindow = (63,63,63)
        colorHandle = (180,180,40)
        colorHandle2 = (200,200,80)
        ###
        """
        colorBookmarks = (0,0,0)

        self.penBackground = wx.Pen(colorWindow)
        self.brushBackground = wx.Brush(colorWindow)
        self.penShadow = wx.Pen(colorShadow)
        self.penDarkShadow = wx.Pen(colorDarkShadow)
        self.penHighlight = wx.Pen(colorHighlight)
        self.penHighlight2 = wx.Pen(colorHighlight2)
        self.penHandle = wx.Pen(colorHandle)
        self.brushHandle = wx.Brush(colorHandle)
        self.brushHandleHighlight = wx.Brush((160,160,160))
        self.penHandle2 = wx.Pen(colorHandle2)
        self.brushHandle2 = wx.Brush(colorHandle2)
        self.penGrayText = wx.Pen(colorGrayText)
        self.brushGrayText = wx.Brush(colorGrayText)
        self.penBookmarks = wx.Pen(colorBookmarks)
        self.brushBookmarks = wx.Brush(colorBookmarks)
        self.brushOffset = wx.Brush(colorHighlight)
        self.penOffset = wx.Pen(colorHighlight)
        self.brushSplitClip =  wx.Brush(self.app.options['timelinesplitclipcolor'])  # default wx.Brush((100,160,120))

    def _StopPlaying(self):  # GPo 2020
        if self.app.playing_video:
            self.app.PlayPauseVideo()
            self.app.playing_video = '' # starts playing again OnSliderReleased

    def _OnLeftDown(self, event):
        self.app.lastshownframe = self.app.paintedframe
        self.paintWait = False
        mousepos = event.GetPosition()
        x, y, w, h = self.GetRect()
        rectHandle = self._getRectHandle()
        rectBox = wx.Rect(0, 0+self.yo, w, h-self.yo-self.yo2)
        if rectHandle.Inside(mousepos): # slider button itself
            self._StopPlaying()
            self.isclicked = True
            self.paintWait = True
            self.xdelta = mousepos.x - rectHandle.x
            self.CaptureMouse()
            self._Refresh(False)
        elif self.selmode == 1 and self._HitTestHandleDeadZone(mousepos):
            pass
        elif rectBox.Inside(mousepos):
            self._StopPlaying()
            self.isclicked = True
            self.CaptureMouse()
            oldvalue = self.value
            self.SetValue(self.startOffset + int(round((mousepos.x-self.xo) * (self.maxValue - self.minValue) / float(w-2*self.xo))))
            if self.value != oldvalue:
                self.paintWait = True
                self._Refresh(False)
                self._SendScrollEvent()
            rectHandle = self._getRectHandle()
            self.xdelta = mousepos.x - rectHandle.x
        event.Skip()

    def _OnMouseMotion(self, event):
        if event.Dragging() and event.LeftIsDown() and self.HasCapture():
            x, y, w, h = self.GetRect()
            xmouse, ymouse = event.GetPosition()
            oldvalue = self.value
            self.SetValue(self.startOffset + int(round((xmouse-self.xdelta-self.xo+self.wH/2) * (self.maxValue - self.minValue) / float(w-2*self.xo))))
            if self.value != oldvalue:
                self._SendScrollEvent()

    def _OnLeftUp(self, event):
        self.isclicked = False
        self.xdelta = None
        if self.HasCapture():
            self.ReleaseMouse()
            self.adjust_handle = True
            self._SendScrollEndEvent()
        else:
            # If clicked on a bookmark, go to that frame
            mousepos = event.GetPosition()
            index = self.HitTestBookmark(mousepos)
            if index is not None:
                self._StopPlaying()
                self.paintWait = True
                self.SetValue(index)
                self.adjust_handle = False
                self._SendScrollEndEvent()
        event.Skip()

    """
    # GPo, in this version not used, if you enable it,
    # you must enable #~self.Bind(wx.EVT_MOUSEWHEEL, self._OnMouseWheel)
    def _OnMouseWheel(self, event):
        #~ if event.LeftIsDown():
        if not self.HasCapture():
            rotation = event.GetWheelRotation()
            if self.mouse_wheel_rotation * rotation < 0:
                self.mouse_wheel_rotation = rotation
            else:
                self.mouse_wheel_rotation += rotation
            if abs(self.mouse_wheel_rotation) >= event.GetWheelDelta():
                delta = -1 if self.mouse_wheel_rotation > 0 else 1
                if self.app.options['invertscrolling']: delta = -delta
                self.mouse_wheel_rotation = 0
                oldvalue = self.value
                self.SetValue(self.value + delta)
                if self.value != oldvalue:
                    self._SendScrollEvent()
    """
    """
    def _OnKeyDown(self, event):
        if self.HasCapture():
            key = event.GetKeyCode()
            oldvalue = self.value
            if key in (wx.WXK_LEFT, wx.WXK_UP):
                self.SetValue(self.value-1)
            elif key in (wx.WXK_RIGHT, wx.WXK_DOWN):
                self.SetValue(self.value+1)
            if self.value != oldvalue:
                self._SendScrollEvent()
    """
    def _SendScrollEvent(self):
        event = wx.CommandEvent(wx.wxEVT_SCROLL_THUMBTRACK, self.GetId())
        event.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(event)

    def _SendScrollEndEvent(self):
        event = wx.CommandEvent(wx.wxEVT_SCROLL_ENDSCROLL, self.GetId())
        event.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(event)
        self.paintWait = False
        self._Refresh(False)

    def _OnSize(self, event):
        self._Refresh(False)

    def _OnPaint(self, event):
        #dc = wx.PaintDC(self)
        dc = wx.BufferedPaintDC(self)
        self._PaintSlider(dc)

    # repaint only the slider button (it's faster for button color changes)
    def PaintSliderHandle(self, dc=None):
        if not dc:
            if self.IsDoubleBuffered():
                dc = wx.ClientDC(self)
            else:
                dc = wx.BufferedDC(wx.ClientDC(self))
        boolEnabled = self.IsEnabled()
        w, h = self.GetSize()
        xB, yB, wB, hB = self.xo, self.yo, w-2*self.xo, h-self.yo-self.yo2
        xH, yH, wH, hH = -1, self.yo-3, self.wH, hB+6
        pixelpos = int(self.value * wB / float(self.maxValue - self.minValue)) + self.xo
        pixelpos0 = pixelpos - self.wH/2
        if not boolEnabled:
            dc.SetPen(self.penHandle2)
            dc.SetBrush(self.brushHandle2)
        elif self.paintWait or self.isclicked:
            #dc.SetClippingRect(wx.Rect(pixelpos0+3, yH+3, wH-6, hH-6))
            dc.SetPen(self.penHandle)
            dc.SetBrush(self.brushHandleHighlight)
        else:
            dc.SetPen(self.penHandle)
            dc.SetBrush(self.brushHandle)
        # clear only the button
        dc.SetClippingRect(wx.Rect(pixelpos0, yH, wH, hH))
        dc.Clear()
        # now draw the button
        dc.DrawRectangle(pixelpos0, yH, wH, hH)
        dc.SetPen(self.penHighlight2)
        dc.DrawLine(pixelpos0, yH, pixelpos0+wH, yH)
        dc.DrawLine(pixelpos0, yH, pixelpos0, yH+hH)
        dc.SetPen(self.penDarkShadow)
        dc.DrawLine(pixelpos0+wH, yH, pixelpos0+wH, yH+hH)
        dc.DrawLine(pixelpos0, yH+hH, pixelpos0+wH+1, yH+hH)
        dc.SetPen(self.penShadow)
        dc.DrawLine(pixelpos0+wH-1, yH+1, pixelpos0+wH-1, yH+hH)
        dc.DrawLine(pixelpos0+1, yH+hH-1, pixelpos0+wH, yH+hH-1)

    # GPo 2020, changed, I want do handle the selections seperataly (not in bookmarks stored)
    def _PaintSlider(self, dc):
        boolEnabled = self.IsEnabled()
        # Paint the bar
        x, y = (0, 0)
        w, h = self.GetSize()
        xB, yB, wB, hB = self.xo, self.yo, w-2*self.xo, h-self.yo-self.yo2
        xH, yH, wH, hH = -1, self.yo-3, self.wH, hB+6
        # First paint background
        dc.SetPen(self.penWindowBackground)
        dc.SetBrush(self.brushWindowBackground)
        dc.DrawRectangle(0, 0, w, h)
        if self.AVI_SplitClip:
            dc.SetBrush(self.brushSplitClip)
            dc.SetPen(self.penOffset)
        elif self.offsetSet:
            dc.SetPen(self.penOffset)
            dc.SetBrush(self.brushOffset)
        else:
            dc.SetPen(self.penBackground)
            dc.SetBrush(self.brushBackground)
        dc.DrawRectangle(xB, yB, wB, hB)

        # draw the bookmark triangles
        dc.SetPen(self.penWindowBackground)
        if boolEnabled:
            dc.SetBrush(self.brushBookmarks)
        else:
            dc.SetBrush(self.brushGrayText)
        wT = self.wT
        lastpixelpos = -1
        for value in self.bookmarks.keys(): # no check for bmtype, so that we can see -> all ok
            if ((value-self.startOffset) > self.maxValue) or (value < self.minValue+self.startOffset):
                continue
            pixelpos = int((value-self.startOffset) * wB / float(self.maxValue - self.minValue)) + self.xo
            if pixelpos == lastpixelpos: # speed it up if next bookmark pixelpos the last one (int rounding float/int)
                continue
            if value in self.titleDict:
                dc.SetBrush(wx.BLUE_BRUSH)
            else:
                dc.SetBrush(self.brushBookmarks)
            p1 = wx.Point(pixelpos, h-wT/2)
            p2 = wx.Point(pixelpos-wT/4, h)
            p3 = wx.Point(pixelpos+wT/4, h)
            dc.DrawPolygon((p1, p2, p3))
            lastpixelpos = pixelpos

        # draw the selection marks
        dc.SetBrush(self.brushBookmarks)
        for value, bmtype in self.selectionsDict.items():
            if ((value-self.startOffset) > self.maxValue) or (value < self.minValue+self.startOffset):
                continue
            pixelpos = int((value-self.startOffset) * wB / float(self.maxValue - self.minValue)) + self.xo
            p1 = wx.Point(pixelpos, h-wT/2)
            if bmtype == 1:
                p2 = wx.Point(pixelpos-wT/2, h)
                p3 = wx.Point(pixelpos, h)
                dc.DrawPolygon((p1, p2, p3))
                dc.SetPen(self.penBookmarks)
                dc.DrawLine(pixelpos, h-1, pixelpos+wT/4, h-1)
                dc.SetPen(self.penWindowBackground)
            elif bmtype == 2:
                p2 = wx.Point(pixelpos, h)
                p3 = wx.Point(pixelpos+wT/2, h)
                dc.DrawPolygon((p1, p2, p3))
                dc.SetPen(self.penBookmarks)
                dc.DrawLine(pixelpos, h-1, pixelpos-wT/4, h-1)
                dc.SetPen(self.penWindowBackground)

        # draw the selections
        if self.selections is not None:
            if boolEnabled:
                if not self.offsetSet:
                    dc.SetPen(wx.Pen(wx.BLUE))
                    dc.SetBrush(wx.BLUE_BRUSH)
                else:
                    color = wx.Colour(90,95,200)
                    dc.SetPen(wx.Pen(color))
                    dc.SetBrush(wx.Brush(color))
            else:
                color = wx.Colour(200,200,230)
                dc.SetPen(wx.Pen(color))
                dc.SetBrush(wx.Brush(color))

            for start, stop in self.selections:
                start = min(max((start-self.startOffset), self.minValue), self.maxValue)
                stop = min(max((stop-self.startOffset), self.minValue), self.maxValue)
                if start == stop: # or remove it and show the marks on timeline end
                    continue
                pixelstart = int(start * wB / float(self.maxValue - self.minValue)) + self.xo
                pixelstop = int(stop * wB / float(self.maxValue - self.minValue)) + self.xo
                dc.DrawRectangle(pixelstart, yB, pixelstop - pixelstart, hB)

        # draw offset info, before border
        if self.offsetSet:
            dc.SetFont(wx.Font(pointSize=round(self.dpiScale*9), family=wx.FONTFAMILY_DEFAULT, style=wx.FONTSTYLE_NORMAL, weight=wx.FONTWEIGHT_NORMAL))
            dc.SetTextForeground(wx.WHITE)
            dc.SetTextBackground(wx.Colour(70,70,70))
            dc.SetBackgroundMode(wx.BRUSHSTYLE_SOLID)
            endtxt = str((self.maxValue + self.endOffset) - (self.startOffset + self.maxValue))
            txw, txh = dc.GetTextExtent(endtxt)
            dc.DrawText('%i' % self.startOffset, xB+self.dpiScale*7, yB)
            dc.DrawText(endtxt, (wB+self.dpiScale*8)-txw, yB)
            # draw the frame or time numbers
            if self.showNumbers:
                dc.SetPen(self.penBookmarks)
                dc.SetTextBackground(wx.Colour(50,50,160))
                if self.showTime and self.app.currentScript.AVI is not None:
                    framerate = self.app.currentScript.AVI.Framerate
                else: framerate = None
                startval = int(self.maxValue/self.numDivisor) # set here the needed count (10 = 9 parts)
                for i in xrange(self.numDivisor+1):
                    pixelpos = self.xo + int((i*startval)*wB / float(self.maxValue - self.minValue))
                    dc.DrawLine(pixelpos, 0, pixelpos, yB)
                    if i > 0 and i < self.numDivisor:
                        if framerate:
                            try:
                                posTxt = self.app.FormatTime((self.startOffset + (startval*i))/float(framerate))
                            except:
                                posTxt = str(self.startOffset + (startval*i))
                                framerate = None
                        else:
                            posTxt = str(self.startOffset + (startval*i))
                        txw, txh = dc.GetTextExtent(posTxt)
                        dc.DrawText(posTxt, pixelpos-int(txw/2.0), yB)
        # Then paint the border
        dc.SetPen(self.penShadow)
        dc.DrawLine(xB, yB, xB+wB, yB)
        dc.DrawLine(xB, yB, xB, yB+hB)
        dc.SetPen(self.penDarkShadow)
        dc.DrawLine(xB+1, yB+1, xB+wB, yB+1)
        dc.DrawLine(xB+1, yB+1, xB+1, yB+hB)
        dc.SetPen(self.penHighlight2)
        dc.DrawLine(xB+wB, yB, xB+wB, yB+hB)
        dc.DrawLine(xB, yB+hB, xB+wB+1, yB+hB)
        dc.SetPen(self.penHighlight)
        dc.DrawLine(xB+wB-1, yB+1, xB+wB-1, yB+hB)
        dc.DrawLine(xB+1, yB+hB-1, xB+wB, yB+hB-1)
        # Then paint the handle
        pixelpos = int(self.value * wB / float(self.maxValue - self.minValue)) + self.xo
        pixelpos0 = pixelpos - self.wH/2
        """
        if self.isclicked or not boolEnabled:
            dc.SetPen(self.penHandle2)
            dc.SetBrush(self.brushHandle2)
        else:
            dc.SetPen(self.penHandle)
            dc.SetBrush(self.brushHandle)
        """
        if not boolEnabled:
            dc.SetPen(self.penHandle2)
            dc.SetBrush(self.brushHandle2)
        elif self.paintWait or self.isclicked:
            dc.SetPen(self.penHandle)
            dc.SetBrush(self.brushHandleHighlight)
        else:
            dc.SetPen(self.penHandle)
            dc.SetBrush(self.brushHandle)

        dc.DrawRectangle(pixelpos0, yH, wH, hH)
        dc.SetPen(self.penHighlight2)
        dc.DrawLine(pixelpos0, yH, pixelpos0+wH, yH)
        dc.DrawLine(pixelpos0, yH, pixelpos0, yH+hH)
        dc.SetPen(self.penDarkShadow)
        dc.DrawLine(pixelpos0+wH, yH, pixelpos0+wH, yH+hH)
        dc.DrawLine(pixelpos0, yH+hH, pixelpos0+wH+1, yH+hH)
        dc.SetPen(self.penShadow)
        dc.DrawLine(pixelpos0+wH-1, yH+1, pixelpos0+wH-1, yH+hH)
        dc.DrawLine(pixelpos0+1, yH+hH-1, pixelpos0+wH, yH+hH-1)
        # if trim dlg is shown paint the slider buttons
        if self.selmode == 1:
            hH2 = hH/2
            border = 3
            yH2 = yB #yH + hH/4
            for seltype in (1,2):
                if seltype == 1:
                    xpos = pixelpos0 - self.wH
                    p1 = wx.Point(xpos+border, yH2+hH2-border)
                    p2 = wx.Point(xpos+self.wH-border, yH2+hH2-border)
                    p3 = wx.Point(xpos+self.wH-border, yH2+border)
                else:
                    xpos = pixelpos0 + self.wH #+ 1
                    p1 = wx.Point(xpos+border, yH2+border)
                    p2 = wx.Point(xpos+border, yH2+hH2-border)
                    p3 = wx.Point(xpos+self.wH-border, yH2+hH2-border)
                # Draw the button
                dc.SetPen(self.penHandle)
                dc.SetBrush(self.brushHandle)
                dc.DrawRectangle(xpos, yH2, self.wH, hH2)
                dc.SetPen(self.penHighlight2)
                dc.DrawLine(xpos, yH2, xpos+wH, yH2)
                dc.DrawLine(xpos, yH2, xpos, yH2+hH2)
                dc.SetPen(self.penDarkShadow)
                if seltype == 2:
                    dc.DrawLine(xpos+wH, yH2, xpos+wH, yH2+hH2)
                    dc.DrawLine(xpos, yH2+hH2, xpos+wH+1, yH2+hH2)
                else:
                    dc.DrawLine(xpos, yH2+hH2, xpos+wH, yH2+hH2)
                dc.SetPen(self.penShadow)
                dc.DrawLine(xpos+wH-1, yH2+1, xpos+wH-1, yH2+hH2)
                dc.DrawLine(xpos+1, yH2+hH2-1, xpos+wH, yH2+hH2-1)
                # Draw the button image
                if boolEnabled:
                    dc.SetPen(wx.BLACK_PEN)
                    dc.SetBrush(wx.BLACK_BRUSH)
                else:
                    dc.SetPen(self.penGrayText)
                    dc.SetBrush(self.brushGrayText)
                dc.DrawPolygon((p1, p2, p3))

    # GPo 2020 changed (childSelectionsDict = script selectionsDict)
    def _createSelections(self):
        def updateChild():
            if isinstance(self.childSelectionsDict, dict):
                try:
                    self.childSelectionsDict.clear()
                    self.childSelectionsDict.update(self.selectionsDict)
                except:
                    pass

        selectionmarks = [item for item in self.selectionsDict.items()]
        if len(selectionmarks) == 0:
            updateChild()
            return None
        selectionmarks.sort()
        selectionList = []
        start = stop = None
        if selectionmarks[0][1] == 2:
            start = self.minValue
        for value, bmtype in selectionmarks:
            if start is None:
                if bmtype == 1:
                    start = value
            else:
                if bmtype == 2:
                    stop = value
                    selectionList.append((start, stop))
                    start = stop = None

        if start is not None:
            stop = self.maxValue + self.endOffset
            selectionList.append((start, stop))

        updateChild()
        return selectionList

    def _getRectHandle(self):
        x, y, w, h = self.GetRect()
        pixelpos = int(self.value* (w-2*self.xo) / float(self.maxValue - self.minValue))
        rectHandle = wx.Rect(pixelpos-self.wH/2+self.xo, self.yo-3, self.wH, h-self.yo-self.yo2+6)
        return rectHandle

    def GetValue(self):
        return self.value + self.startOffset

    def GetMin(self):
        return self.minValue

    def GetMax(self):
        return self.maxValue + self.endOffset

    def GetVirtualMin(self):
        return self.startOffset

    def GetVirtualMax(self):
        return self.startOffset + self.maxValue

    def _Refresh(self, updateSelections):
        if updateSelections:
            if self.selectionsDict:
                self.selections = self._createSelections()
            else:
                try: # update only if needed
                    if self.selections is not None and isinstance(self.childSelectionsDict, dict):
                        self.childSelectionsDict.clear()
                except:
                    pass
                self.selections = None

        if self.IsDoubleBuffered():
            dc = wx.ClientDC(self)
        else:
            dc = wx.BufferedDC(wx.ClientDC(self))
        dc.Clear()
        self._PaintSlider(dc)

    def SetBookmarkHilighting(self, enabled=False):  # GPo
        if self.hilightBookmarks != enabled:
            if not enabled and not self.app.trimDialog.IsShown():
                self.selmode = 0
            self.hilightBookmarks = enabled
        self._DefineBrushes()

    def SetValue(self, value):
        value -= self.startOffset
        self.value = max(min(value, self.maxValue), self.minValue)
        # GPo, higlight also selection marks, easier do find the start and end points
        if self.hilightBookmarks:
            if self.selections and self.value+self.startOffset in self.selectionsDict:
                self.brushWindowBackground = self.selectionsHilightColor
            elif self.value+self.startOffset in self.bookmarks:
                self.brushWindowBackground = self.bookmarksHilightColor
            else:
                self.brushWindowBackground = wx.Brush(self.colorBackground)
        self._Refresh(False)
        return True

    def SetOffset(self, start, end):
        self.startOffset = start
        self.endOffset = end
        self.offsetSet = start != 0 or end != 0

    def SetRange(self, minValue, maxValue, refresh=True):
        if minValue >= maxValue:
            if minValue == 0 and (maxValue == -1 or maxValue == 0):
                maxValue = 1
            else:
                print>>sys.stderr, _('Slider SetRange Error: minValue must be less than maxValue')
                return
        self.minValue = minValue
        self.maxValue = maxValue
        self.selections = self._createSelections()
        if refresh:
            self._Refresh(False)
        return True

    # GPo new
    def SetBookmark(self, value, bmtype=0, title='', refresh=True):
        # Type=0: bookmark
        if bmtype == 0:
            if value in self.bookmarks:
                return False
            self.bookmarks[value] = title
        elif bmtype in (1,2):
            if value in self.selectionsDict and (self.selectionsDict[value] == bmtype):
                del self.selectionsDict[value]
            else:
                self.selectionsDict[value] = bmtype
        else:
            return False

        if refresh:
            self.SetBookmarkHilighting(self.hilightBookmarks)
            self._Refresh(bmtype != 0)
        return True

    def RemoveBookmark(self, value, bmtype=0, refresh=True):
        try:
            if bmtype == 0:
                if value in self.bookmarks:
                    del self.bookmarks[value]
                else:
                    return False
            elif bmtype in (1,2):
                if value in self.selectionsDict:
                    del self.selectionsDict[value]
                else:
                    return False
            else:
                return False

            if refresh:
                self.SetBookmarkHilighting(self.hilightBookmarks)
                self._Refresh(bmtype != 0)
            return True
        except KeyError:
            return False

    def RemoveAllSelections(self, refresh=True):
        self.selectionsDict.clear()
        self.selections = None
        try:
            if isinstance(self.childSelectionsDict, dict):
                self.childSelectionsDict.clear()
        except:
            pass
        if not refresh:
            return
        self.SetBookmarkHilighting(self.hilightBookmarks)
        self._Refresh(False)

    def RemoveAllBookmarks(self, clearSelections=True):
        if self.bookmarks or (self.selections and clearSelections):
            if clearSelections:
                self.RemoveAllSelections(False)
            self.bookmarks.clear()
            self.SetBookmarkHilighting(self.hilightBookmarks)
            self._Refresh(False)
        return True

    def GetBookmarks(self, copy=False):
        if not copy:
            return self.bookmarks
        return dict(self.bookmarks)

    def GetSelections(self):
        if self.selections:
            return self.selections[:]
        return self.selections

    def ToggleSelectionMode(self, mode=0, fixmod=False):
        if not fixmod:
            if self.selmode == 0 or mode == 1:
                self.selmode = 1
            else:
                self.selmode = 0
        self._Refresh(False)

    def HitTestHandle(self, mousepos):
        rectHandle = self._getRectHandle()
        return rectHandle.Inside(mousepos)

    # GPo changed
    def HitTestBookmark(self, mousepos):
        x, y, w, h = self.GetRect()
        hitlist = []
        wT = self.wT
        for value in self.bookmarks.keys():
            pixelpos = int((value-self.startOffset) * (w-2*self.xo) / float(self.maxValue - self.minValue)) + self.xo
            rect = wx.Rect(pixelpos-wT/4, h-self.yo2, wT/2, wT/2)
            if rect.Inside(mousepos):
                hitlist.append((value, pixelpos))
                #~break # break also get the first bookmark
        #~if not hitlist and self.selections:
        if self.selections:
            for value, bmtype in self.selectionsDict.items():
                pixelpos = int((value-self.startOffset) * (w-2*self.xo) / float(self.maxValue - self.minValue)) + self.xo
                if bmtype == 1:
                    rect = wx.Rect(pixelpos-wT/2, h-self.yo2, wT/2+wT/4, wT/2)
                elif bmtype == 2:
                    rect = wx.Rect(pixelpos-wT/4, h-self.yo2, wT/2+wT/4, wT/2)
                else:
                    continue
                if rect.Inside(mousepos):
                    hitlist.append((value, pixelpos))
                    break
        if hitlist:
            if len(hitlist) == 1:
                return hitlist[0][0]
            else:
                return min([(abs(pixelpos-mousepos.x), value) for value, pixelpos in hitlist])[1]
        return None

    def HitTestSelectionButton(self, mousepos):
        if self.selmode == 1:
            x, y, w, h = self.GetRect()
            pixelpos = int(self.value* (w-2*self.xo) / float(self.maxValue - self.minValue))
            rectLeftButton = wx.Rect(pixelpos-self.wH/2+self.xo-self.wH, self.yo-3, self.wH, (h-self.yo-self.yo2+6)/1)
            rectRightButton = wx.Rect(pixelpos-self.wH/2+self.xo+self.wH, self.yo-3, self.wH, (h-self.yo-self.yo2+6)/1)
            bmtype = None
            if rectLeftButton.Inside(mousepos):
                bmtype = 1
            if rectRightButton.Inside(mousepos):
                bmtype = 2
            return bmtype

    def _HitTestHandleDeadZone(self, mousepos):
        rectHandle = self._getRectHandle()
        rectHandle.Inflate(self.wH + self.intPPI(2), 0) # GPo 2020, Inflate extends both sides (left, right) so 1x + 2 pixel is enough.
        return rectHandle.Inside(mousepos)

    # GPo new
    def HitTestSelection(self, mousepos):
        if not self.selections:
            return None
        w, h = self.GetSize()
        xB, yB, wB, hB = self.xo, self.yo, w-2*self.xo, h-self.yo-self.yo2
        hitlist = []
        for start, stop in self.selections:
            if start == stop:
                continue
            pixelstart = int((start-self.startOffset) * wB / float(self.maxValue - self.minValue)) + self.xo
            pixelstop = int((stop-self.startOffset) * wB / float(self.maxValue - self.minValue)) + self.xo
            rect = wx.Rect(pixelstart, yB, pixelstop - pixelstart, hB)
            if rect.Inside(mousepos):
                hitlist.append((start, stop))
                break
        if hitlist:
            return hitlist
        return None
"""
################################################################################

# GPo, WndProc functions

################################################################################
"""
if os.name == 'nt':
    CallWindowProc = ctypes.windll.user32.CallWindowProcW
    if platform.architecture()[0].startswith('64'):
        CallWindowProc.restype  = LONG
        CallWindowProc.argtypes = [
            LPVOID,
            HANDLE,
            LONG,
            WPARAM,
            LPARAM,
        ]

        SetWindowLong  = ctypes.windll.user32.SetWindowLongPtrW
        SetWindowLong.restype  = LPVOID
        SetWindowLong.argtypes = [
            HANDLE,
            ctypes.c_int,
            LPVOID,
        ]

        WndProcType = ctypes.WINFUNCTYPE(LONG, HANDLE, UINT, WPARAM, LPARAM)

    else:
        SetWindowLong  = ctypes.windll.user32.SetWindowLongW
        WndProcType = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_long, ctypes.c_int,
                ctypes.c_int, ctypes.c_int)

    class WndProcHookMixin(object):
        GWL_WNDPROC = -4
        WM_DESTROY  = 2

        def __init__(self, wnd_handle):
            self.__msg_dict = {}
            # We need to maintain a reference to the WndProcType wrapper
            # because ctypes doesn't
            self.__local_wnd_proc_wrapped = None
            # keep window handle
            self.__local_win_handle = wnd_handle
            # empty class vars
            self.__local_wnd_proc_wrapped = None
            self.__old_wnd_proc           = None

        def hook_wnd_proc(self):
            """Attach to OS Window message handler"""
            self.__local_wnd_proc_wrapped = WndProcType(self.local_wnd_proc)
            self.__old_wnd_proc = SetWindowLong(self.__local_win_handle,
                                            self.GWL_WNDPROC,
                                            self.__local_wnd_proc_wrapped)
        def unhook_wnd_proc(self):
            """Restore previous Window message handler"""
            if not self.__local_wnd_proc_wrapped:
                return
            SetWindowLong(self.__local_win_handle,
                            self.GWL_WNDPROC,
                            self.__old_wnd_proc)

            # Allow the ctypes wrapper to be garbage collected
            self.__local_wnd_proc_wrapped = None

        def add_msg_handler(self, message_number, handler):
            """Add custom handler function to specific OS message number"""
            self.__msg_dict[message_number] = handler

        def local_wnd_proc(self, hwnd, msg, w_param, l_param):
            """Call the handler if one exists"""
            if msg in self.__msg_dict:
                self.__msg_dict[msg](w_param, l_param)

            # Restore the old WndProc on Destroy.
            if msg == self.WM_DESTROY:
                self.unhook_wnd_proc()

            return CallWindowProc(self.__old_wnd_proc,
                                hwnd, msg, w_param, l_param)

    class COPYDATASTRUCT(ctypes.Structure):
        _fields_ = [
            ('dwData', LPARAM),
            ('cbData', DWORD),
            ('lpData', LPVOID)
        ]

    PCOPYDATASTRUCT = ctypes.POINTER(COPYDATASTRUCT)
else:
    class WndProcHookMixin(object):
        pass

# Main program window
class MainFrame(wxp.Frame, WndProcHookMixin):
    # Initialization functions
    def __init__(self, parent=None, id=wx.ID_ANY, title=global_vars.name, pos=wx.DefaultPosition, size=tuplePPI(700, 550), style=wx.DEFAULT_FRAME_STYLE):
        wxp.Frame.__init__(self, parent, id, pos=pos, size=size, style=style)
        self.name = title
        self.version = global_vars.version
        self.x86_64 = sys.maxsize > 2**32
        self.WinVersion = utils.get_winversion()
        self.calltipstemporal = False  # GPo, disable/enable calltip
        self.playing_video = False     # GPo, moved, HidePreviewWindow calls self.StopPlayback on createWindowElements
        self.Thread_List = []
        self.AppClosing = False
        self.previewWindowVisible = False
        self.SlidersContextMenu = None
        self.StatusBarContextMenu = None
        self.Lock = threading.RLock()
        self.displayFilter = False
        self.getPixelInfo = False
        self.blockEventSize = False
        self.ClipRefreshPainter = None       # GPo, clip thread progress event blocker
        #self.debug = False
        #
        #self.tb_icon = wx.lib.adv.TaskBarIcon()
        #icon = wx.Icon(sys.executable + ";0", wx.BITMAP_TYPE_ICO)
        #self.tb_icon.SetIcon(icon, "tooltip")
        #
        # GPo, init WndProc
        self.customHandler = 0
        if os.name == 'nt':
            self.w_param_zero = -50000  # Zero for w_param, use 50000 - 10 for -10
            #self.SendMessage = ctypes.windll.user32.SendMessageW
            #self.SendMessage.argtypes = HANDLE, UINT, WPARAM, LPARAM
            #self.SendMessage.restype = LPARAM
            self.PostMessage = ctypes.windll.user32.PostMessageW
            self.PostMessage.argtypes = HANDLE, UINT, WPARAM, LPARAM
            WndProcHookMixin.__init__(self, self.GetHandle())
            #  Received messages
            WM_CUSTOM_INFORM_HANDLER = 32770
            WM_CUSTOM_FRAME_NR = 32771
            WM_CUSTOM_SCROLL_STEP = 32772
            WM_CUSTOM_SCROLL = 32773
            WM_CUSTOM_RESET_ANTIALIAS = 32774
            WM_COPYDATA = 0x4A    # do not change
            # For PostMessages to customHandler
            self.AVSP_VID_SIZE = 32800
            # Add receivable messages to msg list
            WndProcHookMixin.add_msg_handler(self, WM_CUSTOM_INFORM_HANDLER, self.custom_inform_handler)
            WndProcHookMixin.add_msg_handler(self, WM_CUSTOM_FRAME_NR, self.custom_frame_nr)
            WndProcHookMixin.add_msg_handler(self, WM_CUSTOM_SCROLL_STEP, self.custom_scroll_step)
            WndProcHookMixin.add_msg_handler(self, WM_CUSTOM_SCROLL, self.custom_scroll)
            WndProcHookMixin.add_msg_handler(self, WM_CUSTOM_RESET_ANTIALIAS, self.custom_reset_antialias)
            WndProcHookMixin.add_msg_handler(self, WM_COPYDATA, self.custom_copy_data)
            # enable custom WndProc
            WndProcHookMixin.hook_wnd_proc(self)

        # Define program directories
        if hasattr(sys,'frozen'):
            self.programdir = os.path.dirname(sys.executable)
        else:
            self.programdir = os.path.abspath(os.path.dirname(sys.argv[0]))
        if type(self.programdir) != unicode:
            self.programdir = unicode(self.programdir, encoding)
        self.initialworkdir = os.getcwdu()
        self.toolsfolder = os.path.join(self.programdir, 'tools')
        sys.path.insert(0, self.toolsfolder)
        self.macrofolder = os.path.join(self.programdir, 'macros')
        self.helpdir = os.path.join(self.programdir, 'help')
        # Get persistent options
        self.optionsfilename = os.path.join(self.programdir, 'options.dat')
        self.filterdbfilename = os.path.join(self.programdir, 'filterdb.dat')
        self.filterdbremote_plugins = r'https://raw.github.com/wiki/AvsPmod/AvsPmod/Plugin-functions.md'
        self.filterdbremote_scripts = r'https://raw.github.com/wiki/AvsPmod/AvsPmod/Script-functions.md'
        self.lastSessionFilename = os.path.join(self.programdir, '_last_session_.ses')
        self.macrosfilename = os.path.join(self.programdir, 'macros', 'macros.dat')
        self.optionsPreviewFiltersFilename = os.path.join(self.programdir, 'pfilter.dat')
        self.optionsFilters = None
        self.loaderror = []
        self.getOptionsDict()

        self.SetPaths()
        self.LoadAvisynth()
        self.IdleCall = []      # old one, allows multiple entries of the same function
        self.IdleCallDict = {}  # GPo, if you use the same key name for a function then each func does only fires once
        self.defineFilterInfo()
        self.optionsPreviewFilters = {}
        self.readFrameProps = False
        self.resizeFilter = (False, self.options['resizefilter'], 1, True) # enabled, filter, zoom, fitHeight
        self.mintextlines = self.options['mintextlines']
        self.mainSplitter_SetSashPos = None
        self.SplitClipCtrl = SplitClipCtrl(self)

        if os.path.isfile(self.macrosfilename):
            try:
                with open(self.macrosfilename, 'rb') as f:
                    self.optionsMacros = cPickle.load(f)
            except:
                self.loaderror.append(os.path.basename(self.macrosfilename))
                shutil.copy2(self.macrosfilename,
                             os.path.splitext(self.macrosfilename)[0] + '.BAD')
                self.optionsMacros = {}
        else:
            self.optionsMacros = {}
        if os.path.isfile(self.optionsPreviewFiltersFilename):
            try:
                with open(self.optionsPreviewFiltersFilename, 'rb') as f:
                    self.optionsPreviewFilters = cPickle.load(f)
            except:
                self.loaderror.append(os.path.basename(self.optionsPreviewFiltersFilename))
                shutil.copy2(self.optionsPreviewFiltersFilename,
                             os.path.splitext(self.optionsPreviewFiltersFilename)[0] + '.BAD')

        if not 'previewfilters' in self.optionsPreviewFilters:
            self.optionsPreviewFilters['previewfilters'] = {}

        # Set DPI Awareness and ppi_factor
        self.ppi_factor = 1.0
        DPI = dpi.DPI()
        self.ppi_factor = DPI.GetPPIFactor()
        self.setPPIFactor()

        # all dialogs fit inside display and greate scrollbars if needed
        wx.Dialog.EnableLayoutAdaptation(True)

        ### property window and parent options
        self.propWindowParent = self.options['propwindowparent'] # GPo, 0=propWnd, 1=sliderWnd top, 2=sliderWnd bottom
        try:
            sw, sh = wx.ScreenDC().GetSize()
            x,y,w,h = self.options['propwindowrect']
            _pos = (min(max(x,-5),sw-60), min(max(y,0),sh-50))
            w = max(w, 80)
            h = max(h, 50)
            _size = (min(w,sw),min(h,sh))
        except:
            _pos = wx.DefaultPosition
            _size = tuplePPI(200,260)
        self.propWindow = PropWindow(self, pos=_pos, size=_size)
        ###
        self.scrapWindow = ScrapWindow(self)

        # load translation file
        self.translations_dir = os.path.join(self.programdir, 'translations')
        if self.options['lang'] != 'eng':
            sys.path.insert(0, self.translations_dir)
            sys.dont_write_bytecode = True
            try:
                translation = __import__('translation_' + self.options['lang'])
            except ImportError:
                translation = None
            else:
                try:
                    global messages
                    messages = translation.messages
                    helpdir = '_'.join((self.helpdir, self.options['lang']))
                    if os.path.isdir(helpdir):
                        self.helpdir = helpdir
                except AttributeError:
                    pass
            finally:
                sys.dont_write_bytecode = False

        self.colour_data = wxp.ColourData() # needed before the following
        self.optionsDlgInfo = self.getOptionsDlgInfo()

        # GPo 2020, set port and name for wxp.SingleInstanceApp
        # make a difference between x64, x32
        # you must also change the code in wxp.py
        xSys = 'x64' if self.x86_64 else 'x32'
        self.port = 50009 if xSys == 'x64' else 50008
        self.instance = wx.SingleInstanceChecker(title+xSys+wx.GetUserId())

        self.boolSingleInstance = self.options.setdefault('singleinstance', False)
        if self.boolSingleInstance:
            if self.instance.IsAnotherRunning():
                # Send data to the main instance via socket
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect(('localhost', self.port))
                pickledstring = StringIO()
                cPickle.dump(sys.argv[1:],pickledstring)
                sock.sendall(pickledstring.getvalue())
                response = sock.recv(8192)
                self.Destroy()
                return None
            else:
                def OnArgs(evt):
                    self.ProcessArguments(evt.data)
                self.Bind(wxp.EVT_POST_ARGS, OnArgs)
                # Start socket server (in a separate thread) to receive arguments from other instances
                self.argsPosterThread = wxp.ArgsPosterThread(self)
                self.argsPosterThread.Start()
        else:
            if self.instance.IsAnotherRunning():
                self.options['exitstatus'] = 0

        # Program size and position options
        self.separatevideowindow = self.options['separatevideowindow']
        dimensions = self.options.get('dimensions')
        if dimensions is not None:# and dimensions[0] > 0 and dimensions[1] > 0:
            size = wx.ScreenDC().GetSize()
            dimensions = (
                min(max(dimensions[0], -5), size[0]-100), min(max(dimensions[1], 0), size[1]-100),
                dimensions[2], dimensions[3]
                )
            self.SetDimensions(*dimensions)

        if self.options['alwaysontop']:
            style = wx.DEFAULT_FRAME_STYLE|wx.STAY_ON_TOP
        else:
            style = wx.DEFAULT_FRAME_STYLE
        self.SetWindowStyle(style)

        # Drag-and-drop target for main window
        class MainFrameDropTarget(wx.PyDropTarget):
            def __init__(self, win):
                wx.PyDropTarget.__init__(self)
                self.win = win
                self.textdata = wx.TextDataObject()
                self.filedata = wx.FileDataObject()
                self.data = wx.DataObjectComposite()
                self.data.Add(self.textdata)
                self.data.Add(self.filedata)
                self.SetDataObject(self.data)

            def OnData(self, x, y, default):
                self.GetData()
                if self.textdata.GetTextLength() > 1:
                    text = self.textdata.GetText()
                    self.textdata.SetText('')
                    if text == self.win.currentScript.GetSelectedText():
                        self.win.NewTab()
                    else:
                        self.win.NewTab(text=text)
                else:
                    for filename in self.filedata.GetFilenames():
                        self.win.OpenFile(filename=filename, hidePreview=True)
                return False

        class ScriptDropTarget(wx.DropTarget):
            def __init__(self, win, app):
                wx.PyDropTarget.__init__(self)
                self.win = win
                self.app = app
                self.textdata = wx.TextDataObject()
                self.filedata = wx.FileDataObject()
                self.data = wx.DataObjectComposite()
                self.data.Add(self.textdata)
                self.data.Add(self.filedata)
                self.SetDataObject(self.data)
                self.oldPos = None

            def OnLeave(self):
                self.win.SetCaretWidth(1)

            def OnDragOver(self, x, y, default):
                point = wx.Point(x,y)
                textPos = self.win.PositionFromPoint(point)
                textPoint = self.win.PointFromPosition(textPos)
                if textPos != self.oldPos:
                    self.win.SetCaretWidth(0)
                    self.win.Refresh()
                dc = wx.ClientDC(self.win)
                dc.SetPen(wx.Pen('black', 1))
                dc.DrawLine(
                    textPoint.x,
                    textPoint.y,
                    textPoint.x,
                    textPoint.y + self.win.TextHeight(0)
                )
                self.oldPos = textPos
                return default#wx.DragMove

            def OnData(self, x, y, default):
                script = self.win
                script.SetCaretWidth(1)
                self.GetData()
                if self.textdata.GetTextLength() > 1:
                    # Get the clipboard data
                    text = self.textdata.GetText()
                    self.textdata.SetText('')
                    # Get the current selection positions
                    posA, posB = script.GetSelection()
                    # Go to the current mouse position
                    point = wx.Point(x,y)
                    textPos = script.PositionFromPoint(point)
                    script.GotoPos(textPos)
                    # Erase the old selection if required
                    if default == wx.DragMove:
                        script.SetTargetStart(posA)
                        script.SetTargetEnd(posB)
                        script.ReplaceTarget('')
                    # Insert the clipboard text in the current position
                    curPos = script.GetCurrentPos()
                    script.InsertText(curPos, text)
                    script.SetSelection(curPos, curPos+len(text))
                else:
                    # Go to the current mouse position
                    point = wx.Point(x,y)
                    textPos = script.PositionFromPoint(point)
                    script.GotoPos(textPos)
                    filenames = self.filedata.GetFilenames()
                    if len(filenames) == 1 and os.path.splitext(filenames[0])[1].lower() not in ('.avs', '.avsi', '.vpy', '.ses'):
                        # Insert the single filename as a source
                        self.app.InsertSource(filenames[0])
                    else:
                        # Open each filename as a script
                        hidePreview = len(filenames) > 1
                        for filename in self.filedata.GetFilenames():
                            self.app.OpenFile(filename=filename, hidePreview=hidePreview)
                return True

        self.SetDropTarget(MainFrameDropTarget(self))
        self.scriptDropTarget = ScriptDropTarget

        # Internal class variables
        self.currentframenum = None
        self.zoomfactor = 1
        self.zoomwindow = False
        self.zoomwindowfit = False
        self.zoomwindowfill = False
        self.extended_move = False   # GPo
        self.timelineRange = 0       # GPo, last saved timeline range mod 2
        self.timelineAutoScroll = self.options['timelineautoscroll'] # scroll the timeline range if needed
        self.timelineAutoReset = self.options['timelineautoreset']
        self.dummyObject = None      # GPo used as multi var
        # Create all the program's controls and dialogs
        self.blockStatusbar = False  # GPo 2020
        self.NewFileName = _('New File')

        self.titleDict = {}
        self.recentframes = []
        self.bmpVideo = None
        self.createWindowElements()
        if not __debug__:
            sys.stdout = self.scrapWindow
        if not self.separatevideowindow:
            cropdialogparent = self
        else:
            cropdialogparent = self.videoDialog
        self.cropDialog = self.createCropDialog(cropdialogparent)
        self.trimDialog = self.createTrimDialog(cropdialogparent)
        self.findDialog = wxp.QuickFindDialog(self.scriptNotebook)
        self.replaceDialog = wxp.FindReplaceDialog(self.scriptNotebook)

        # Internal class variables
        self.UseNewFrameThread = self.options['usenewframethread']  # GPo new, test with one background frame thread for each script
        self.progressDelayTime = self.options['progressdelaytime']  # GPo, waiting before showing the thread progress dialog
        self.splitView = False                             # GPo
        self.splitView_next = True                         # GPo
        self.splitView_freeze = False                      # GPo, freeze frame number
        self.splitView_nextScript = None                   # GPo 2023
        self.splitViewEx = self.options['splitviewex']     # GPo 2023
        self.splitViewEx_posx = None                       # GPo 2023
        self.splitViewEx_snapped = False                   # GPo 2023
        self.extended_width = 0                            # GPo 2020 used for extended_move and splitView
        self.splitView_lastShown = (None, None, None, None) # frameNr, AVI.DisplayWidth, zoomfactor, videoWnd.GetViewStart
        self.snapShotIdx = 0         # GPo
        self.bellAtBookmark = False  # GPo
        self.previewFilterDict = {}  # GPo 2020
        self.zoom_antialias = self.options['zoom_antialias']  # GPo
        #self.ShowPFilterTime = False # Show Preview Filter time in the slider window
        self.KeyUpVideoWndow = True
        self.optionsLastPageIndex = 0 # GPo, store/restore the last OptionsDlg page
        self.lastcrop = ""
        self.oldWidth = 0
        self.oldHeight = 0
        self.oldFramecount = None
        self.startupframe = 0
        self.oldPreviewtxt = None
        self.oldLastSplitVideoPos = None
        self.oldLastSplitSliderPos = None
        self.oldSliderWindowShown = None
        self.oldDisplayVideoSize = (None, None)
        self.oldBoolSliders = None
        self.slidersShowExclusionFilters = False
        self.options['selectedmatrix'] = self.options['defaultmatrix'].split(',')
        self.xo = self.yo = intPPI(5)
        self.mouseDownXY = None
        self.saveViewPos = 0     # GPo, keep/restore zoom sttings on tab change (0=off, 1=only pos, 2=pos and zoom)
        self.oldTabIndex =  0    # GPo, save the last page index for toggle
        self.tabChangeLoadBookmarks = self.options['tabsbookmarksfromscript']
        self.OnMenuTabChangeLoadBookmarks(None) # enable/disable 'Clear tab bookmarks' menu
        self.play_speed_factor = 1.0
        self.play_drop = False
        self.UseAviThread = self.options['avithread'] # GPo, use thread for load/unload clip, read frame
        self.sliderOpenString = '[<'
        self.sliderCloseString = '>]'
        self.fc = None
        self.regexp = re.compile(r'\%s.*?\%s' % (self.sliderOpenString, self.sliderCloseString))
        self.cropValues = {
            'left': 0,
            'top': 0,
            '-right': 0,
            '-bottom': 0,
        }
        self.oldCropValues = self.cropValues
        self.middleDownScript = False
        self.refreshAVI = True
        self.lastshownframe = None
        self.paintedframe = None
        self.oldlinenum = None
        self.dlgAvs2avi = None
        self.macroVars = {'last': None}
        self.imageFormats = {
            '.bmp': (_('Windows Bitmap') + ' (*.bmp)', wx.BITMAP_TYPE_BMP),
            '.gif': (_('Animation') + ' (*.gif)', wx.BITMAP_TYPE_GIF),
            '.jpg': (_('JPEG') + ' (*.jpg)', wx.BITMAP_TYPE_JPEG),
            '.pcx': (_('Zsoft Paintbrush') + ' (*.pcx)', wx.BITMAP_TYPE_PCX),
            '.png': (_('Portable Network Graphics') + ' (*.png)', wx.BITMAP_TYPE_PNG),
            '.pnm': (_('Netpbm') + ' (*.pnm)', wx.BITMAP_TYPE_PNM),
            '.tif': (_('Tagged Image File') + ' (*.tif)', wx.BITMAP_TYPE_TIF),
            '.xpm': (_('ASCII Text Array') + ' (*.xpm)', wx.BITMAP_TYPE_XPM),
            '.ico': (_('Windows Icon') + ' (*.ico)', wx.BITMAP_TYPE_ICO),
            '.cur': (_('Windows Cursor') + ' (*.cur)', wx.BITMAP_TYPE_CUR),
        }
        self.markFrameInOut = self.options['trimmarkframes']
        if self.options['trimreversechoice'] == 0:
            self.invertSelection = False
        else:
            self.invertSelection = True
        if self.options['videostatusbarinfo'] == None:
            sep = '\t\t' if os.name == 'nt' else '\\T\\T'
            """
            self.videoStatusBarInfo = (_('Frame') + ' %F / %FC %TR  -  (%T)  %BM      %POS  %HEX '
                                       '{sep} %Z %Wx%H (%AR)  -  %FR ' + _('fps') + '  -  %CS').format(sep=sep)
            """
            self.videoStatusBarInfo = (_('Frame') + ' %F / %FC %TR -  (%T)  %BM      %POS  %HEX '
                '{sep} %Z %Wx%H (%AR) - %FR fps - %FB %PS - %CS (%BITbit) (Audio %AUBbit, %AURHz) %DYR').format(sep=sep)
        else:
            self.videoStatusBarInfo = self.options['videostatusbarinfo']
        self.videoStatusBarInfoParsed, self.showVideoPixelInfo = self.ParseVideoStatusBarInfo(self.videoStatusBarInfo)
        self.foldAllSliders = True
        self.interlaced = self.swapuv = self.bit_depth = False
        self.flip = []
        self.titleEntry = None
        self.colour_data.FromString(self.options['colourdata'])
        # Events
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.OnNotebookPageChanged)
        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGING, self.OnNotebookPageChanging)
        #leave it, if thread progress is shown LayoutVideoWindows doesn't work if self Iconized and no event skip called
        def OnIconize(event):
            self.blockEventSize = True
            if self.IsIconized():
                self.StopPlayback()
                if self.propWindow.IsShown():
                    self.propWindow.Hide()
            else:
                if self.readFrameProps and self.propWindowParent == 0:
                    self.propWindow.Show()
                self.mainSplitter.UpdateSize()
                self.videoSplitter.UpdateSize()
                try:
                    #wx.GetApp().SafeYieldFor(self.videoWindow, wx.wxEVT_PAINT)
                    wx.GetApp().SafeYieldFor(self, wx.wxEVT_PAINT)
                except:
                    pass
            event.Skip()
        self.Bind(wx.EVT_ICONIZE, OnIconize)

        """
        def OnMaximaze(event):
            #if self.currentScript.GetSize()[1] > 4:
                #wx.CallAfter(self.SetMinimumScriptPaneSize)
            print('On Maximaze')
            event.Skip()
        self.Bind(wx.EVT_MAXIMIZE, OnMaximaze)

        """
        """
        def OnShow(event):
            if self.readFrameProps and self.propWindowParent == 0:
                self.propWindow.Show()
            if self.mainSplitter.IsSplit():
                self.mainSplitter.UpdateSize()
                self.videoSplitter.UpdateSize()
            event.Skip()
        self.Bind(wx.EVT_SHOW, OnShow)
        """

        """
        def OnModalDialogClosed(event):
            print('Modal Close')
            event.Skip()
        self.Bind(wx.EVT_WINDOW_MODAL_DIALOG_CLOSED, OnModalDialogClosed)
        """

        if not self.separatevideowindow:
            def OnSize(event):
                if event.GetEventType() != wx.EVT_CLOSE.typeId:
                    if self.titleEntry:
                        self.scriptNotebook.SetFocus()
                # It's bad for switchin fullsize mode on playback
                if not self.blockEventSize and not self.ClipRefreshPainter:
                    if self.previewWindowVisible:
                        script = self.currentScript
                        size = script.GetSize()[self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL]
                        self.mainSplitter_SetSashPos = None if size > 4 else 1
                        if self.zoomwindow or self.zoomfactor != 1:
                            func = (self.ShowVideoFrame, tuple(), {'focus': False})
                            if not func in self.IdleCall:
                                if self.options['zoom_antialias']:
                                    self.zoom_antialias = False
                                    # first Reset, IdleCall pops from last to first
                                    self.IdleCall.append((self.ResetZoomAntialias, tuple(), {}))
                                self.IdleCall.append(func)
                        elif script.resizeFilter[0] and script.resizeFilter[2] == 1:
                            func = (self.ShowVideoFrame_checkResizeFilter, tuple(), {'script': script})
                            if not func in self.IdleCall:
                                self.IdleCall.append(func)

                    # set minpanesize again if size changed ( maximaze, restore, fullscreen)
                    if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
                        func = (self.SetMinimumScriptPaneSize, tuple(), {'mlines': self.mintextlines})
                        if not func in self.IdleCall:
                            self.IdleCall.append(func)

                self.blockEventSize = False
                event.Skip()
            self.Bind(wx.EVT_SIZE, OnSize) # Size is also called on Maximaze and Restore
        else:
            def OnSize(event): # after size
                if self.previewWindowVisible and event.GetEventType() != wx.EVT_CLOSE.typeId:
                    if not self.blockEventSize and not self.ClipRefreshPainter:
                        if not self.videoDialog.IsMaximized() and not self.videoDialog.IsFullScreen():
                            self.options['dimensions2'] = (self.videoDialog.GetRect())
                        script = self.currentScript
                        if self.zoomwindow or self.zoomfactor != 1:
                            func = (self.ShowVideoFrame, tuple(), {'focus': False})
                            if not func in self.IdleCall:
                                if self.options['zoom_antialias']:
                                    self.zoom_antialias = False
                                    # first Reset, IdleCall pops from last to first
                                    self.IdleCall.append((self.ResetZoomAntialias, tuple(), {}))
                                self.IdleCall.append(func)
                        elif script.resizeFilter[0] and script.resizeFilter[2] == 1:
                            func = (self.ShowVideoFrame_checkResizeFilter, tuple(), {'script': script, 'forceLayout': False})
                            if not func in self.IdleCall:
                                self.IdleCall.append(func)
                    self.blockEventSize = False
                event.Skip()
            self.videoDialog.Bind(wx.EVT_SIZE, OnSize)

        # Command line arguments
        self.UpdateRecentFilesList()
        self.reloadList = []
        self.lastClosed = None
        if self.options['exitstatus'] == 1:
            self.IdleCall.append((wx.MessageBox, (_('A crash detected at the last running!'), \
                                   _('Warning'), wx.OK|wx.ICON_EXCLAMATION, self), {}))

        # backup session files
        if self.options['sessionbackupcount'] > 0 and \
            os.path.isfile(os.path.splitext(self.lastSessionFilename)[0] + 'backup.ses'):
                self.BackupSessionEx(sourcesession=os.path.splitext(self.lastSessionFilename)[0] + 'backup.ses')
        if os.path.isfile(self.lastSessionFilename):
            shutil.copy2(self.lastSessionFilename, os.path.splitext(self.lastSessionFilename)[0] + 'backup.ses')
        saveDir = os.path.join(self.programdir, 'SessionBackups')
        fname = os.path.join(saveDir, '_session_backup_')
        files = glob.glob(fname + '*.ses')
        files.sort()
        while len(files) > self.options['sessionbackupcount']:
            try:
                os.remove(files[0])
            except:
                pass
            del files[0]

        use_last_preview_placement = True
        if (self.options['exitstatus'] == 2) or ((self.options['exitstatus'] or self.options['startupsession'] and
                (self.options['alwaysloadstartupsession'] or len(sys.argv) <= 1 or not self.options['promptexitsave']))
            and os.path.isfile(self.lastSessionFilename)):
                if self.LoadSession(self.lastSessionFilename, saverecentdir=False, resize=False, backup=False, startup=True):
                    use_last_preview_placement = False
                else:
                    self.loaderror.append(os.path.basename(self.lastSessionFilename))
                    shutil.copy2(self.lastSessionFilename, os.path.splitext(self.lastSessionFilename)[0] + '.BAD')
        if use_last_preview_placement and self.options['last_preview_placement'] != self.mainSplitter.GetSplitMode():
            self.TogglePreviewPlacement()
        if self.options['exitstatus'] != 1:
            self.options['exitstatus'] = 1
            f = open(self.optionsfilename, mode='wb')
            cPickle.dump(self.options, f, protocol=0)
            f.close()

        if len(sys.argv) > 1:
            self.ProcessArguments(sys.argv[1:])

        # Misc
        self.UpdateProgramTitle()
        self.SetIcon(AvsP_icon.getIcon())
        self.SetExternalToolMenuLabel()
        for slider in self.GetVideoSliderList():
            slider.numDivisor = self.options['timelinenumdivisor']

        if self.separatevideowindow:
            def OnActivate(event):
                if event.GetActive():
                    self.currentScript.SetFocus()
                event.Skip()
            self.Bind(wx.EVT_ACTIVATE, OnActivate)

        def OnMove(event):
            self.currentScript.UpdateCalltip()
            event.Skip()
        self.Bind(wx.EVT_MOVE, OnMove)

        def OnIdle(event=None):
            if self.IdleCallDict: # GPo, fire from first to last entry
                try:
                    key = next(iter(self.IdleCallDict))
                    f = self.IdleCallDict.pop(key)
                    f()
                except:
                    self.IdleCallDict.clear()

            if self.IdleCall:
                func, args, kwargs = self.IdleCall.pop() # GPo, fire from last to first entry
                try:
                    func(*args, **kwargs)
                except:
                    pass
        self.Bind(wx.EVT_IDLE, OnIdle)

        # Print options
        self.print_data = wx.PageSetupDialogData()
        self.print_data.SetMarginTopLeft(wx.Point(15, 15))
        self.print_data.SetMarginBottomRight(wx.Point(15, 15))
        self.print_header = True
        self.print_wrap = True
        self.print_zoom = False

        # Other options
        self.mouse_wheel_rotation = 0
        self.GetStatusBar().SetDoubleBuffered(True)  # GPo
        #wx.ToolTip_SetDelay(2000)
        wx.ToolTip_SetAutoPop(30000)

        # Display the program
        if self.separatevideowindow:
            self.videoStatusBar.SetDoubleBuffered(True) # GPo

        vidmenu = self.videoWindow.contextMenu
        menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Zoom'))).GetSubMenu()
        menuItem = menu.FindItemByPosition(self.options['zoomindex'])
        if menuItem is not None:
            self.OnMenuVideoZoom(None, menuItem=menuItem, show=False)

        if self.options['use_customvideobackground']:
            self.OnMenuVideoBackgroundColor(color=self.options['videobackground'])

        # GPo 2020, scrptWindow and videoWindow binds on create, videoControls also on create but to another func
        # exclude Statusbar, it's binding with videoControls, exclude all scriptNotebook children
        self.BindObjMouseAux(self, self.GetStatusBar().GetHandle())
        self.BindObjMouseAux(self.scriptNotebook, -3)

        if self.options.get('maximized'):
            self.Maximize(True)
        if self.options.get('maximized2') and self.separatevideowindow:
            self.videoDialog.Maximize(True)

        self.Show()
        self.Update()
        self.Raise()
        self.SetMinimumScriptPaneSize()

        index = self.scriptNotebook.GetSelection()
        self.ReloadModifiedScripts()
        self.scriptNotebook.SetSelection(index)
        self.currentScript.SetFocus()
        # set the script selections
        if self.tabChangeLoadBookmarks:
            self.SetSelectionsDict(self.currentScript.selections)

        if len(self.optionsPreviewFilters['previewfilters']) > 0:
            try:
                self.UpdatePreviewFilterMenu(self.optionsPreviewFilters['previewfilters'], isRestoreMenu=True)
            except:
                try: # new Version
                    for key in self.optionsPreviewFilters['previewfilters'].keys():
                        ident, arg = self.optionsPreviewFilters['previewfilters'][key]
                        self.optionsPreviewFilters['previewfilters'][key] = (ident, arg, (0,0))
                    self.UpdatePreviewFilterMenu(self.optionsPreviewFilters['previewfilters'], isRestoreMenu=True)
                except:
                    self.optionsPreviewFilters['previewfilters'] = {}

        # Warn if option files are damaged
        if self.loaderror:
            #print>>sys.stderr, '{0}: {1}'.format(_('Error'), _('Damaged {0}. Using default settings.').format(', '.join(self.loaderror)))
            wx.SafeShowMessage(' '.join((self.name, self.version)),'{0}: {1}'.format(_('Error'), _('Damaged {0}. Using default settings.').format(', '.join(self.loaderror))))
        # Update the translation file if necessary
        for path, lang in self.getTranslations(return_paths=True):
            if not os.stat(path).st_size:
                i18n.UpdateTranslationFile(self.translations_dir, lang, self.version)
        if self.options['lang'] != 'eng':
            if translation:
                try:
                    try:
                        translation_version = translation.version
                    except AttributeError:
                        translation_version = None
                    if translation_version != self.version:
                        if i18n.UpdateTranslationFile(os.path.join(self.translations_dir),
                                                      self.options['lang'], self.version):
                            wx.MessageBox(_('%s translation file updated with new messages to translate')
                                            % i18n.display_name(self.options['lang']), _('Translation updated'))
                        else:
                            wx.MessageBox(_('%s translation file updated.  No new messages to translate.')
                                            % i18n.display_name(self.options['lang']), _('Translation updated'))
                except NameError as err:
                    pass
            else:
                wx.MessageBox(_("%s language couldn't be loaded") % i18n.display_name(self.options['lang']),
                              _('Error'), style=wx.OK|wx.ICON_ERROR)
                self.options['lang'] = 'eng'

        # Timer for saving the session periodically
        class BackupTimer(wx.Timer):
            def __init__(self, parent):
                wx.Timer.__init__(self)
                self.parent = parent
            def Notify(self):
                self.parent.SaveSession(self.parent.lastSessionFilename, saverecentdir=False, previewvisible=False)
        self.backupTimer = BackupTimer(self)
        if self.options['periodicbackup']:
            self.backupTimer.Start(self.options['periodicbackup'] * 60000)

    # GPo 2020, block SetVideoStatusText for a certain period
    def StatusbarTimer_Start(self, ms=3000, txt='', bellcount=0):
        def OnTimerEnd():
            self.blockStatusbar = False
        if self.blockStatusbar:
            wx.CallLater(1000, self.StatusbarTimer_Start, ms, txt, bellcount)
            return
        self.blockStatusbar = True
        if txt:
            self.GetStatusBar().SetStatusText(txt)
        if bellcount > 1:
            for i in xrange(bellcount):
                wx.Bell()
                time.sleep(0.4)
        elif bellcount > 0:
            wx.Bell()
        wx.CallLater(ms, OnTimerEnd)

#### GPo 2018 WndProc messages

    def custom_frame_nr(self, w_param, l_param):
        if w_param > 0 and not self.zoomwindowfit:
          xy = (LOWORD(w_param), HIWORD(w_param))
        else:
            xy = None
        # -1, -2 FrameStep
        if l_param == -1:
            l_param = self.currentframenum + 1
        elif l_param == -2:
            l_param = self.currentframenum - 1
        self.IdleCall.append((self.ShowVideoFrame, (l_param,), {'scroll': xy, 'wrap': False}))

    def custom_scroll(self, w_param, l_param):
        xy = (w_param, l_param)
        if self.previewWindowVisible:
            if not self.zoomwindowfit:
                if self.zoom_antialias and (self.zoomfactor != 1 or self.zoomwindowfill):
                    self.zoom_antialias = False # for reset must call custom_reset_antialias
                self.videoWindow.Scroll(xy)
        elif not self.zoomwindowfit:
            self.IdleCall.append((self.ShowVideoFrame, {'scroll': xy}, {}))

    # for posting x us positive w_param_zero value + youre x value
    def custom_scroll_step(self, w_param, l_param):
        x, y = self.videoWindow.GetViewStart()
        x += self.w_param_zero + w_param
        y += l_param

        if self.previewWindowVisible:
            if not self.zoomwindowfit:
                if self.zoom_antialias and (self.zoomfactor != 1 or self.zoomwindowfill):
                    self.zoom_antialias = False # for reset must call custom_reset_antialias
                self.videoWindow.Scroll(x, y)
        elif not self.zoomwindowfit:
            wx.CallAfter(self.ShowVideoFrame, forceLayout=True, scroll=(x,y))

    def custom_reset_antialias(self, w_param, l_param):
        if w_param == 0:
          self.zoom_antialias = False
          self.videoWindow.Refresh()
          self.videoWindow.Update()
        else:
            self.IdleCall.append((self.OnAfterScrollVideoWindow, tuple(), {}))

    def custom_copy_data(self, w_param, l_param):
        pCDS = ctypes.cast(l_param, PCOPYDATASTRUCT)
        ide = pCDS.contents.dwData
        if ide == 1:   # find and select tab
            s = ctypes.wstring_at(pCDS.contents.lpData)
            self.FindTabByName(s)
        elif ide == 2: # open file
            s = ctypes.wstring_at(pCDS.contents.lpData)
            if os.path.isfile(s):
                self.OpenFile(s)
            else:
                wx.Bell()
        elif ide == 3: # find and release tab video memory
            s = ctypes.wstring_at(pCDS.contents.lpData)
            idx = self.FindTabByName(s, False)
            if idx > -1:
                script = self.scriptNotebook.GetPage(idx)
                if self.AviThread_Running(script):
                    return 0
                if idx == self.scriptNotebook.GetSelection():
                    self.HidePreviewWindow()
                    self.SetVideoStatusText()
                self.AviFree(script, updateTabname=True)
        elif ide == 4: # find and close tab
            s = ctypes.wstring_at(pCDS.contents.lpData)
            idx = self.FindTabByName(s, False)
            if idx > -1:
                if self.previewWindowVisible:
                    self.HidePreviewWindow()
                wx.CallAfter(self.CloseTab, idx)
        elif ide == 5:  # find only the tab
            s = ctypes.wstring_at(pCDS.contents.lpData)
            return self.FindTabByName(s, False)
        elif ide == 6:  # find bookmark and show frame if found
            nr = ctypes.wstring_at(pCDS.contents.lpData)
            if not nr or not nr.isdigit():
                return -1
            bookmarks = self.GetBookmarkFrameList()
            if bookmarks and int(nr) in bookmarks:
                wx.CallAfter(self.ShowVideoFrame, int(nr), forceCursor=True)
            else: return -1

        elif ide > 100:  # Addr of sender data, return it to sender
            s = ctypes.wstring_at(pCDS.contents.lpData)
            if self.FindTabByName(s) > -1:
               self.PostMessage(w_param, 33000, ide, int(self.GetHandle()))

        return 1

    def custom_inform_handler(self, w_param, l_param):
        self.customHandler = w_param
        if w_param == 0: # disable PostMessages
            return
        pw, pl = (-1, -1)
        if l_param == 32800:
            if self.currentScript.AVI:
                z = self.zoomfactor if not self.zoomwindow else 1
                pw = int(self.currentScript.AVI.DisplayWidth * z)
                pl = int(self.currentScript.AVI.DisplayHeight * z)
        elif l_param == 32801:
            pw, pl = self.videoWindow.GetSize()
        elif l_param == 32802:
            pw, pl = self.videoWindow.GetVirtualSize()
        elif l_param == 32803:
            if self.currentScript.AVI:
                pw, pl = (self.currentframenum,  self.currentScript.AVI.Framecount)
        elif l_param == 32804:
            if not self.zoomwindow:
                pw, pl = self.videoWindow.GetViewStart()

        if pw > -1 and pl > -1:
            self.PostMessage(w_param, l_param, pw, pl)
### end GPo

    def BindObjMouseAux(self, obj, excludeChildren = -2):
        if wx.VERSION >= (2,9):
            obj.Bind(wx.EVT_MOUSE_AUX1_DOWN, self.OnMouseAux1Down)
            obj.Bind(wx.EVT_MOUSE_AUX2_DOWN, self.OnMouseAux2Down)
            if excludeChildren == -3:
                return
            for child in obj.GetChildren():
                if child.GetHandle() == excludeChildren:
                    continue
                child.Bind(wx.EVT_MOUSE_AUX1_DOWN, self.OnMouseAux1Down)
                child.Bind(wx.EVT_MOUSE_AUX2_DOWN, self.OnMouseAux2Down)

    def ProcessArguments(self, args):
        if args:
            first = True
            self.HidePreviewWindow()
            for arg in args:
                arg = arg.decode(sys.stdin.encoding or encoding)
                if os.path.isfile(arg):
                    if os.path.dirname(arg) == '':
                        arg = os.path.join(self.initialworkdir, arg)
                    self.OpenFile(filename=arg, hidePreview=True) # BUG: sys.argv gives back short filenames only?!!
                    if not os.path.splitext(arg)[1].lower() in ('.py', '.pys'):    # GPo 2018
                        self.currentScript.GotoPos(0)
                        self.currentScript.EnsureCaretVisible()
#### GPo 2018, execute macro, process arguments
                        if first:
                            first = False
                            if os.path.splitext(arg)[1].lower() == '.avs':
                                if os.path.isfile(os.path.join(self.macrofolder, 'startup_avs.pys')):
                                    wx.CallAfter(self.Update)
                                    wx.CallAfter(self.ExecuteMacro, os.path.join(self.macrofolder, 'startup_avs.pys'))

                            elif os.path.isfile(os.path.join(self.macrofolder, 'startup.pys')):
                                wx.CallAfter(self.Update)
                                wx.CallAfter(self.ExecuteMacro, os.path.join(self.macrofolder, 'startup.pys'))
                elif len(arg) > 3:
                    if arg[:3] == '-em':
                        wx.CallAfter(self.Update)
                        wx.CallAfter(self.ExecuteMacro, arg[3:].strip())
                    elif (arg[:3] == '-sf') and (arg[3:].strip().isdigit()):
                        self.startupframe = int(arg[3:].strip())
                        wx.CallAfter(self.Update)
                        wx.CallAfter(self.ShowVideoFrame, self.startupframe)
### GPo end ###

    def getOptionsDict(self):
        oldOptions = None

        if os.path.isfile(self.optionsfilename):
            try:
                with open(self.optionsfilename, mode='rb') as f:
                    oldOptions = cPickle.load(f)
            except:
                self.loaderror.append(os.path.basename(self.optionsfilename))
                shutil.copy2(self.optionsfilename,
                             os.path.splitext(self.optionsfilename)[0] + '.BAD')
                oldOptions = {}

        if oldOptions and oldOptions.get('version').startswith('1.'):
            oldOptions = None

        if os.name == 'nt':
            templateDict = {
                'avi': 'AVISource(***)',
                'wav': 'WAVSource(***)',
                'd2v': 'D2VSource(***)',
                'dga': 'AVCSource(***)',
                'dgi': 'DGSource(***)',
                'mpg': 'DirectShowSource(***)',
                'mp4': 'DirectShowSource(***)',
                'mkv': 'DirectShowSource(***)',
                'wmv': 'DirectShowSource(***)',
                'avs': 'Import(***)',
                'bmp': 'ImageSource(***)',
                'jpg': 'ImageSource(***)',
                'png': 'ImageSource(***)',
            }
        else:
            templateDict = {
                'avi': 'FFVideoSource(***)',
                'wav': 'FFAudioSource(***)',
                'mpg': 'FFVideoSource(***)',
                'mp4': 'FFVideoSource(***)',
                'mkv': 'FFVideoSource(***)',
                'wmv': 'FFVideoSource(***)',
                'avs': 'Import(***)',
                'bmp': 'FFVideoSource(***, cache=false, seekmode=-1)',
                'jpg': 'FFVideoSource(***, cache=false, seekmode=-1)',
                'png': 'FFVideoSource(***, cache=false, seekmode=-1)',
            }
        applyFilterDict = {
            'Selected filters': '/**avsp_filter\nfilter = """\\\n%*%join\n\\\"""\nApplyFilter(%start, %stop, filter)\n**/',
            'Selected filters*': '/**avsp_filter\nfilter = """\\\n%*%join\n\\\"""\n%>ApplyFilter(%start, %stop, filter)\n**/',
        }
        index = os.name == 'nt'
        sans = ('sans', 'Verdana')[index]
        sans2 = ('sans', 'Arial')[index]
        serif = ('serif', 'Georgia')[index]
        serif2 = ('serif', 'Times New Roman')[index]
        mono = ('monospace', 'Courier New')[index]
        mono2 = ('monospace', 'Fixedsys')[index]
        other = ('sans', 'Comic Sans MS')[index]
        rgb = tuple(map(lambda x: (x+255)/2, wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE).Get()))
        solarized_base03 = '#002b36'
        solarized_base02 = '#073642'
        solarized_base01 = '#586e75'
        solarized_base00 = '#657b83'
        solarized_base0 = '#839496'
        solarized_base1 = '#93a1a1'
        solarized_base2 = '#eee8d5'
        solarized_base3 = '#fdf6e3'
        solarized_yellow = '#b58900'
        solarized_orange = '#cb4b16'
        solarized_red = '#dc322f'
        solarized_magenta = '#d33682'
        solarized_violet = '#6c71c4'
        solarized_blue = '#268bd2'
        solarized_cyan = '#2aa198'
        solarized_green = '#859900'
        solarized_base021 = '#c1c5bb' # added
        solarized_base21 = '#2f525b' # added
        zenburn_normal_fore = '#dcdccc'
        zenburn_normal_back = '#3f3f3f'
        zenburn_low_fore = '#a0a094' # added
        zenburn_comment = '#7f9f7f'
        zenburn_string = '#cc9393'
        zenburn_stringeol_fore = '#ecbcbc'
        zenburn_stringeol_back = '#41363c'
        zenburn_number = '#8cd0d3'
        zenburn_operator = '#f0efd0'
        zenburn_clipproperty = '#9fafaf'
        zenburn_internalfunction = '#c0bed1'
        zenburn_internalfilter = '#6c6c9c'
        zenburn_externalfilter = '#bc6c9c'
        zenburn_userdefined = '#efef8f'
        zenburn_datatype = '#dfdfbf'
        zenburn_keyword = '#f0dfaf'
        zenburn_define = '#ffcfaf'
        zenburn_bad = '#e89393'
        zenburn_cursor_fore = '#000d18'
        zenburn_cursor_back = '#8faf9f'
        zenburn_select_back = '#2f2f2f'
        zenburn_linenumber_fore = '#9fafaf'
        zenburn_linenumber_back = '#262626'
        zenburn_currentline_back = '#434443'
        zenburn_fold_fore = '#93b3a3'
        zenburn_fold_back = '#333333'
        locals_dict = locals()
        self.defaulttextstylesDict = {
            'Default': {
                'monospaced': 'face:{mono},size:10',
                'default': 'face:{sans},size:10,fore:#000000,back:#FFFFFF',
                'comment': 'face:{serif},size:9,fore:#007F00,back:#FFFFFF',
                'comment2': 'face:{sans},size:8,fore:#000000,back:#FFFFFF',
                'blockcomment': 'face:{serif},size:9,fore:#007F00,back:#FFFFFF',
                'endcomment': 'face:{sans},size:10,fore:#C0C0C0,back:#FFFFFF',
                'number': 'face:{mono},size:10,fore:#007F7F,back:#FFFFFF',
                'badnumber': 'face:{mono},size:10,fore:#FF0000,back:#FFFFFF',
                'string': 'face:{mono},size:10,fore:#7F007F,back:#FFFFFF',
                'stringtriple': 'face:{mono},size:10,fore:#7F0000,back:#FFFFFF',
                'stringeol': 'face:{mono},size:10,fore:#000000,back:#E0C0E0',
                'operator': 'face:{sans},size:10,fore:#000000,back:#FFFFFF,bold',
                'assignment': 'face:{sans},size:10,fore:#000000,back:#FFFFFF,bold',
                'clipproperty': 'face:{sans},size:10,fore:#00007F,back:#FFFFFF,bold',
                'internalfunction': 'face:{sans},size:10,fore:#007F7F,back:#FFFFFF,bold',
                'internalfilter': 'face:{sans},size:10,fore:#00007F,back:#FFFFFF,bold',
                'externalfilter': 'face:{sans},size:10,fore:#0080C0,back:#FFFFFF,bold',
                'userdefined': 'face:{sans},size:10,fore:#8000FF,back:#FFFFFF,bold',
                'unknownfunction': 'face:{sans},size:10,fore:#E10000,back:#FFFFFF,bold',
                'parameter': 'face:{sans},size:10,fore:#555555,back:#FFFFFF',
                'datatype': 'face:{sans},size:10,fore:#0000FF,back:#FFFFFF',
                'calltip': 'fore:#808080,back:#FFFFFF',
                'calltiphighlight': 'fore:#000000',
                'keyword': 'face:{sans},size:10,fore:#400080,back:#FFFFFF,bold',
                'miscword': 'face:{sans},size:10,fore:#00007F,back:#FFFFFF,bold',
                'userslider': 'face:{sans},size:10,fore:#00007F,back:#FFFFFF',
                'cursor': 'fore:#000000',
                'bracelight': 'face:{sans},size:10,fore:#0000FF,back:#FFFFFF,bold',
                'badbrace': 'face:{sans},size:10,fore:#FF0000,back:#FFFFFF,bold',
                'highlight': 'fore:#000000,back:#C0C0C0',
                'highlightline': 'back:#E8E8FF',
                'linenumber': 'face:{mono},fore:#555555,back:#C0C0C0',
                'foldmargin': 'fore:#555555,back:#%02X%02X%02X' % rgb,
                'scrapwindow': 'face:{mono},size:10,fore:#0000AA,back:#F5EF90',
                'propwindow': 'face:{sans},size:9,fore:#dcdccc,back:#434443',
                'sliderwindow': 'fore:#E4DEDA,back:#2B2B2B',
                'sliderwindowtextctrl': 'fore:#EBEBEB,back:#353535',
                'sliderwindowdefvalue': 'fore:#FFFD37,bold',
                'sliderwindowextrabtn1': 'fore:#ADB7A4',
                'sliderwindowbackslider': 'back:#2b2b2b',
                'sliderwindowsidebar': 'back:#504e54',
                'sliderwindowprevfilter': 'fore:#D1B38F,back:#B6AFCF',
            },
            'Default dark': {
                'monospaced': 'face:{mono},size:10',
                'default': 'face:{sans},size:10,fore:#dcdccc,back:#2b2b2b',
                'comment': 'face:{serif},size:9,fore:#9eb69e,back:#2b2b2b',
                'comment2': 'face:{sans},size:8,fore:#eae8bf,back:#2b2b2b',
                'blockcomment': 'face:{serif},size:9,fore:#9eb69e,back:#2b2b2b',
                'endcomment': 'face:{sans},size:10,fore:#7f9f7f,back:#2b2b2b',
                'number': 'face:{mono},size:10,fore:#8cd0d3,back:#2b2b2b',
                'badnumber': 'face:{mono},size:10,fore:#e89393,back:#3f3f3f',
                'string': 'face:{mono},size:10,fore:#d7aaaa,back:#2b2b2b',
                'stringtriple': 'face:{mono},size:10,fore:#d7aaaa,back:#2b2b2b',
                'stringeol': 'face:{mono},size:10,fore:#ecbcbc,back:#41363c',
                'operator': 'face:{sans},size:10,fore:#f0efd0,back:#2b2b2b,bold',
                'assignment': 'face:{sans},size:10,fore:#dcdccc,back:#2b2b2b,bold',
                'clipproperty': 'face:{sans},size:10,fore:#afbcbc,back:#2b2b2b,bold',
                'internalfunction': 'face:{sans},size:10,fore:#c0bed1,back:#2b2b2b,bold',
                'internalfilter': 'face:{sans},size:10,fore:#7696eb,back:#2b2b2b,bold',
                'externalfilter': 'face:{sans},size:10,fore:#c987ae,back:#2b2b2b,bold',
                'userdefined': 'face:{sans},size:10,fore:#d6993f,back:#2b2b2b,bold',
                'unknownfunction': 'face:{sans},size:10,fore:#e89393,back:#3f3f3f,bold',
                'parameter': 'face:{sans},size:10,fore:#bcbcb4,back:#2b2b2b',
                'datatype': 'face:{sans},size:10,fore:#dfdfbf,back:#2b2b2b',
                'calltiphighlight': 'fore:#dcdccc',
                'calltip': 'fore:#a0a094,back:#434443',
                'keyword': 'face:{sans},size:10,fore:#eedda8,back:#2b2b2b,bold',
                'miscword': 'face:{sans},size:10,fore:#f0dfaf,back:#444444,bold',
                'userslider': 'face:{sans},size:10,fore:#ffcfaf,back:#2b2b2b',
                'cursor': 'fore:#8faf9f',
                'bracelight': 'face:{sans},size:10,fore:#93b3a3,back:#3f3f3f,bold',
                'badbrace': 'face:{sans},size:10,fore:#e89393,back:#3f3f3f,bold',
                'highlight': 'fore:#00ff00,back:#555555',
                'highlightline': 'back:#000000',
                'linenumber': 'face:{mono},size:10,fore:#9fafaf,back:#262626',
                'foldmargin': 'fore:#93b3a3,back:#333333',
                'scrapwindow': 'face:{mono},size:10,fore:#dcdccc,back:#434443',
                'propwindow': 'face:{sans},size:9,fore:#dcdccc,back:#434443',
                'sliderwindow': 'fore:#E4DEDA,back:#2b2b2b',
                'sliderwindowtextctrl': 'fore:#EBEBEB,back:#353535',
                'sliderwindowdefvalue': 'fore:#FFFD37,bold',
                'sliderwindowextrabtn1': 'fore:#ADB7A4',
                'sliderwindowbackslider': 'back:#2b2b2b',
                'sliderwindowsidebar': 'back:#504e54',
                'sliderwindowprevfilter': 'fore:#D1B38F,back:#B6AFCF',
            },
            # Based, with some minor changes, on Solarized <http://ethanschoonover.com/solarized>
            'Solarized light': {
                'monospaced': 'face:{mono},size:10',
                'default': 'face:{sans},size:10,fore:{solarized_base00},back:{solarized_base3}',
                'comment': 'face:{serif},size:9,fore:{solarized_base1},back:{solarized_base3}',
                'comment2': 'face:{sans},size:8,fore:{solarized_base00},back:{solarized_base3}',
                'blockcomment': 'face:{serif},size:9,fore:{solarized_base1},back:{solarized_base3}',
                'endcomment': 'face:{sans},size:10,fore:{solarized_base1},back:{solarized_base3}',
                'number': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base3}',
                'badnumber': 'face:{mono},size:10,fore:{solarized_red},back:{solarized_base3}',
                'string': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base3}',
                'stringtriple': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base3}',
                'stringeol': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base2}',
                'operator': 'face:{sans},size:10,fore:{solarized_base00},back:{solarized_base3},bold',
                'assignment': 'face:{sans},size:10,fore:{solarized_base00},back:{solarized_base3},bold',
                'clipproperty': 'face:{sans},size:10,fore:{solarized_blue},back:{solarized_base3},bold',
                'internalfunction': 'face:{sans},size:10,fore:{solarized_blue},back:{solarized_base3},bold',
                'internalfilter': 'face:{sans},size:10,fore:{solarized_violet},back:{solarized_base3},bold',
                'externalfilter': 'face:{sans},size:10,fore:{solarized_magenta},back:{solarized_base3},bold',
                'userdefined': 'face:{sans},size:10,fore:{solarized_yellow},back:{solarized_base3},bold',
                'unknownfunction': 'face:{sans},size:10,fore:{solarized_red},back:{solarized_base3},bold',
                'parameter': 'face:{sans},size:10,fore:{solarized_base1},back:{solarized_base3}',
                'datatype': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base3}',
                'calltip': 'fore:{solarized_base00},back:{solarized_base2}',
                'calltiphighlight': 'fore:{solarized_base21}',
                'keyword': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base3},bold',
                'miscword': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base3},bold',
                'userslider': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base3}',
                'cursor': 'fore:{solarized_base21}',
                'bracelight': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base3},bold',
                'badbrace': 'face:{sans},size:10,fore:{solarized_red},back:{solarized_base3},bold',
                'highlight': 'fore:{solarized_base21},back:{solarized_base021}',
                'highlightline': 'back:{solarized_base2}',
                'linenumber': 'face:{mono},fore:{solarized_base1},back:{solarized_base2}',
                'foldmargin': 'fore:{solarized_base1},back:{solarized_base2}',
                'scrapwindow': 'face:{mono},size:10,fore:{solarized_base01},back:{solarized_base2}',
                'propwindow': 'face:{sans},size:9,fore:#dcdccc,back:#434443',
                'sliderwindow': 'fore:#E4DEDA,back:#2B2B2B',
                'sliderwindowtextctrl': 'fore:#EBEBEB,back:#353535',
                'sliderwindowdefvalue': 'fore:#FFFD37,bold',
                'sliderwindowextrabtn1': 'fore:#ADB7A4',
                'sliderwindowbackslider': 'back:#2B2B2B',
                'sliderwindowsidebar': 'back:#504e54',
                'sliderwindowprevfilter': 'fore:#D1B38F,back:#B6AFCF',
            },
            'Solarized dark': {
                'monospaced': 'face:{mono},size:10',
                'default': 'face:{sans},size:10,fore:{solarized_base0},back:{solarized_base03}',
                'comment': 'face:{serif},size:9,fore:{solarized_base01},back:{solarized_base03}',
                'comment2': 'face:{sans},size:8,fore:{solarized_base0},back:{solarized_base03}',
                'blockcomment': 'face:{serif},size:9,fore:{solarized_base01},back:{solarized_base03}',
                'endcomment': 'face:{sans},size:10,fore:{solarized_base01},back:{solarized_base03}',
                'number': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base03}',
                'badnumber': 'face:{mono},size:10,fore:{solarized_red},back:{solarized_base03}',
                'string': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base03}',
                'stringtriple': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base03}',
                'stringeol': 'face:{mono},size:10,fore:{solarized_cyan},back:{solarized_base02}',
                'operator': 'face:{sans},size:10,fore:{solarized_base0},back:{solarized_base03},bold',
                'assignment': 'face:{sans},size:10,fore:{solarized_base0},back:{solarized_base03},bold',
                'clipproperty': 'face:{sans},size:10,fore:{solarized_blue},back:{solarized_base03},bold',
                'internalfunction': 'face:{sans},size:10,fore:{solarized_blue},back:{solarized_base03},bold',
                'internalfilter': 'face:{sans},size:10,fore:{solarized_violet},back:{solarized_base03},bold',
                'externalfilter': 'face:{sans},size:10,fore:{solarized_magenta},back:{solarized_base03},bold',
                'userdefined': 'face:{sans},size:10,fore:{solarized_yellow},back:{solarized_base03},bold',
                'unknownfunction': 'face:{sans},size:10,fore:{solarized_red},back:{solarized_base03},bold',
                'parameter': 'face:{sans},size:10,fore:{solarized_base01},back:{solarized_base03}',
                'datatype': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base03}',
                'calltip': 'fore:{solarized_base0},back:{solarized_base02}',
                'calltiphighlight': 'fore:{solarized_base021}',
                'keyword': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base03},bold',
                'miscword': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base03},bold',
                'userslider': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base03}',
                'cursor': 'fore:{solarized_base021}',
                'bracelight': 'face:{sans},size:10,fore:{solarized_green},back:{solarized_base03},bold',
                'badbrace': 'face:{sans},size:10,fore:{solarized_red},back:{solarized_base03},bold',
                'highlight': 'fore:{solarized_base021},back:{solarized_base21}',
                'highlightline': 'back:{solarized_base02}',
                'linenumber': 'face:{mono},fore:{solarized_base01},back:{solarized_base02}',
                'foldmargin': 'fore:{solarized_base01},back:{solarized_base02}',
                'scrapwindow': 'face:{mono},size:10,fore:{solarized_base1},back:{solarized_base02}',
                'propwindow': 'face:{sans},size:9,fore:#dcdccc,back:#434443',
                'sliderwindow': 'fore:#E4DEDA,back:#2B2B2B',
                'sliderwindowtextctrl': 'fore:#EBEBEB,back:#353535',
                'sliderwindowdefvalue': 'fore:#FFFD37,bold',
                'sliderwindowextrabtn1': 'fore:#ADB7A4',
                'sliderwindowbackslider': 'back:#2B2B2B',
                'sliderwindowsidebar': 'back:#504e54',
                'sliderwindowprevfilter': 'fore:#D1B38F,back:#B6AFCF',
            },
        }
        #self.x_defaultTextStyle = dict(self.defaulttextstylesDict['Default'].copy()) # for test
        for values in self.defaulttextstylesDict.itervalues():
            for key, value in values.items():
                values[key] = value.format(**locals_dict)
        textstylesDict = self.defaulttextstylesDict['Default'].copy()
        # Create the options dict
        self.options = global_vars.options
        self.options.update({
            # Avisynth properties, header 8 must be at least version 3.71, previously C interface bug
            'can_read_avisynth_props': False,
            # INTERNAL OPTIONS
            'templates': templateDict,
            'snippets': {},
            'textstyles': textstylesDict,
            'applyfilters': applyFilterDict,
            'displayfilters': {},
            'theme_set_only_colors': True,
            'filteroverrides': {},
            'filterpresets': {},
            'filterdefaults_presets': {},
            'filterremoved': set(),
            'shortcuts': [],
            'contextshowshortcuts': True,  # GPo, show shortcuts in the contextmenus (videoWindow, script)
            'recentdir': '',
            'userecentdir': True,
            'recentdirPlugins': '',
            'recentdirSession': '',
            'recentfiles': None,
            'lastscriptid': None,
            'scraptext': ('', 0, 0),
            'maximized': False,
            'maximized2': False,
            'dimensions': (intPPI(50), intPPI(50), intPPI(700), intPPI(550)), # TODO ppi_factor not set
            'dimensions2': None,    # videoDialog (separate Video Wnd)
            'propwindowrect': None, # GPo propWindow dimensions
            'find_recent': [],
            'replace_recent': [],
            'cropchoice': 0,
            'autocrop_samples': 10,
            'triminsertchoice': 0,
            'trimreversechoice': 0,
            'trimmarkframes': True,
            'imagechoice': 0,
            'jpegquality': 85,     # GPo 2018  70 to 85
            'askjpegquality': True,
            'imagenamedefaultformat': '%s%06d',
            'imagenameformat': '%s%06d',
            'imagesavedir': '',
            'useimagesavedir': True,
            'colourdata': '1',
            'zoomindex': 2,
            'exitstatus': 0,
            'reservedshortcuts': ['Escape', 'Tab', 'Shift+Tab', 'Ctrl+Z', 'Ctrl+Y', 'Ctrl+X', 'Ctrl+C', 'Ctrl+V', 'Ctrl+A'],
            # GENERAL OPTIONS
            'altdir': os.path.join('%programdir%', 'tools'),
            'usealtdir': False,
            'pluginsdir': '',
            'avisynthhelpfile': '',
            'workdir': os.path.join('%programdir%', 'tools'),
            'useworkdir': False,
            'alwaysworkdir': False,
            'customplugindir': False,   # GPo
            'plugindirregister': False, # GPo
            'dllfuncparseerror': True, # GPo, False = no error message on parse plugin and function names
            'externalplayer': '',
            'externalplayerargs': '',
            'externaltool': '',         # GPo 2020
            'externaltoolarg1': 'AvsMeter info|-avsinfo',   # GPo 2020, predefined for AvsMeter
            'externaltoolarg2': 'AvsMeter|%fn',             # GPo 2020, predefined for AvsMeter
            'docsearchpaths': ';'.join(['%pluginsdir%',
                    os.path.join('%avisynthdir%' if os.name == 'nt'
                        else '/usr/local/share', 'docs', 'english', 'corefilters'),
                    os.path.join('%avisynthdir%' if os.name == 'nt'
                        else '/usr/local/share', 'docs', 'english', 'externalfilters')]),
            'docsearchurl':'http://www.google.com/search?q=%filtername%+Avisynth',
            # TEXT OPTIONS
            'calltips': True,
            'frequentcalltips': False,
            'syntaxhighlight_preferfunctions': False,
            'syntaxhighlight_styleinsidetriplequotes': True,
            'usestringeol': True,
            'autocomplete': True,
            'autocompletelength': 1,
            'autocompletepluginnames': {},
            'autoparentheses': 1,
            'presetactivatekey': 'return',
            'wrap': False,
            'highlight_fore': False,
            'highlightline': True,
            'usetabs': False,
            'tabwidth': 4,
            'numlinechars': 1,
            'foldflag': 1,
            'autocompletesingle': True,
            'autocompletevariables': True,
            'autocompleteicons': True,
            'calltipsoverautocomplete': False,
            'fdb_plugins': True,
            'fdb_userscriptfunctions': True,
            'autoloadedplugins': True,
            'autoloadedavsi': True,
            # VIDEO OPTIONS
            'mousewheelfunc': 'frame_step',    # GPo 2020
            'startupwithlastzoom': False,      # GPo 2020
            'zoom_antialias': False,           # GPo 2020
            'buttonjumpchoice' : 0,            # GPo 0=frame, 1=1 sec, 2=1 minute, 3=custom units
            'dragupdate': True,
            'focusonrefresh': True,
            'previewunsavedchanges': True,
            'hidepreview': False,
            'refreshpreview': True,
            'promptwhenpreview': False,
            'last_preview_placement': wx.SPLIT_HORIZONTAL,
            'separatevideowindow': False,
            'previewontopofmain': True,
            'videostatusbarinfo': None,
            'use_customvideobackground': False,
            'videobackground': (0, 0, 0),
            'customvideobackground': (0, 0, 0),
            'errormessagefont': ('Arial', 24, '$FF0000', '', (0, 0, 0)),  # GPo fontColor
            'cropminx': 16,
            'cropminy': 16,
            'customjump': 10,
            'customjumpunits': 'sec',
            'enabletabscrolling': False,
            'enabletabscrolling_groups': True,
            'enableframepertab': True,
            'enableframepertab_same': True,
            'applygroupoffsets': True,
            'offsetbookmarks': False,
            'readmatrix': True, # GPo, read the BT. type (601,709) from source
            'defaultmatrix': 'auto,tv',
            'resetmatrix': False, # for real.finder, reset the matrix if not found
            'displayfilter': utils.resource_str_displayfilter,
            'resizefilter': 'Spline36Resize',
            'frametoframetime': False,           # GPo, recalc on video update last frame time to new framenum
            'fullscreenmode': 3,                 # 0= show tabs always, 1= hide tabs only if row count > 1, 2= hide if fullscreen else 0, 3= hide if fullscreen else 1,  4= hide tabs always
            # AUTOSLIDER OPTIONS
            'keepsliderwindowhidden': True,
            'autoslideron': True,
            'sliderdisablerefresh': True,         # GPo disable script refresh on sliders change
            'autosliderstartfold': 3,             # GPo, fold or restore
            'allsliderwindowshideshow': True,     # GPo, Button shows or hides all slider window
            'autoslidermakeintfloat': True,
            'autoslidermakeintlist': True,
            'autoslidermakecolor': True,
            'autoslidermakebool': True,
            'autoslidermakestringlist': True,
            'autoslidermakestringfilename': True,
            'autoslidermakeunknown': True,
            'autosliderexclusions': '',
            'autosliderupdatedirectly': True,       # GPo
            'sliderwindowcustomtheme': True,        # GPo
            'sliderhidetagmenu': False,             # GPo
            # USER SLIDER, TOGGLE TAGS
            'savetoggletags': False,                # GPo, save toggle tags within the script
            # MISC OPTIONS
            'lang': 'eng',
            'startupsession': True,
            'alwaysloadstartupsession': False,
            'closeneversaved': False,
            'promptexitsave': True,
            'promptexitsaveonlyexisting': False,     # GPo
            'bookmarksfromscript': True,             # GPo
            'tabsbookmarksfromscript': True,         # GPo
            'warnscriptbookmarksdif': True,          # GPo 2020
            'middlemousefunc': 'show video frame',   # GPo 2020
            'mouseauxdown': 'tab change',            # GPo 2020
            'tabautopreview': False,                 # GPo 2021
            'hidescrollbars': False,                 # GPo 2021
            'scriptwindowbindmousewheel': 0,         # GPo 2021 # user problem with mouse wheel on editor
            'playloop': False,                       # GPo 2020 playback loop
            'playbackthread': True,                  # GPo 2021, if true use separate thread for playback
            'avithread': True,                       # GPo 2021, if true use separate thread for loading and freeing the clip and frame
            'avithreadassignlater': True,            # GPo 2021, if true then thread assign AVI to script after canceling, else freeing the clip
            'usenewframethread': True,               # GPo now default
            'progressdelaytime': 10,                 # GPo delay before showing thread progress dialog (10s)
            'threadprogressopt': 0,                  # GPo, thread progress behave, 0=old, 1=show dialog, 2=hide dialog
            'bookmarktotrim': False,                 # GPo 2020
            'bookmarkshilightcolor': wx.Colour(233,122,122),   # GPo
            'selectionshilightcolor': wx.Colour(110,110,204),  # GPo 2020
            'showfreememory': 1000,                  # GPo
            'savemarkedavs': False,                  # GPo, changed to false, i don't like hidden scripts
            'timelineautoscroll': True,              # GPo, scroll the timeline range if needed
            'timelineautoreset': True,               # GPo, reset the range if frame count change
            'timelinemoveslidertostart': True,       # GPo, set slider to timeline start
            'timelinestatusbarmovesense': 100,       # GPo, sensevity timeline mouse move
            'timelinehidenumbers': True,             # GPo, automatically hide the numbers if trim dialog shown
            'timelinenumdivisor': 5,                 # GPo, timline number divisor e.g. 10 shows 9 numbers
            'timelinesplitclipcolor': (100,160,120), # GPo, timeline color if Split Clip enabled
            'autosnapshot': True,                    # GPo, automatically take snapshot 2 on clip refresh
            'propwinhorzscroll': False,              # GPo, property wnd scrollbar
            'propwinwordwarp': False,                # GPo, property wnd word warp
            'sessionbackupcount': 3,                 # GPo, max session backups at startup
            'showresamplemenu': 0,                   # GPo, 1= as submenu, 2=normal 0= hide and disabled
            'resizevideowindow': True,               # GPo, resize the video window on set zoom and tab change
            'showbuttontooltip': True,               # GPo, show video controls button tooltips
            'propwindowparent': 0,                   # GPo, property window parent (0,1) 0=propertyWnd, 1=sliderWnd
            'propwindowparentsize': intPPI(200),     # GPo, property text height in the slider window
            'sliderwindowwidth': -intPPI(400),       # GPo, default slider window width, must be negative!
            'optionsdlgsize': (300, 300),            # GPo, not important, only width is set after layout
            'numberwheel': False,                    # GPo, enable/disable number wheel
            'numberwheelfaster': False,              # GPo, change OnMiddleUpScriptWindow the number wheel performance
            'threaddlgshowmem': True,                # GPo, thread dlg show free and script memory
            'usesplitclip': False,                   # GPo, on UpdateScriptAvi restore script.AVI.split_clip if AVI.IsSplitClip enabled on refresh
            'usefastclip': True,                     # GPo, /**avsp_split**/ must be written in the script do use the fastClip.  AvsPmod is then the fastest Avisynth editor ;)
            'cliprefreshpainter': True,              # GPo, paint the last frame during clip refresh if load Avisynth in threads enabled (disavantage
            'splitviewex': False,                    # GPo, use Split View alternate (self.splitViewEx)
            'eol': 'auto',
            'loadstartupbookmarks': True,
            'nrecentfiles': 5,
            'mintextlines': 6,
            'usetabimages': True,
            'multilinetab': False,
            'fixedwidthtab': False,
            'invertscrolling': False,
            'invertframescrolling': False,
            'dllnamewarning': True,
            # TOGGLE OPTIONS
            'alwaysontop': False,
            'previewalwaysontop': False,
            'singleinstance': False,
            'usemonospacedfont': False,
            'usesliderwindowprevfiltercolor': True,
            'usesliderwindowbackslider': False,
            'sliderwindowsidebarcolor': False,
            'disablepreview': False,
            'paranoiamode': False,
            'periodicbackup': 0,
            'autoupdatevideo': False,
            # PPI scaling (DPI) # GPo 2020
            'ppiscalingstatusbar': 0,
            'ppiscalingscripttabs': 0,
            'ppiscalingvideocontrols': 0,
            'ppiscalingsliderwindow': 0,
        })
        # Import certain options from older version if necessary
        if oldOptions is not None:
            # Update the new options dictionnary with the old options
            updateInfo = [(k,v) for k,v in oldOptions.items() if k in self.options]
            self.options.update(updateInfo)
            # Update the new options sub-dictionnaries with the old options
            for key, d1 in (('templates', templateDict), ('textstyles', textstylesDict)):
                d2 = oldOptions.get(key)
                if d2 is not None:
                    d1.update(d2)
                self.options[key] = d1

        self.options['version'] = self.version
        self.options['offsetbookmarks'] = False # GPo, disable it as default

        # Fix recentfiles as necessary???
        try:
            for i, s in enumerate(self.options['recentfiles']):
                if type(s) != unicode:
                    self.options['recentfiles'][i] = unicode(s, encoding)
        except TypeError:
            pass

        # check new key to make options.dat compatible for all 2.x version
        if len(self.options['textstyles']['highlight'].split(':')) == 2:
            self.options['textstyles']['highlight'] += ',fore:#000000'
        if len(self.options['textstyles']['foldmargin'].split(':')) == 2:
            self.options['textstyles']['foldmargin'] += ',fore:#555555'
        self.options['cropminx'] = self.options['cropminy'] = 1
        self.options['loadstartupbookmarks'] = True
        if oldOptions and 'autocompleteexclusions' in oldOptions:
            for name in oldOptions['autocompleteexclusions']:
                self.options['filterremoved'].add(name.lower())
        if oldOptions and 'parseavsi' in oldOptions:
            self.options['autoloadedavsi'] = oldOptions['parseavsi']

    def SetPaths(self):
        '''Set configurable paths'''
        self.avisynthdir = ''
        altdir_exp = self.ExpandVars(self.options['altdir'])
        if os.name == 'nt':
            try:
                # Get the avisynth directory from the registry
                key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'Software\\AviSynth')
                value = os.path.expandvars(_winreg.EnumValue(key, 0)[1])
                if os.path.isdir(value):
                    self.defaultavisynthdir = value
                else:
                    raise WindowsError
                key.Close()
            except WindowsError:
                self.defaultavisynthdir = ''

            if self.options['usealtdir'] and os.path.isdir(altdir_exp):
                self.avisynthdir = self.options['altdir']
                global_vars.avisynth_library_dir = altdir_exp
            else:
                self.options['usealtdir'] = False
                if os.path.isdir(self.defaultavisynthdir):
                    self.avisynthdir = self.ExpandVars(self.defaultavisynthdir, False, '%avisynthdir%')

            avisynthdir_exp = self.ExpandVars(self.avisynthdir)
            if (not os.path.isfile(self.ExpandVars(self.options['avisynthhelpfile'])) and
                os.path.isfile(os.path.join(avisynthdir_exp, 'docs', 'english', 'index.htm'))):
                    self.options['avisynthhelpfile'] = os.path.join('%avisynthdir%', 'docs', 'english', 'index.htm')

            # GPo, read plugins path from the registry or read not and let the user set the path
            if self.options['customplugindir'] and os.path.isdir(self.options['pluginsdir']):
                return
            try:
                # Get the plugins directory from the registry (local machine, AviSynth 2.5-2.6 and avs+)
                key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'Software\\AviSynth')
                value = os.path.expandvars(_winreg.QueryValueEx(key, 'plugindir2_5')[0])
                if os.path.isdir(value):
                    self.options['pluginsdir'] = self.ExpandVars(value, False, '%pluginsdir%')
                else:
                    value = os.path.expandvars(_winreg.QueryValueEx(key, 'plugindir+')[0])   # GPo added avs+
                    if os.path.isdir(value):
                        self.options['pluginsdir'] = self.ExpandVars(value, False, '%pluginsdir%')
                    else:
                        raise WindowsError
                key.Close()
            except WindowsError:
                self.options['pluginsdir'] = ''
                wx.MessageBox(_("Cannot read the avisynth plugins directory from the registry\n")+
                              _("HKLM\Software\Avisynth\'plugindir2_5' or 'plugindir+' is missing or wrong.\n\n")+
                              _("You should set the plugins path under options manually or register it."), 'Information')
        else:
            if self.options['usealtdir'] and os.path.isdir(altdir_exp):
                self.avisynthdir = self.options['altdir']
                global_vars.avisynth_library_dir = altdir_exp
            else:
                self.options['usealtdir'] = False
                self.avisynthdir = '/usr/local/lib'
            if not os.path.isfile(self.ExpandVars(self.options['avisynthhelpfile'])):
                helpfile = '/usr/local/share/doc/english/index.htm'
                if os.path.isfile(helpfile):
                    self.options['avisynthhelpfile'] = helpfile
            self.defaultpluginsdir = self.ExpandVars(os.path.join('%avisynthdir%', 'avxsynth'))
            pluginsdir_exp = self.ExpandVars(self.options['pluginsdir'])
            if os.path.isdir(pluginsdir_exp):
                os.environ['AVXSYNTH_RUNTIME_PLUGIN_PATH'] = pluginsdir_exp
            else:
                pluginsdir = os.environ.get('AVXSYNTH_RUNTIME_PLUGIN_PATH', '')
                if os.path.isdir(pluginsdir):
                    self.options['pluginsdir'] = self.ExpandVars(pluginsdir, False, '%pluginsdir%')
                elif os.path.isdir(self.defaultpluginsdir):
                    self.options['pluginsdir'] = self.defaultpluginsdir
        if self.options['useworkdir']:
            workdir = self.ExpandVars(self.options['workdir'])
            if os.path.isdir(workdir):
                os.chdir(workdir)

    def LoadAvisynth(self):
        '''Load avisynth.dll/avxsynth.so'''
        global avisynth
        exception = path_used = altdir_used = False
        while True:
            try:
                if self.x86_64:
                    import avisynth_cffi as avisynth
                else:
                    import avisynth
                break
            except OSError as err:
                if __debug__:
                    print (err)
                exception = True
                if self.options['usealtdir']:
                    if not path_used:
                        global_vars.avisynth_library_dir = ''
                        path_used = True
                        continue
                elif self.options['altdir'] and not altdir_used:
                    global_vars.avisynth_library_dir = self.ExpandVars(self.options['altdir'])
                    altdir_used = True
                    continue
                lib = ('AviSynth', 'avisynth.dll') if os.name == 'nt' else ('AvxSynth', 'libavxsynth.so')
                message = (_('{0}\n\nLoading {1} failed! Make sure that {2} is installed.'
                           '\n\n' + _('Alternatively, specify now its directory.')).format(
                          err, lib[1], lib[0]))
                ret = wx.MessageBox(message, ' '.join((self.name, self.version)), wx.YES_NO|wx.ICON_ERROR)
                if ret == wx.YES:
                        # Get the shared library directory from the user with a dialog box
                        dlg = wx.DirDialog(self, _('Select the {0} directory').format(lib[1]),
                                           os.path.expanduser('~'))
                        ID = dlg.ShowModal()
                        if ID==wx.ID_OK:
                            global_vars.avisynth_library_dir = dlg.GetPath()
                            dlg.Destroy()
                        else:
                            dlg.Destroy()
                            sys.exit(0)
                else:
                    sys.exit(0)
        if exception:
            if global_vars.avisynth_library_dir:
                self.options['usealtdir'] = True
                self.options['altdir'] = self.ExpandVars(
                        global_vars.avisynth_library_dir, False, 'avisynthdir')
            else:
                self.options['usealtdir'] = False
            self.SetPaths() # some paths may depend on %avisynthdir%
        try:
            global pyavs
            import pyavs
        except AttributeError:
            import pyavs_avifile as pyavs #  VFW, not longer supported
        pyavs.InitRoutines()

    def defineFilterInfo(self):
        self.plugin_shortnames = collections.defaultdict(list)
        self.optionsFilters = self.getFilterInfoFromAvisynth()

        #~if not self.avisynth_p: # parse avsi files for user script functions
        # vdcrim 2019 update
        # Parse avsi files for user script functions
        # This info is already provided by AviSynth+
        if not self.avisynth_p and self.options['pluginsdir']:

            parse_avsi = self.options['autoloadedavsi']
            pluginsdir = self.ExpandVars(self.options['pluginsdir'])

            def escape_fnmatch(path):
                """Taken from http://bugs.python.org/issue8402"""
                pattern_chrs = re.compile('([*?[])')
                drive, path = os.path.splitdrive(path)
                path = pattern_chrs.sub(r'[\1]', path)
                return drive + path

            filenames = glob.iglob(os.path.join(escape_fnmatch(pluginsdir), '*.avsi'))
            filterInfo = []
            for filename in filenames:
                try:
                    info = self.ParseAvisynthScript(filename, quiet=True)
                except:
                    info = None
                if info:
                    filterInfo += info
            for filename, filtername, filterargs, ftype in filterInfo:
                filtername_lower = filtername.lower()
                if parse_avsi:
                    self.optionsFilters[filtername_lower] = (filtername, filterargs, ftype)
                self.installed_avsi_filternames.add(filtername_lower)

        if __debug__:
            self.ExportFilterData(self.optionsFilters, os.path.join(self.programdir, 'tempfilterout.txt'), True)

        self.avskeywords = [
            'return', 'global', 'function', 'last',
            'true', 'false', 'try', 'catch', 'if', 'else'
        ]
        self.avsdatatypes = [
            'clip', 'int', 'float', 'string', 'bool', 'var', 'func', 'array'  # GPo add 'func', 'array' Neo or >= v3.52 compatiple
        ]
        self.avsoperators = [
            '-', '*', ',', '.', '/', ':', '?', '\\', '+', '<', '>', '=',
            '(', ')', '[', ']', '{', '}', '!', '%', '&', '|',
        ]

        self.avsmiscwords = ['__end__']
        if os.path.isfile(self.filterdbfilename):
            # GPo test naming STGMC>QTGMC other name same args
            linkNamings = []
            filters_ex = {}
            def testNaming(s):
                splitstring = s.split('>', 1)
                if len(splitstring) == 2 and splitstring[1].lower() in self.optionsFilters:
                    args = self.optionsFilters[splitstring[1].lower()][1]
                    return splitstring[0].strip(), args
                return '', ''
            # test end
            try:
                with open(self.filterdbfilename, mode='r') as f:
                    text = '\n'.join([line.strip() for line in f.readlines()])
                for section in text.split('\n\n['): # TODO: merge AvsFunctionDialog.ParseCustomizations and this
                    title, data = section.split(']\n',1)
                    title = title.strip('[]').lower()
                    if title == 'keywords':
                        self.avskeywords = data.split()
                    elif title == 'datatypes':
                        self.avsdatatypes = data.split()
                    elif title == 'operators':
                        self.avsoperators = data.split()
                    elif title == 'clipproperties':
                        for item in data.split('\n'):
                            if not item.strip():
                                continue
                            splitstring = item.split('(', 1)
                            if len(splitstring) == 2:
                                filtername = splitstring[0].strip()
                                filterargs = '('+splitstring[1].strip(' ')
                            else:
                                filtername = item
                                filterargs = ''
                            if filtername.startswith('*'):
                                filters_ex[filtername.lower()] = (filtername, filterargs, 1)
                            else:
                                self.optionsFilters[filtername.lower()] = (filtername, filterargs, 1)
                    elif title == 'scriptfunctions':
                        for item in data.split('\n'):
                            if not item.strip():
                                continue
                            splitstring = item.split('(', 1)
                            if len(splitstring) == 2:
                                filtername = splitstring[0].strip()
                                filterargs = '('+splitstring[1].strip(' ')
                            else:
                                filtername = item
                                filterargs = ''
                            self.optionsFilters[filtername.lower()] = (filtername, filterargs, 4)
                    elif title == 'corefilters':
                        for s in data.split('\n\n'):
                            splitstring = s.split('(', 1)
                            if len(splitstring) == 2:
                                filtername = splitstring[0].strip()
                                filterargs = '('+splitstring[1].strip(' ')
                                if filtername.startswith('*'):
                                    filters_ex[filtername.lower()] = (filtername, filterargs, 0)
                                else:
                                    self.optionsFilters[filtername.lower()] = (filtername, filterargs, 0)
                            """
                            else: # GPo, other name but same args
                                splitstring = s.split('>', 1)
                                if len(splitstring) == 2:
                                    linkNamings.append((s, 0))
                            """
                    elif title == 'plugins':
                        if not self.options['fdb_plugins']:
                            continue
                        for s in data.split('\n\n'):
                            splitstring = s.split('(', 1)
                            if len(splitstring) == 2:
                                filtername = splitstring[0].strip()
                                filterargs = '('+splitstring[1].strip(' ')
                                key = filtername.lower()
                                short_name = self.GetPluginFunctionShortName(key)
                                if short_name:
                                    self.optionsFilters[key] = (filtername, filterargs, 2)
                                    self.plugin_shortnames[short_name].append(key)
                                else:
                                    print>>sys.stderr, '{0}: {1}'.format(_('Error'), _('Invalid plugin '
                                        'function name "{name}". Must be "pluginname_functionname".').format(name=key))
                    elif title == 'userfunctions':
                        if not self.options['fdb_userscriptfunctions']:
                            continue
                        for s in data.split('\n\n'):
                            splitstring = s.split('(', 1)
                            if len(splitstring) == 2:
                                filtername = splitstring[0].strip()
                                filterargs = '('+splitstring[1].strip(' ')
                                self.optionsFilters[filtername.lower()] = (filtername, filterargs, 3)
                            else: # GPo, other name but same args STGMC>QTGMC
                                splitstring = s.split('>', 1)
                                if len(splitstring) == 2:
                                    linkNamings.append((s, 3))

                # GPo, other name but same args ( only on 'userfunctions' used)
                if linkNamings:
                    for i, (s, typ) in enumerate(linkNamings):
                        filtername, filterargs = testNaming(s)
                        if filtername:
                            self.optionsFilters[filtername.lower()] = (filtername, filterargs, typ)
                # end test
            except:
                self.loaderror.append(os.path.basename(self.filterdbfilename))
                bad0 = os.path.splitext(self.filterdbfilename)[0]
                bad, i = bad0 + '.BAD', 1
                while os.path.isfile(bad):
                    bad = bad0 + str(i) + '.BAD'
                    i += 1
                os.rename(self.filterdbfilename, bad)
        # Clean up override dict
        deleteKeys = []

        for key, value in self.options['filteroverrides'].items():
            if key in self.optionsFilters and self.optionsFilters[key] == value:
                deleteKeys.append(key)
        for key in deleteKeys:
            del self.options['filteroverrides'][key]
        # Don't lose edited plugin and user function presets when the plugin/avsi
        # is removed and the definition was not overrided
        for key, value in self.options['filterdefaults_presets'].items():
            if key not in self.optionsFilters:
                self.options['filteroverrides'][key] = value
        # Define data structures that are used by each script
        self.avsfilterdict = {}
        self.avsfilterdictEx = {}
        self.defineScriptFilterInfo(ex_filterList=filters_ex)

    def ExportFilterData(self, filterDict, filename, onlylongnames=False):
        order = [1, 4, 0, 2, 3]
        keysdec = [(order.index(v[2]), k) for k,v in filterDict.items()]
        keysdec.sort()
        lines = []
        typeDict = {
            0: '[COREFILTERS]',
            1: '[CLIPPROPERTIES]',
            2: '[PLUGINS]',
            3: '[USERFUNCTIONS]',
            4: '[SCRIPTFUNCTIONS]',
        }
        currentType = None
        for keysortindex, key in keysdec:
            keytype = order[keysortindex]
            if keytype != currentType:
                extra = ''
                if len(lines) > 0:
                    if not lines[-1].endswith('\n\n'):
                        extra = '\n'
                lines.append(extra+typeDict[keytype]+'\n')
                currentType = keytype
            propername, args, ftype = filterDict[key]
            if onlylongnames and ftype == 2 and key.count('_') == 0:
                continue
            if ftype in (1, 4):
                line = propername+args+'\n'
            else:
                if args.count('\n') == 0:
                    line = '%s(\n%s\n)\n\n' % (propername, ',\n'.join(args.strip('()').split(', ')))
                    line = line.replace('[,\n...]', '[, ...]')
                else:
                    line = propername+args+'\n\n'
            lines.append(line)
        f = open(filename, 'w')
        f.writelines(lines)
        f.close()

    def defineScriptFilterInfo(self, ex_filterList=None):
        # Create the basic filter dictionnary - {lowername: (args, style_constant)}
        styleList = [  # order is important here!
            AvsStyledTextCtrl.STC_AVS_COREFILTER,
            AvsStyledTextCtrl.STC_AVS_CLIPPROPERTY,
            AvsStyledTextCtrl.STC_AVS_PLUGIN,
            AvsStyledTextCtrl.STC_AVS_USERFUNCTION,
            AvsStyledTextCtrl.STC_AVS_SCRIPTFUNCTION,
        ]
        self.options['filterdefaults_presets'] = dict(
            [ # plugins and user functions with its preset edited but not the definition
            (lowername, (name, args, ftype))
            for lowername, (name, args, ftype) in self.optionsFilters.items()
            if lowername in self.options['filterpresets'] and
               lowername not in self.options['filteroverrides'] and
               ftype in (2, 3)
            ]
        )
        self.avsfilterdict.clear()
        self.avsfilterdict.update(dict(
            [
            (lowername, (args, styleList[ftype], name, None))
            for lowername,(name,args,ftype) in self.optionsFilters.items()
            ]
        ))
        self.avsfilterdictEx.clear()
        if ex_filterList:
            self.avsfilterdictEx.update(dict(
                [
                (lowername, (args, styleList[ftype], name, None))
                for lowername,(name,args,ftype) in ex_filterList.items()
                ]
            ))
        overridedict = dict()
        for lowername, (name, args, ftype) in self.options['filteroverrides'].iteritems():
            overridedict[lowername] = args, styleList[ftype], name, None
            if ftype == 2:
                shortname = self.GetPluginFunctionShortName(lowername)
                if lowername not in self.plugin_shortnames[shortname]:
                    self.plugin_shortnames[shortname].append(lowername)
        self.avsfilterdict.update(overridedict)
        # Add short plugin names to avsfilterdict.  Priority rules:
        #   1. no excluded from autocomplete > excluded
        #   2. don't override user script functions
        #   3. autoloaded > filterdb > added by the user
        #   4.1 AviSynth lookup order (autoloaded)
        #   4.2 alphabetical (filterdb)
        #   4.3 undefined (added by the user)
        for shortname, long_name_list in self.plugin_shortnames.items():
            if shortname in self.avsfilterdict and self.avsfilterdict[shortname][1] == styleList[3]:
                if shortname not in self.options['filterremoved']:
                    continue
                user_function = True
            else:
                user_function = False
            for index, long_name in enumerate(long_name_list):
                if long_name not in self.options['filterremoved'] and \
                        self.options['autocompletepluginnames'].get(long_name) != 1:
                    break
            else:
                if user_function:
                    continue
                long_name = long_name_list[0]
            args, styletype, name = self.avsfilterdict[long_name][:3]
            self.avsfilterdict[shortname] = args, styletype, self.GetPluginFunctionShortName(name), long_name
        # Remove unchecked items from autocompletion, delete long and short names as required
        avsfilterdict_autocomplete = self.avsfilterdict.copy()
        for lowername, (args, styletype, name, is_short) in self.avsfilterdict.iteritems():
            if styletype == styleList[2]:
                if is_short:
                    if self.options['autocompletepluginnames'].get(is_short) == 1:
                        del avsfilterdict_autocomplete[lowername]
                else:
                    self.options['autocompletepluginnames'].setdefault(lowername, 0)
                    if self.options['autocompletepluginnames'][lowername] == 2 or \
                            lowername in self.options['filterremoved']:
                        del avsfilterdict_autocomplete[lowername]
            elif lowername in self.options['filterremoved']:
                del avsfilterdict_autocomplete[lowername]
        self.avsazdict = self.GetAutocompleteDict(avsfilterdict_autocomplete)
        self.avsazdict_all = self.GetAutocompleteDict(self.avsfilterdict)
        self.avssingleletters = [
            s for s in (self.avsfilterdict.keys()+self.avskeywords+self.avsmiscwords)
            if (len(s) == 1 and not s.isalnum() and s != '_')
        ]

    def GetPluginFunctionShortName(self, long_name):
        """Return the short name from a plugin function's mangled name"""
        for dllname in sorted(self.dllnameunderscored, reverse=True):
            if long_name.lower().startswith(dllname):
                return long_name[len(dllname)+1:]
        splitname = long_name.split('_', 1)
        if len(splitname) == 2:
            return splitname[1]
        return ''

    @staticmethod
    def GetAutocompleteDict(filter_dict):
        """Create a list for each letter (for autocompletion)"""
        avsazdict = collections.defaultdict(list)
        for lowername in sorted(filter_dict.keys()):
            first_letter = lowername[0]
            if first_letter.isalpha() or first_letter != '_':
                for char in lowername:
                    if not char.isalnum() and char != '_':
                        break
                else:
                    avsazdict[first_letter].append(filter_dict[lowername][2])
        return avsazdict

    def getFilterInfoFromAvisynth(self):
        self.avisynthVersion = (None,) * 3
        self.installed_plugins = set()
        self.installed_plugins_filternames = set()
        self.installed_avsi_filternames = set()
        self.dllnameunderscored = set()
        # get version info
        try:
            env = avisynth.AVS_ScriptEnvironment(3)
        except OSError:
            error = _('Make sure you have AviSynth installed and that there are no '
                      'unstable plugins or avsi files in the AviSynth plugins directory.')
            error = '\n'.join(textwrap.wrap(error, 70))
        else:
            if hasattr(env, 'get_error'):
                error = env.get_error()
            else:
                error = None
        if error:
            wx.SafeShowMessage(' '.join((self.name, self.version)),
                              '\n\n'.join((_('Error loading AviSynth!'), error)))
            sys.exit(0)
        self.avisynthVersion = (env.invoke('VersionString'),
                                env.invoke('VersionNumber'),
                                env.invoke('Version').get_version())

        # GPo, for frame properties minimum version 3.71 is required
        avs371up = utils.CheckAvisynthVersion371(env, self.avisynthVersion[0])
        self.options['can_read_avisynth_props'] = avs371up
        if not avs371up:
            try:
                if not env.check_version(6):
                    raise
            except:
                wx.SafeShowMessage(' '.join((self.name, self.version)),
                    '\n\n'.join((_('Error loading AviSynth!'), 'Minimum AviSynth+ header verion 6 is required')))
                sys.exit(0)

        # retrieve existing filters (internal filters, autoloaded plugins and avsi files)
        self.avisynth_p = env.function_exists('AutoloadPlugins') # AviSynth+
        if self.avisynth_p:
            try:
                env.invoke('AutoloadPlugins')
            except avisynth.AvisynthError:
                pass
        # internal filters
        try:
            intfunc = env.get_var("$InternalFunctions$")
        except avisynth.AvisynthError as err:
            if str(err) != "NotFound": raise
            funclist = []
        else:
            funclist = [(name, 0) for name in intfunc.split()]
        # autoladed plugins
        try:
            pluginfunc = env.get_var("$PluginFunctions$")
        except avisynth.AvisynthError as err:
            if str(err) != "NotFound": raise
        else:
            pluginfuncList = []
            baddllnameList = []
            short_name = None
            #error_shown = False

            for name in pluginfunc.split():
                if short_name is None:
                    short_name = name
                    continue

                long_name = name
                pos = long_name.find('_' + short_name)
                if pos == -1:
                    if self.options['dllfuncparseerror']:
                        #if not error_shown:
                            #error_shown = True
                            #wx.SafeShowMessage(' '.join((self.name, self.version)),'Error parsing plugin string at function "%s"' % long_name)
                        print>>sys.stderr, 'Error parsing plugin string at function "%s"\n' % long_name
                    short_name = None
                    continue # GPo, We don't stop, we load all other functions

                dllname = long_name[:pos]

                if not dllname.strip():
                    if self.options['dllfuncparseerror']:
                        #if not error_shown:
                            #error_shown = True
                            #wx.SafeShowMessage(' '.join((self.name, self.version)),'Error parsing function "%s"' % long_name)
                        print>>sys.stderr, 'Error parsing function "%s"\n' % long_name

                    short_name = None
                    continue # GPo, We don't stop, we load all other functions

                self.installed_plugins.add(dllname)

                if dllname in baddllnameList:
                    pass
                elif not dllname[0].isalpha() and dllname[0] != '_':
                    baddllnameList.append(dllname)
                else:
                    for char in dllname:
                        if not char.isalnum() and char != '_':
                            baddllnameList.append(dllname)
                            break
                if self.options['autoloadedplugins']:
                    pluginfuncList.append((long_name, 2))
                    self.plugin_shortnames[short_name.lower()].append(long_name.lower())

                self.installed_plugins_filternames.add(long_name.lower())
                if dllname.count('_'):
                    self.dllnameunderscored.add(dllname.lower())
                short_name = None
            if self.options['autoloadedplugins']:
                funclist += pluginfuncList
            if baddllnameList and self.options['dllnamewarning']:
                self.IdleCall.append((self.ShowWarningOnBadNaming, (baddllnameList, ), {}))

        # autoloaded avsi files
        try:
            userfunc = env.get_var("$UserFunctions$")
        except avisynth.AvisynthError as err:
            if str(err) != "NotFound": raise
        else:
            userfuncList = []
            for name in userfunc.split():
                self.installed_avsi_filternames.add(name.lower())
                userfuncList.append((name, 3))
            if self.options['autoloadedavsi']:
                funclist += userfuncList

        # get parameter info for each filter
        typeDict = {
            'c': 'clip',
            'i': 'int',
            'f': 'float',
            'b': 'bool',
            's': 'string',
            'n': 'func',        # GPo Avisynth_Neo or >= v3.52
            'a': 'array',
            '.': 'var',
            #~ '*': '[...]',
        }
        functionDict = {}
        for name, functionType in funclist:
            if name.strip() == '':
                continue
            try:
                t = env.get_var("$Plugin!"+name+"!Param$")
            except avisynth.AvisynthError as err:
                if str(err) != "NotFound": raise
            else:
                argList = []
                namedarg = False
                namedargname = []
                for i, c in enumerate(t):
                    if c == '[':
                        namedarg = True
                    elif c == ']':
                        namedarg = False
                    elif namedarg:
                        namedargname.append(c)
                    else:
                        namedargindex = len(argList)
                        if c in ('+', '*'):
                            try:
                                typeDict[t[i-1]] # Helps ensure previous arg is valid
                                argList[-1] += ' [, ...]'
                            except (IndexError, KeyError):
                                print>>sys.stderr, (
                                    'Error parsing %s plugin parameters: '
                                    '+ without preceeding argument') % name
                        else:
                            try:
                                typeValue = typeDict[c]
                            except KeyError:
                                print>>sys.stderr, (
                                    'Error parsing %s plugin parameters: '
                                    'unknown character %s') % (name, repr(c))
                                typeValue = '?'
                            argList.append(typeValue)
                        if namedargname:
                            try:
                                argList[namedargindex] += ' "{0}"'.format(''.join(namedargname))
                            except IndexError:
                                print>>sys.stderr, (
                                    'Error parsing %s plugin parameters: '
                                    '[name] without following argument') % name
                                argList.append(''.join(namedargname))
                            namedargname = []
                argstring = '(%s)' % (', '.join(argList))
            if functionType == 0:
                if name.islower():
                    if argstring.startswith('(clip'):
                        functionType = 1
                    else:
                        functionType = 4
                elif argstring == '(clip)':
                    boolIsXXX = len(name) > 2 and name.startswith('Is') and name[2].isupper()
                    boolHasXXX = len(name) > 3 and name.startswith('Has') and name[3].isupper()
                    boolGetXXX = len(name) > 3 and name.startswith('Get') and name[3].isupper()
                    if boolIsXXX or boolHasXXX or boolGetXXX:
                        functionType = 1
            key = name.lower()
            functionDict[key] = (name, argstring, functionType)
        return functionDict

    def ParseAvisynthScript(self, filename='', script_text=None, quiet=False):
        pattern = r'function\s+([^\W_]\w*)\s*\((.*?)\)\s*\{(.+?)\}'
        default = r'default\s*\(\s*%s\s*,\s*(.+?)\s*\)'
        filterInfo, text = [], []
        if script_text is None:
            script_text = self.GetTextFromFile(filename)[0]
        for line in script_text.splitlines():
            line = line.strip().strip('\\')
            if not line.startswith('#'):
                text.append(line)
        text = ' '.join(text)
        matches = re.findall(pattern, text, re.I|re.S)
        for filtername, args, body in matches:
            text = ['(\n']
            varnameDict = {}
            if args.strip():
                for arg in args.split(','):
                    arg = arg.split()
                    if len(arg) == 2:
                        vartype, varname = arg
                    elif len(arg) == 1:
                        sep = arg[0].find('"')
                        vartype = arg[0][:sep]
                        varname = arg[0][sep:]
                    else:
                        return None
                    text += [vartype, ' ', varname]
                    varname = varname.strip('"')
                    pat = default % varname
                    ret = re.search(pat, body, re.I|re.S)
                    if ret:
                        value = ret.group(1)
                        if (vartype in ['string', 'val'] or value.isdigit() or
                            value.lower() in ['true', 'false']):
                            text += ['=', value]
                            varnameDict[varname] = value
                        else:
                            for name in varnameDict:
                                value = value.replace(name, varnameDict[name])
                            try:
                                value = str(eval(value))
                            except:
                                if not quiet:
                                    print (_('Error'), 'ParseAvisynthScript() try eval(%s)' % value)
                            else:
                                text += ['=', value]
                                varnameDict[varname] = value
                    text.append(',\n')
            if text[-1] == ',\n':
                text[-1] = '\n'
            text.append(')')
            filterargs = ''.join(text)
            filterInfo.append((filename, filtername, filterargs, 3))
        return filterInfo

    def wrapFilterCalltip(self, txt, maxchars=80):
        if txt.count('\n') > 0:
            return txt
        args = txt.split(',')
        argList = []
        count = 0
        lastArg = len(args) - 1
        for i, arg in enumerate(args):
            arg = arg.strip()
            if i != lastArg: #not arg.endswith(')'):
                arg += ', '
            count += len(arg)
            if count <= maxchars:
                argList.append(arg)
            else:
                argList.append('\n'+arg)
                count = len(arg)
        return ''.join(argList)

    """ test
    def wrapFilterCalltip(self, txt, maxchars=80):
        if (txt.count('\n') > 0) and (txt.Find('>next') < 0):
            return txt
        args = txt.split(',')
        argList = []
        count = 0
        lastArg = len(args) - 1
        for i, arg in enumerate(args):
            arg = arg.strip()
            if arg.startswith('>next'):
                argList.append('\n' + 'Alternative:')
                argList.append('\n')
                count = 0
                continue
            if i != lastArg: #not arg.endswith(')'):
                arg += ', '
            count += len(arg)
            if count <= maxchars:
                argList.append(arg)
            else:
                argList.append('\n'+arg)
                count = len(arg)
        return ''.join(argList)
    """
    def getOptionsDpiDlgInfo(self):
        return (
            (_('DPI'),
                ((_('Main tabs*'), wxp.OPT_ELEM_SPIN, 'ppiscalingscripttabs', _('Additional adjust the script window tabs (10 % steps)'), dict(min_val=-2, val=0, max_val=10) ),
                 (_('Video controls*'), wxp.OPT_ELEM_SPIN, 'ppiscalingvideocontrols', _('Additional adjust the video controls (10 % steps)'), dict(min_val=-2, val=0, max_val=10) ),),
                ((_('Statusbar* '), wxp.OPT_ELEM_SPIN, 'ppiscalingstatusbar', _('Additional adjust the statusbar (10 % steps)'), dict(min_val=-2, val=0, max_val=10) ),
                 (_('Slider window* '), wxp.OPT_ELEM_SPIN, 'ppiscalingsliderwindow', _('Additional adjust the slider window font (10 % steps)'), dict(min_val=-2, val=0, max_val=10) ),),
            ),
        )

    def getOptionsDlgInfo(self):
        plugtxt = 'Plugins directory 64 bit:' if self.x86_64 else 'Plugins directory 32 bit:'
        return (
            (_('Paths'),
                ((_('Available variables: %programdir%, %avisynthdir%, %pluginsdir%'), wxp.OPT_ELEM_SEP, None, '', dict(width=0, expand=False) ), ),
                ((_('Use a custom AviSynth directory')+' *', wxp.OPT_ELEM_CHECK, 'usealtdir', _('Choose a different version than the installed'), dict() ), ),
                ((_('Custom AviSynth directory:')+' *', wxp.OPT_ELEM_DIR, 'altdir', _('Alternative location of avisynth.dll/avxsynth.so'), dict(buttonText='...', buttonWidth=30) ), ),
                ((_(plugtxt), wxp.OPT_ELEM_DIR, 'pluginsdir', _('Leave blank for reset or choose a directory for manually set or for register'), dict(buttonText='...', buttonWidth=30) ), ),
                ((_('Disable autoload, set manually')+' *', wxp.OPT_ELEM_CHECK, 'customplugindir', _('If plugins autoload fails set the path manually. Read only. Only for proper program functions'), dict(ident=20) ),
                 (_('Register the plugins directory')+' *', wxp.OPT_ELEM_CHECK, 'plugindirregister', _('This changes the plugins directory for Avisynth itself. On Windows Registry values in HKLM are changed.'), dict() ), ),
                ((_('Use a custom working directory'), wxp.OPT_ELEM_CHECK, 'useworkdir', _('Override the current working directory'), dict() ),
                 (_('For all scripts'), wxp.OPT_ELEM_CHECK, 'alwaysworkdir', _("Use the custom directory also for scripts saved to file, instead of its parent"), dict() ), ),
                ((_('Working directory:'), wxp.OPT_ELEM_DIR, 'workdir', _('Specify an alternative working directory'), dict(buttonText='...', buttonWidth=30) ), ),
                ((_('External player:'), wxp.OPT_ELEM_FILE, 'externalplayer', _('Location of external program for script playback'), dict(fileMask=(_('Executable files') + ' (*.exe)|*.exe|' if os.name == 'nt' else '') + _('All files') + ' (*.*)|*.*', buttonText='...', buttonWidth=30) ), ),
                ((_('External player extra args:'), wxp.OPT_ELEM_STRING, 'externalplayerargs', _('Additional arguments when running the external player'), dict() ), ),
                ((_('External tool:'), wxp.OPT_ELEM_FILE, 'externaltool', _('Location of external program, e.g. AvsMeter'), dict(fileMask=(_('Executable files') + ' (*.exe)|*.exe|' if os.name == 'nt' else '') + _('All files') + ' (*.*)|*.*', buttonText='...', buttonWidth=30) ), ),
                ((_('External tool arg1:'), wxp.OPT_ELEM_STRING, 'externaltoolarg1', _('Arguments for external tool menu 1, e.g. Menu label|arguments\nUse %fn to pass the script file name with the arguments.' ), dict() ),
                 (_('External tool arg2:'), wxp.OPT_ELEM_STRING, 'externaltoolarg2', _('Arguments for external tool menu 2, e.g. Menu label|arguments\nUse %fn to pass the script file name with the arguments.' ), dict() ), ),
                ((_('Avisynth help file/url:'), wxp.OPT_ELEM_FILE_URL, 'avisynthhelpfile', _('Location of the avisynth help file or url'), dict(buttonText='...', buttonWidth=30) ), ),
                ((_('Documentation search paths:'), wxp.OPT_ELEM_STRING, 'docsearchpaths', _('Specify which directories to search for docs when you click on a filter calltip'), dict() ), ),
                ((_('Documentation search url:'), wxp.OPT_ELEM_STRING, 'docsearchurl', _("The web address to search if docs aren't found (the filter's name replaces %filtername%)"), dict() ), ),
            ),
            (_('Text'),
                ((_('Style inside triple-quoted strings'), wxp.OPT_ELEM_CHECK, 'syntaxhighlight_styleinsidetriplequotes', _("Highlight the text as if it wasn't enclosed by triple quotes"), dict() ), ),
                ((_('Prefer functions over variables'), wxp.OPT_ELEM_CHECK, 'syntaxhighlight_preferfunctions', _('When a word could be either a function or a variable, highlight it as function'), dict() ), ),
                ((_('Wrap text'), wxp.OPT_ELEM_CHECK, 'wrap', _("Don't allow lines wider than the window"), dict() ), ),
                ((_('Draw lines at fold points'), wxp.OPT_ELEM_CHECK, 'foldflag', _('For code folding, draw a line underneath if the fold point is not expanded'), dict() ), ),
                ((_('Use tabs instead of spaces'), wxp.OPT_ELEM_CHECK, 'usetabs', _('Check to insert actual tabs instead of spaces when using the Tab key'), dict() ), ),
                ((_('Tab width'), wxp.OPT_ELEM_SPIN, 'tabwidth', _('Set the size of the tabs in spaces'), dict(min_val=0) ), ),
                ((_('Line margin width'), wxp.OPT_ELEM_SPIN, 'numlinechars', _('Initial space to reserve for the line margin in terms of number of digits. Set it to 0 to disable showing line numbers'), dict(min_val=0) ), ),
                ((_('Show filter calltips'), wxp.OPT_ELEM_CHECK, 'calltips', _('Turn on/off automatic tips when typing filter names'), dict() ), ),
                ((_('Frequent calltips'), wxp.OPT_ELEM_CHECK, 'frequentcalltips', _("Always show calltips any time the cursor is within the filter's arguments"), dict(ident=20) ), ),
                ((_('Show autocomplete on capital letters'), wxp.OPT_ELEM_CHECK, 'autocomplete', _('Turn on/off automatic autocomplete list when typing words starting with capital letters'), dict() ), ),
                (('       '+_('Amount of letters typed'), wxp.OPT_ELEM_SPIN, 'autocompletelength', _('Show autocomplete list when typing a certain amount of letters'), dict(min_val=0) ), ),
                ((_('Min text lines on video preview'), wxp.OPT_ELEM_SPIN, 'mintextlines', _('Minimum number of lines to show when displaying the video preview'), dict(min_val=0) ), ),
                ((_('Mouse wheel scroll rate in editor (0 disabled)'), wxp.OPT_ELEM_SPIN, 'scriptwindowbindmousewheel', _('If the mouse wheel does not work in the editor\nor you want another scroll rate. 1 to 6 lines to scroll, Ctrl doubles the rate'), dict(min_val=0, max_val=6)  ), ),
            ),
            (_('Autocomplete'),
                ((_('AviSynth user function database'), wxp.OPT_ELEM_SEP, '', _('Select what functions beside internal and user-defined will be included in the database'), dict(adjust_width=True) ), ),
                ((_('Autoloaded plugin functions')+' *', wxp.OPT_ELEM_CHECK, 'autoloadedplugins', _('Include the functions on autoloaded plugins in the database'), dict() ),
                 (_('Autoloaded script functions')+' *', wxp.OPT_ELEM_CHECK, 'autoloadedavsi', _('Include the functions on autoloaded avsi files in the database'), dict() ), ),
                ((_('Plugin functions from database')+' *', wxp.OPT_ELEM_CHECK, 'fdb_plugins', _("Include plugin functions from the program's database"), dict() ),
                 (_('Script functions from database')+' *', wxp.OPT_ELEM_CHECK, 'fdb_userscriptfunctions', _("Include user script functions from the program's database"), dict() ), ),
                ((_('Autocomplete'), wxp.OPT_ELEM_SEP, '', '', dict(adjust_width=True) ), ),
                ((_('Show autocomplete with variables'), wxp.OPT_ELEM_CHECK, 'autocompletevariables', _('Add user defined variables into autocomplete list'), dict() ), ),
                ((_('Show autocomplete on single matched lowercase variable'), wxp.OPT_ELEM_CHECK, 'autocompletesingle', _('When typing a lowercase variable name, show autocomplete if there is only one item matched in keyword list'), dict(ident=20) ), ),
                ((_('Show autocomplete with icons'), wxp.OPT_ELEM_CHECK, 'autocompleteicons', _("Add icons into autocomplete list. Using different type to indicate how well a filter's presets is defined"), dict() ), ),
                ((_("Don't show autocomplete when calltip is active"), wxp.OPT_ELEM_CHECK, 'calltipsoverautocomplete', _('When calltip is active, autocomplete will not be activate automatically. You can still show autocomplete manually'), dict() ), ),
                ((_('Autoparentheses level'), wxp.OPT_ELEM_RADIO, 'autoparentheses', _('Determines parentheses to insert upon autocompletion'), dict(choices=[(_('None " "'), 0),(_('Open "("'), 1),(_('Close "()"'), 2)])), ),
                ((_('Preset activation key'), wxp.OPT_ELEM_RADIO, 'presetactivatekey', _('Determines which key activates the filter preset when the autocomplete box is visible'), dict(choices=[(_('Tab'), 'tab'),(_('Return'), 'return'),(_('Both'), 'both'),(_('None'), 'none')]) ), ),
            ),
            (_('Video'),
                ((_('Constantly update video while dragging'), wxp.OPT_ELEM_CHECK, 'dragupdate', _('Update the video constantly when dragging the frame slider'), dict() ), ),
                ((_('Enable line-by-line update'), wxp.OPT_ELEM_CHECK, 'autoupdatevideo', _('Enable the line-by-line video update mode (update every time the cursor changes line position)'), dict() ), ),
                ((_('Focus the video preview upon refresh'), wxp.OPT_ELEM_CHECK, 'focusonrefresh', _('Switch focus to the video preview window when using the refresh command'), dict() ), ),
                ((_('Refresh preview automatically'), wxp.OPT_ELEM_CHECK, 'refreshpreview', _('Refresh preview when switch focus on video window'), dict() ), ),
                ((_('Move video slider to timeline start'), wxp.OPT_ELEM_CHECK, 'timelinemoveslidertostart', _('On Timeline moving with Ctrl + Alt + (limited range Left/Right or unlimited range PageUp/PageDown)'), dict() ), ),
                ((_('Shared timeline'), wxp.OPT_ELEM_CHECK, 'enableframepertab', _('Seeking to a certain frame will seek to that frame on all tabs'), dict() ), ),
                ((_('Only on tabs of the same characteristics'), wxp.OPT_ELEM_CHECK, 'enableframepertab_same', _('Only share timeline for clips with the same resolution and frame count'), dict(ident=20) ), ),
                ((_('Mouse wheel function'), wxp.OPT_ELEM_LIST, 'mousewheelfunc', _('Determines which mouse wheel function is used, see below tabs.Tab change also possible under Misc -> Mouse browse buttons'), dict(choices=[(_('Frame step'), 'frame_step'), (_('Tab change'), 'tab_change'), (_('Tab change or scroll'), 'tab_change_or_scroll'),]) ), ),
                ((_('Enable scroll wheel through similar tabs'), wxp.OPT_ELEM_CHECK, 'enabletabscrolling', _('Mouse scroll wheel cycles through tabs with similar videos'), dict() ), ),
                ((_('Enable scroll wheel through tabs on the same group'), wxp.OPT_ELEM_CHECK, 'enabletabscrolling_groups', _('Mouse scroll wheel cycles through tabs assigned to the same tab group'), dict() ), ),
                ((_('Separate video preview window')+' *', wxp.OPT_ELEM_CHECK, 'separatevideowindow', _('Use a separate window for the video preview'), dict() ), ),
                ((_('Keep it on top of the main window')+' *', wxp.OPT_ELEM_CHECK, 'previewontopofmain', _('Keep the video preview window always on top of the main one and link its visibility'), dict(ident=20) ), ),
                ((_('Startup with last zoom settings'), wxp.OPT_ELEM_CHECK, 'startupwithlastzoom', _('Use last zoom settings at startup'), dict() ), ),
                ((_('Display default YUV -> RGB conversion'), wxp.OPT_ELEM_LIST, 'defaultmatrix', _('Conversions default for a new script\nAuto = Resolution based'), dict(choices=[(_('Auto tv'), 'auto,tv'), (_('Rec.709'), '709,tv'), (_('Rec.601'), '601,tv'), (_('Auto pc'), 'auto,pc'), (_('PC.709'), '709,pc'), (_('PC.601'), '601,pc')]) ), ),
                # 0= show tabs always, 1= hide tabs only if row count > 1, 2= hide if fullscreen else 0, 3= hide if fullscreen else 1,  4= hide always
                ((_('Tab behave in Fullsize/Fullscreen mode'), wxp.OPT_ELEM_LIST, 'fullscreenmode', _('Show or hide the tabs on Fullscreen or Fullsize mode\nDouble click on preview is Fullsize\nPress Ctrl on double click is Fullscreen\nIf multiline tab style then row count can be greater then 1'), \
                    dict(choices=[(_('(1) Show tabs always'), 0), (_('(2) Hide if row count greater 1'), 1), (_('(3) Hide if fullscreen else (1)'), 2), (_('(4) Hide if fullscreen else (2)'), 3), (_('(5) Hide tabs always'), 4),]) ), ),
                ((_('Customize video status bar...'), wxp.OPT_ELEM_BUTTON, 'videostatusbarinfo', _('Customize the video information shown in the program status bar'), dict(handler=self.OnConfigureVideoStatusBarMessage) ), ),
                ((_('Error message font...'), wxp.OPT_ELEM_BUTTON, 'errormessagefont', _('Set the font used for displaying the error if evaluating the script fails'), dict(handler=self.OnConfigureErrorFont) ), ),
            ),
            (_('User Sliders'),
                ((_('Hide slider window by default'), wxp.OPT_ELEM_CHECK, 'keepsliderwindowhidden', _('Keep the slider window hidden by default when previewing a video'), dict() ), ),
                ((_('Create user sliders automatically'), wxp.OPT_ELEM_CHECK, 'autoslideron', _('Create user sliders automatically using the filter database'), dict() ), ),
                ((_('type int/float (numerical slider)'), wxp.OPT_ELEM_CHECK, 'autoslidermakeintfloat', _('Create user sliders for int and float arguments'), dict(ident=20) ), ),
                ((_('type int (list)'), wxp.OPT_ELEM_CHECK, 'autoslidermakeintlist', _('Create listboxes for int list arguments'), dict(ident=20) ), ),
                ((_('type int (hex color)'), wxp.OPT_ELEM_CHECK, 'autoslidermakecolor', _('Create color pickers for hex color arguments'), dict(ident=20) ), ),
                ((_('type bool'), wxp.OPT_ELEM_CHECK, 'autoslidermakebool', _('Create radio boxes for bool arguments'), dict(ident=20) ), ),
                ((_('type string (list)'), wxp.OPT_ELEM_CHECK, 'autoslidermakestringlist', _('Create listboxes for string list arguments'), dict(ident=20) ), ),
                ((_('type string (filename)'), wxp.OPT_ELEM_CHECK, 'autoslidermakestringfilename', _('Create filename pickers for string filename arguments'), dict(ident=20) ), ),
                ((_('undocumented'), wxp.OPT_ELEM_CHECK, 'autoslidermakeunknown', _('Create placeholders for arguments which have no database information'), dict(ident=20) ), ),
                ((_('Disable refresh as default'), wxp.OPT_ELEM_CHECK, 'sliderdisablerefresh', _('Do not reinitialize the clip every time a slider is changed. Can be changed in the slider window'), dict() ), ),
                ((_('Button show/hide applies to all tabs'), wxp.OPT_ELEM_CHECK, 'allsliderwindowshideshow', _('Or press Ctrl when you click the button.'), dict() ), ),
                ((_('Hide slider window toggle tag menus*'), wxp.OPT_ELEM_CHECK, 'sliderhidetagmenu', _('Hide the toggle tag menus in the context menu of the sliders'), dict() ), ),
                ((_('Enable slider window custom color theme'), wxp.OPT_ELEM_CHECK, 'sliderwindowcustomtheme', _("Custom colors can be set under 'Options->Font and colors->Advanced 2'\nNot visible slider windows needed refresh."), dict() ), ),
                ((_('Fold startup setting'), wxp.OPT_ELEM_RADIO, 'autosliderstartfold', _('Determines which filters will initially have hidden arguments in the slider window'), dict(dimensions=2, choices=[(_('Fold all'), 0),(_('Fold none'), 1), (_('Fold non-numbers'), 2), (_('Fold or restore last status'), 3) ]) ), ),
                ((_('Filter exclusion list'), wxp.OPT_ELEM_STRING, 'autosliderexclusions', _('Specify filters never to build automatic sliders for. Use a space as separator.\nYou can toggle it in the slider context menu.'), dict() ), ),
            ),
            (_('Save/Load'),
                ((_('Save session for next launch'), wxp.OPT_ELEM_CHECK, 'startupsession', _('Automatically save the session on shutdown and load on next startup'), dict() ), ),
                ((_('Always load startup session'), wxp.OPT_ELEM_CHECK, 'alwaysloadstartupsession', _('Always load the auto-saved session before opening any other file on startup'), dict() ), ),
                ((_("Don't preview when loading a session"), wxp.OPT_ELEM_CHECK, 'hidepreview', _('Always hide the video preview window when loading a session'), dict() ), ),
                ((_('Backup session at startup (max. count)'), wxp.OPT_ELEM_SPIN, 'sessionbackupcount', _("Backup the last session on every start with timestamp name\nOne backup '_last_session_backup' is always created"), dict(min_val=0, max_val=99) ),
                 (_('Backup session periodically (minutes)'), wxp.OPT_ELEM_SPIN, 'periodicbackup', _('Backup the session every X minutes, if X > 0'), dict(min_val=0) ), ),
                ((_('Backup session when previewing'), wxp.OPT_ELEM_CHECK, 'paranoiamode', _('If checked, the current session is backed up prior to previewing any new script'), dict() ), ),
                ((_('Prompt to save when previewing'), wxp.OPT_ELEM_CHECK, 'promptwhenpreview', _('Prompt to save a script before previewing (inactive if previewing with unsaved changes)'), dict() ), ),
                ((_('Preview scripts with unsaved changes'), wxp.OPT_ELEM_CHECK, 'previewunsavedchanges', _('Create a temporary preview script with unsaved changes when previewing the video'), dict() ), ),
                ((_("When closing tab, don't prompt to save scripts without file"), wxp.OPT_ELEM_CHECK, 'closeneversaved', _("When closing a tab, don't prompt to save the script if it doesn't already exist on the filesystem"), dict() ), ),
                ((_('Prompt to save scripts on program exit'), wxp.OPT_ELEM_CHECK, 'promptexitsave', _('Prompt to save each script with unsaved changes when exiting the program'), dict() ), ),
                ((_('Only with existing script'), wxp.OPT_ELEM_CHECK, 'promptexitsaveonlyexisting', _("When exiting the program, don't prompt to save the script if it doesn't already exist on the filesystem"), dict(ident=20) ), ),   # GPo 2018
                ((_('Line endings'), wxp.OPT_ELEM_LIST, 'eol', _('Auto: CRLF on Windows and LF on *nix for new scripts, existing scripts keep their current line endings'), dict(choices=[(_('Auto'), 'auto'), (_('Force CRLF'), 'force crlf'), (_('Force LF'), 'force lf')]) ), ),
                ((_('Save or read avs scripts with AvsPmod markings'), wxp.OPT_ELEM_CHECK, 'savemarkedavs', _('Save and read AvsPmod-specific markings (user sliders, toggle tags, etc) as a commented section in the *.avs file'), dict() ), ),
                ((_('Save toggle tags within the script ( read the hint! )'), wxp.OPT_ELEM_CHECK, 'savetoggletags', _('Do not remove toggle tags and disabled filters.\nCan make the saved script unreadable for other programs if You not use #> in front of the toggle tag: #>[sharp=0]'), dict() ), ),
                ((_('Start dialogs on the last used directory'), wxp.OPT_ELEM_CHECK, 'userecentdir', _("If unchecked, the script's directory is used"), dict() ), ),
                ((_('Start save image dialogs on the last used directory'), wxp.OPT_ELEM_CHECK, 'useimagesavedir', _("If unchecked, the script's directory is used"), dict() ), ),
                ((_('Default image filename pattern'), wxp.OPT_ELEM_STRING, 'imagenamedefaultformat', _("Choose a default pattern for image filenames. %s -> script title, %06d -> frame number padded to six digits"), dict() ), ),
                ((_('Ask for JPEG quality'), wxp.OPT_ELEM_CHECK, 'askjpegquality', _("When saving a JPEG image, prompt for the quality level. Use the value from the last time if not checked"), dict() ), ),
            ),
            (_('Misc'),
                ((_('Language')+' *', wxp.OPT_ELEM_LIST, 'lang', _('Choose the language used for the interface'), dict(choices=self.getTranslations()) ), ),
                ((_('Use keyboard images in tabs'), wxp.OPT_ELEM_CHECK, 'usetabimages', _('Show keyboard images in the script tabs when video has focus'), dict() ), ),
                ((_('Show tabs in multiline style'), wxp.OPT_ELEM_CHECK, 'multilinetab', _('There can be several rows of tabs'), dict() ), ),
                ((_('Show tabs in fixed width'), wxp.OPT_ELEM_CHECK, 'fixedwidthtab', _('All tabs will have same width'), dict() ), ),
                ((_('Invert scroll wheel direction (Tabs, Zoom)'), wxp.OPT_ELEM_CHECK, 'invertscrolling', _('Scroll the mouse wheel up for changing tabs to the right'), dict() ), ),
                ((_('Invert scroll wheel direction (Frame)'), wxp.OPT_ELEM_CHECK, 'invertframescrolling', _('Invert wheel direction for frames step'), dict() ), ),   # GPo 2018
                ((_('Load bookmarks from script'), wxp.OPT_ELEM_CHECK, 'bookmarksfromscript', _('Automatically load bookmarks from script'), dict() ), ),
                ((_('Tab change loads bookmarks from script or tab *'), wxp.OPT_ELEM_CHECK, 'tabsbookmarksfromscript', _('Automatically load bookmarks from script or tab if tab changed'), dict() ), ),
                ((_('Warning tab bookmarks different'), wxp.OPT_ELEM_CHECK, 'warnscriptbookmarksdif', _('Warn if tab bookmarks and from script reading bookmarks different.'), dict(ident=20) ), ),
                ((_('Only allow a single instance of AvsPmod')+' *', wxp.OPT_ELEM_CHECK, 'singleinstance', _('Only allow a single instance of AvsPmod'), dict() ), ),
                ((_('Show warning for bad plugin naming at startup'), wxp.OPT_ELEM_CHECK, 'dllnamewarning', _('Show warning at startup if there are dlls with bad naming in default plugin folder'), dict() ), ),
                ((_('Show warning for plugin functions parse errors'), wxp.OPT_ELEM_CHECK, 'dllfuncparseerror', _('Show warning at startup if there are plugin functions parse errors in default plugin folder'), dict() ), ),
                ((_('Show shortcuts in context menus*'), wxp.OPT_ELEM_CHECK, 'contextshowshortcuts', _('Show or hide the context menus shortcuts (video, script)'), dict() ), ),
                ((_('Show video control buttons tooltips'), wxp.OPT_ELEM_CHECK, 'showbuttontooltip', _('Show or hide the video control buttons tooltips'), dict() ), ),
                ((_('Mouse browse buttons'), wxp.OPT_ELEM_LIST, 'mouseauxdown', _("Mouse browse buttons (forward/backward) on video and script window\nIf 'Tab change' and tab count less than 2, 'Bookmark jump' is used\nIf 'Tab change' press CTRL or left mouse and 'Bookmark jump' is used\nIf 'Bookmark jump', vice versa"),dict(choices=[(_('Tab change'),'tab change'),(_('Custom jump'),'custom jump'),(_('Bookmark jump'),'bookmark jump'),(_('Frame step'),'frame step')]) ), # GPo 2020
                 (_('Middle mouse on script'), wxp.OPT_ELEM_LIST, 'middlemousefunc', _('Middle mouse button behavior on the script, if script empty open source is used'), dict(choices=[(_('Show video frame'), 'show video frame'), (_('Open source'), 'open source')]) ), ), # GPo 2020
                ((_('Max number of recent filenames'), wxp.OPT_ELEM_SPIN, 'nrecentfiles', _('This number determines how many filenames to store in the recent files menu'), dict(min_val=0) ), ),
                ((_('Custom jump size:'), wxp.OPT_ELEM_SPIN, 'customjump', _('Jump size used in video menu'), dict(min_val=0) ), ),
                ((_('Custom jump size units'), wxp.OPT_ELEM_RADIO, 'customjumpunits', _('Units of custom jump size'), dict(choices=[(_('frames'), 'frames'),(_('seconds'), 'sec'),(_('minutes'), 'min'),(_('hours'), 'hr')]) ), ),
            ),
            (_('Misc 2'),
                ((_('DPI settings*'), wxp.OPT_ELEM_BUTTON, '','', dict(handler=self.ShowDpiOptions) ), ),
                (('', wxp.OPT_ELEM_SEP, '', '', dict(adjust_width=False) ), ),
                ((_('Timeline move sensitivity on the statusbar'), wxp.OPT_ELEM_SPIN, 'timelinestatusbarmovesense', _('Sets the sensitivity of the mouse movement in the status bar, for timeline range move (with or without Shift), lower value more movement'), dict(min_val=5, max_val=300, increment=5) ), ),
                ((_('Timeline range numbers count'), wxp.OPT_ELEM_LIST, 'timelinenumdivisor', _('How many additional numbers should be displayed in the timeline when a range has been set'), dict(choices=[(_('1 number'), 2),(_('4 numbers'), 5), (_('9 numbers'), 10),]) ), ),
                ((_('Show available system memory (0 disabled)'), wxp.OPT_ELEM_SPIN, 'showfreememory', _('After creating a new clip, show available memory in the status bar if memory is less than x MB'), dict(min_val=0, max_val=9000, increment=100) ), ),
                ((_('Show memory information in thread progress dialog'), wxp.OPT_ELEM_CHECK, 'threaddlgshowmem', _('Shows the available system memory in the thread progress dialog'), dict() ), ),
                ((_('Delay before thread progress dialog appears'), wxp.OPT_ELEM_SPIN, 'progressdelaytime', _('If accessing Avisynth in threads enabled, this setting determines the delay in seconds before the dialog appears. Can be double (clip, frame)'), dict(min_val=10, max_val=360) ), ),
                ((_('Thread progress dialog behave'), wxp.OPT_ELEM_LIST, 'threadprogressopt', _('Select the progress dialog behave for loading Avisynth in threads. First entry is the old behave, you can minimize the program with the windows button'), \
                    dict(choices=[(_('Show progress, (program no response)'),0), (_('Show progress (Shift hide program)'), 1), (_('Hide progress (Ctrl do show, Shift hide program)'), 2),]) ), ),
                ((_('Show frame properties*'), wxp.OPT_ELEM_LIST, 'propwindowparent', _('Place you want show the frame properties'), dict(choices=[(_('Separate window'),0), (_('Slider window top'),1), (_('Slider window bottom'),2)]) ), ),
                ((_('Show resample zoom menu*'), wxp.OPT_ELEM_LIST, 'showresamplemenu', _("Show/hide resample menu in zoom menu.\n!! Read Help > 'Resample filter readme'"), dict(choices=[(_('Hide (disabled)'),0), (_('As Submenu'),1), (_('Normal'),2)]) ), ),
            ),
        )

    def getTranslations(self, return_paths=False):
        '''Return the list of 'translation_lng.py' files within the translations subfolder'''
        if return_paths:
            paths = []
            re_lng = re.compile(r'translation_(\w{3})\.py', re.I)
        else:
            translation_list = set()
            translation_list.add((i18n.display_name('eng'), 'eng'))
            re_lng = re.compile(r'translation_(\w{3})\.py[co]?', re.I)
        if os.path.isdir(self.translations_dir):
            for file in os.listdir(self.translations_dir):
                match = re_lng.match(file)
                if match:
                    if return_paths:
                        paths.append((os.path.join(self.translations_dir, file), match.group(1)))
                    else:
                        translation_list.add((i18n.display_name(match.group(1)), match.group(1)))
        if return_paths:
            return paths
        return sorted(translation_list)

    def setPPIFactor(self):
        global ppi_factor
        ppi_factor = self.ppi_factor
        dpi.ppi_factor = self.ppi_factor
        global_vars.ppi_factor = self.ppi_factor

    # event is left up, but you can use it after the splitter pos has changed to recalc the preview
    def OnMainSplitterPosChanged(self, event=None):
        if event:
            self.SaveLastSplitVideoPos()
        script = self.currentScript
        resize = script.resizeFilter[0] and script.resizeFilter[2] == 1
        if resize:
            if self.splitView:
                self.ResizeFilterUpdateSplitView()
            else:
                script.display_clip_refresh_needed = True
                if script.AVI is not None:
                    script.AVI.SetResizeFilter(self.GetResizeFilterInfo(script))
        if resize or self.zoomwindow or (self.zoomfactor != 1 and self.zoom_antialias):
            self.zoom_antialias = False
            if resize and script.previewFilterIdx > 0:
                self.OnMenuPreviewFilter(index=script.previewFilterIdx, updateUserSliders=False)
            else:
                 self.ShowVideoFrame(forceLayout=True, focus=False)
        self.ResetZoomAntialias()
        if event:
            event.Skip()

    def createWindowElements(self):
        # Create the program's status bar
        statusBar = self.CreateStatusBar(2)
        if self.ppi_factor > 1 or self.options['ppiscalingstatusbar'] != 0:
            i = self.options['ppiscalingstatusbar']
            if i != 0:
                i = float(i / 10.0)
            factor = self.ppi_factor + i
            font = statusBar.GetFont()
            dpi.SetFontSize(font, factor)
            statusBar.SetMinHeight(font.GetPixelSize()[1] + intPPI(4))
            statusBar.SetFont(font)
        statusBar.SetStatusWidths([-1, 0])

        class PartialFormatter(string.Formatter):

            def get_value(self, key, args, kwds):
                try:
                    return string.Formatter.get_value(self, key, args, kwds)
                except KeyError:
                    return '%' + key

        self.status_bar_formatter = PartialFormatter()

        # Create the main subwindows
        if wx.VERSION < (2, 9):
            self.programSplitter = wx.SplitterWindow(self, wx.ID_ANY, style=wx.SP_NOBORDER)
        else:
            self.programSplitter = self

        self.mainSplitter = wx.SplitterWindow(self.programSplitter, wx.ID_ANY, style=wx.SP_3DSASH|wx.SP_NOBORDER|wx.SP_LIVE_UPDATE)

        # wxBug, needed for change slider window parent
        self.tempVideoDialog = wx.Frame(self, wx.ID_ANY,style=wx.FRAME_NO_TASKBAR)
        self.tempVideoDialog.Hide()

        if not self.separatevideowindow:
            parent = self.mainSplitter
        else:
            style=wx.DEFAULT_FRAME_STYLE|wx.WANTS_CHARS
            if self.options['previewontopofmain']:
                style = style|wx.FRAME_FLOAT_ON_PARENT
            if self.options['previewalwaysontop']:
                style = style|wx.STAY_ON_TOP
            self.videoDialog = wx.Frame(self, wx.ID_ANY,style=style)#, style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
            if self.options['previewontopofmain']: # main window loses 'always on top' effect
                self.ToggleWindowStyle(wx.STAY_ON_TOP)
                self.ToggleWindowStyle(wx.STAY_ON_TOP)
            dimensions = self.options.get('dimensions2')
            if dimensions is not None and dimensions[0] > 0 and dimensions[1] > 0:
                self.videoDialog.SetDimensions(*dimensions)
                # Move the window if it's offscreen
                size = self.videoDialog.GetSize()
                pos = self.videoDialog.GetPosition()
                wC, hC = wx.ScreenDC().GetSize()
                if (pos[0]+intPPI(50)>wC) or (pos[1]+intPPI(50)>hC):
                    self.videoDialog.Center()
            self.videoDialog.SetIcon(AvsP_icon.getIcon())
            self.videoDialog.Bind(wx.EVT_CLOSE, self.OnMenuVideoHide)
            parent = self.videoDialog

            # We have already bound an EVT_SIZE event,don't know for what this is ( it never seems to get called )
            self.videoDialog.oldSize = None
            def OnVideoDialogResizeEnd(event):
                if self.zoomwindow:
                    newSize = event.GetSize()
                    oldSize = self.videoDialog.oldSize
                    if oldSize is not None and newSize == oldSize:
                        self.ShowVideoFrame()
                        self.videoDialog.oldSize = None
                    else:
                        self.videoDialog.oldSize = newSize
                event.Skip()
            self.videoDialog.Bind(wx.EVT_SIZING, OnVideoDialogResizeEnd)

        # GPo, only the panel for the toggleSliderWindowButton
        self.videoPane = wx.Panel(parent, wx.ID_ANY)
        if self.options['sliderwindowsidebarcolor']:
            color = self.GetThemeColor('sliderwindowsidebar', 'back')
            if color:
                self.videoPane.SetBackgroundColour(color)
        self.videoSplitter = wx.SplitterWindow(self.videoPane, wx.ID_ANY, style=wx.SP_3DSASH|wx.SP_NOBORDER|wx.SP_LIVE_UPDATE)
        f = self.options['ppiscalingvideocontrols']
        if f != 0:
            f = f/10.0
        factor = max(self.ppi_factor + f, 1)
        w = int(10*factor)
        h = int(50*factor)
        bmpMask = wx.EmptyBitmap(w, h)
        mdc = wx.MemoryDC()
        mdc.SelectObject(bmpMask)
        mdc.DrawPolygon([(int(8*factor),0), (int(2*factor),int(6*factor)), (int(8*factor),int(12*factor))])
        mdc.DrawPolygon([(int(8*factor),int(18*factor)), (int(2*factor),int(24*factor)), (int(8*factor),int(30*factor))])
        mdc.DrawPolygon([(int(8*factor),int(36*factor)), (int(2*factor),int(42*factor)), (int(8*factor),int(48*factor))])
        mdc = None

        bmpShow = wx.EmptyBitmap(w, h)
        bmpShow.SetMask(wx.Mask(bmpMask))
        bmpHide = bmpShow.ConvertToImage().Mirror().ConvertToBitmap()
        self.toggleSliderWindowButton = wxButtons.GenBitmapButton(self.videoPane, wx.ID_ANY, bmpHide, size=(w,h), style=wx.NO_BORDER)
        self.toggleSliderWindowButton.bmpShow = bmpShow
        self.toggleSliderWindowButton.bmpHide = bmpHide
        def OnTSWButtonSize(event):
            dc = wx.WindowDC(self.toggleSliderWindowButton)
            dc.Clear()
            wButton, hButton = self.toggleSliderWindowButton.GetClientSizeTuple()
            self.toggleSliderWindowButton.DrawLabel(dc, wButton, hButton)
            event.Skip()
        self.toggleSliderWindowButton.Bind(wx.EVT_SIZE, OnTSWButtonSize)
        def OnToggleSliderWindowButton(event):
            self.ToggleSliderWindow(vidrefresh=True)
            script = self.currentScript
            script.userHidSliders = not script.sliderWindowShown
            if self.options['allsliderwindowshideshow'] or wx.GetKeyState(wx.WXK_CONTROL):
                shown = script.sliderWindowShown
                for i in range(self.scriptNotebook.GetPageCount()): # GPo, show/hide all
                    script,idx = self.getScriptAtIndex(i)
                    script.sliderWindowShown = shown
                    script.userHidSliders = not shown
            self.videoWindow.SetFocus()
        self.videoPane.Bind(wx.EVT_BUTTON, OnToggleSliderWindowButton, self.toggleSliderWindowButton)
        # GPo, its only the sizer for the toggleSliderWindowButton panel, must not be self
        self.videoPaneSizer = wx.BoxSizer(wx.HORIZONTAL)
        self.videoPaneSizer.Add(self.videoSplitter, 1, wx.EXPAND|wx.ALL, 0)
        self.videoPaneSizer.Add(self.toggleSliderWindowButton, 0, wx.EXPAND|wx.ALL, 0)
        self.videoPane.SetSizer(self.videoPaneSizer)
        self.videoPaneSizer.Layout() # GPo new

        ##### Main splitter is splitter for script\videoWindow #####
        self.mainSplitter.SetSplitMode(wx.SPLIT_HORIZONTAL)
        self.mainSplitter.SetSashSize(intPPI(4))
        self.videoSplitter.SetSashSize(intPPI(4))

        # MainSplitter, splitter for script and videoWindow
        def OnMainSplitterLeftDown(event):
            self.zoom_antialias = False
            if self.FindFocus() == self.titleEntry:
                self.scriptNotebook.SetFocus()
            event.Skip()
        self.mainSplitter.Bind(wx.EVT_LEFT_DOWN, OnMainSplitterLeftDown)

        self.mainSplitter.Bind(wx.EVT_LEFT_UP, self.OnMainSplitterPosChanged)
        self.mainSplitter.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost) # GPo 2020
        self.mainSplitter.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClickWindow)
        self.mainSplitter.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDownWindow)

        # VideoSplitter, splitter for sliderWindow and videoWindow
        def OnVideoSplitterPosChanged(event):
            #sliderWindowWidth = self.videoSplitter.GetClientSize()[0] - self.videoSplitter.GetSashPosition()
            if True:
                newpos = self.videoSplitter.GetSashPosition() - self.videoSplitter.GetClientSize()[0]
                self.currentScript.lastSplitSliderPos = newpos
                self.currentScript.sliderWindowShown = True
            else:
                self.currentScript.sliderWindowShown = False
            self.SaveLastSplitVideoPos()
            script = self.currentScript
            resize = script.resizeFilter[0] and script.resizeFilter[2] == 1 and not script.resizeFilter[3]
            if resize:
                if self.splitView:
                    self.ResizeFilterUpdateSplitView()
                else:
                    script.display_clip_refresh_needed = True
                    if script.AVI is not None:
                        script.AVI.SetResizeFilter(self.GetResizeFilterInfo(script))
            if resize or self.zoomwindowfit or (self.zoomfactor != 1 and self.zoom_antialias) or self.splitView:
                if resize and script.previewFilterIdx > 0:
                    self.OnMenuPreviewFilter(index=script.previewFilterIdx, updateUserSliders=False)
                else:
                     self.ShowVideoFrame(forceLayout=True)
            self.ResetZoomAntialias()
            event.Skip()
        self.videoSplitter.Bind(wx.EVT_LEFT_UP, OnVideoSplitterPosChanged)
        #~ self.videoSplitter.Bind(wx.EVT_SPLITTER_SASH_POS_CHANGED, OnVideoSplitterPosChanged)

        def OnVideoSplitterLeftDown(event):
            self.zoom_antialias = False
            event.Skip()
        self.videoSplitter.Bind(wx.EVT_LEFT_DOWN, OnVideoSplitterLeftDown)
        self.videoSplitter.Bind(wx.EVT_SPLITTER_DCLICK, self.OnLeftDClickVideoSplitter)

        # Create the program's text editing notebook
        self.scriptNotebook = self.createScriptNotebook()
        self.scriptNotebook.dblClicked = False
        scriptWindow = self.createScriptWindow()
        self.currentScript = scriptWindow
        self.currentSliderWindow = scriptWindow.sliderWindow
        self.scriptNotebook.AddPage(scriptWindow, self.NewFileName)
        # Create the program's video preview window
        self.videoWindow = self.createVideoWindow(self.videoSplitter)

        # Create the program's menu
        shortcutList = []
        oldShortcuts = ([item[0] for item in self.options['shortcuts']], self.options['shortcuts'])
        self.menuBackups = [1, 2]
        menuBar = self.createMenuBar(self.menuInfo(), shortcutList, oldShortcuts, self.menuBackups, self.options['contextshowshortcuts'])
        self.SetMenuBar(menuBar)
        self.Bind(wx.EVT_MENU_OPEN, self.OnMenuBar)
        video_menu = self.GetMenuBar().GetMenu(2)
        self.tab_group_menu = video_menu.FindItemById(video_menu.FindItem(_('Add tab to group'))).GetSubMenu()
        #self.preview_filter_menu = video_menu.FindItemById(video_menu.FindItem(_('Preview filter'))).GetSubMenu()
        scriptWindow.contextMenu = self.menuBackups[0] if self.menuBackups else self.GetMenuBar().GetMenu(1)
        self.videoWindow.contextMenu = self.menuBackups[1] if self.menuBackups else self.GetMenuBar().GetMenu(2)
        # Add the tools to the menu
        self.createToolsMenu(shortcutList, oldShortcuts)
        # Add the macros to the menu
        self.createMacroMenu(shortcutList, oldShortcuts)
        # Set the shortcut list
        self.options['shortcuts'] = None
        self.options['shortcuts'] = shortcutList

        self.bindShortcutsToAllWindows()

        # Create the program's video controls
        self.videoControls = self.createVideoControls(self.programSplitter)
        spos = self.videoControls.GetClientSize().height + intPPI(6)
        self.toolbarHeight = spos

        if wx.VERSION < (2, 9):
            self.programSplitter.SetSashSize(0)
            self.programSplitter.SplitHorizontally(self.mainSplitter, self.videoControls, -spos)

        # Set the minimum pane sizes
        self.SetMinimumScriptPaneSize() #2022, moved to after loadsession, so we can calculate with row count
        self.videoSplitter.SetMinimumPaneSize(intPPI(3))

        # Manually implement splitter gravity (improper size updating with sub-splitters...)
        self.videoSplitter.SetSashGravity(1.0)

        def OnProgramSplitterSize(event):
            # programSplitter gravity
            if wx.VERSION < (2, 9):
                self.programSplitter.SetSashPosition(-self.toolbarHeight)
            # mainSplitter gravity
            # Ooooh, searching for 8 houers to find an error, this on (if self.mainSplitter.IsSplit() is not enough)
            if self.mainSplitter.IsSplit() and not self.blockEventSize and not self.ClipRefreshPainter and self.currentScript.AVI:
                pos = self.GetMainSplitterNegativePosition()
                self.mainSplitter.SetSashPosition(pos)
                self.currentScript.lastSplitVideoPos = pos
            event.Skip()
        self.programSplitter.Bind(wx.EVT_SIZE, OnProgramSplitterSize)

        if not self.separatevideowindow:
            if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
                self.mainSplitter.SplitHorizontally(self.scriptNotebook, self.videoPane)
            else:
                self.mainSplitter.SplitVertically(self.scriptNotebook, self.videoPane)
        else:
            self.mainSplitter.SplitHorizontally(self.scriptNotebook, wx.Panel(self.mainSplitter, wx.ID_ANY))
            self.mainSplitter.Unsplit()
            # Layout the separate video window (create first the statusbar !)
            self.videoStatusBar = wx.StatusBar(self.videoDialog, wx.ID_ANY)
            if self.ppi_factor > 1 or self.options['ppiscalingstatusbar'] != 0:
                i = self.options['ppiscalingstatusbar']
                if i > 0:
                    i = float(i / 10.0)
                factor = self.ppi_factor + i
                self.videoStatusBar.SetMinHeight(int(self.videoStatusBar.GetSize()[1]*factor)-6)
                font = self.videoStatusBar.GetFont()
                dpi.SetFontSize(font, factor)
                self.videoStatusBar.SetFont(font)
            self.videoStatusBar.SetFieldsCount(2)
            self.videoStatusBar.SetStatusWidths([-1, 0])
            self.videoControls2 = self.createVideoControls(self.videoDialog, primary=False)
            sizer = wx.BoxSizer(wx.VERTICAL)
            sizer.Add(self.videoPane, 1, wx.EXPAND)
            sizer.Add(self.videoControls2, 0, wx.EXPAND|wx.ALL, 0)
            sizer.Add(self.videoStatusBar, 0, wx.EXPAND)
            self.videoDialog.SetSizer(sizer)
            sizer.Layout()

        self.videoSplitter.SplitVertically(self.videoWindow, self.currentScript.sliderWindow, intPPI(10))

        if wx.VERSION > (2, 9):
            mainFrameSizer = wx.BoxSizer(wx.VERTICAL)
            mainFrameSizer.Add(self.mainSplitter, 1, wx.EXPAND)
            mainFrameSizer.Add(self.videoControls, 0, wx.EXPAND)
            self.SetSizer(mainFrameSizer)

        # Hide the video preview initially
        self.HidePreviewWindow()

        # Misc
        scriptWindow.SetFocus()
        self.SetMinSize(tuplePPI(320, 240))

        # GPo new, update the matrix menu items
        script = self.currentScript
        if script.matrix[0] == 'auto':
            s1 = _('Resolution-based')
        else: s1 = _('BT.' + script.matrix[0])
        s2 = _(script.matrix[1].upper() + ' levels')
        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), s1])
        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), s2])

    def SaveLastSplitVideoPos(self, backup=False):
        if not self.previewOK() or not self.mainSplitter.IsSplit():
            return None
        spos = self.mainSplitter.GetSashPosition() - \
               self.mainSplitter.GetClientSize()[self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL]
        spos = spos if isinstance(spos, int) and spos < 0 else None
        self.currentScript.lastSplitVideoPos = spos
        if backup:
            self.currentScript.lastSplitVideoPosShown = spos
        return spos

    def SetMinimumScriptPaneSize(self, mlines=-1, onlyReturnValue=False, IsFullScreen=None):
        if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
            scrollbarheight = wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X)
            if mlines < 0:
                self.mintextlines = max(0, self.options['mintextlines'])
            else:
                self.mintextlines = max(0, mlines)

            if self.mintextlines != 0:
                minpanesize = self.currentScript.GetRect()[1] + self.mainSplitter.GetSashSize() + scrollbarheight +  (self.mintextlines * self.currentScript.TextHeight(0))
            else:
                if IsFullScreen is None:
                    IsFullScreen = self.IsFullScreen()
                # Fullscreen and Fullsize modes
                # 0= show tabs always, 1= hide tabs only if row count > 1, 2= hide if fullscreen else 0, 3= hide if fullscreen else 1,  4= hide always
                mode = self.options['fullscreenmode']
                if mode == 0:
                    minpanesize = self.currentScript.GetRect()[1]
                elif mode == 1:
                    minpanesize = 1 if self.scriptNotebook.GetRowCount() > 1 else self.currentScript.GetRect()[1]
                elif mode == 2:
                    if IsFullScreen:
                        minpanesize = 1
                    else:
                        minpanesize = self.currentScript.GetRect()[1]
                elif mode == 3:
                    if IsFullScreen:
                        minpanesize = 1
                    else:
                        minpanesize = 1 if self.scriptNotebook.GetRowCount() > 1 else self.currentScript.GetRect()[1]
                else:
                    minpanesize = 1
            if not onlyReturnValue:
                self.mainSplitter.SetMinimumPaneSize(minpanesize)
        else:
            if mlines < 0:
                self.mintextlines = max(0, intPPI(450))
            else:
                self.mintextlines = max(0, mlines)
            minpanesize = self.mintextlines
            if not onlyReturnValue:
                self.mainSplitter.SetMinimumPaneSize(minpanesize)
        return minpanesize

    def bindShortcutsToAllWindows(self):
        self._shortcutBindWindowDict = {self:[], self.videoWindow:[]}
        self.useEscape = False
        for label, shortcut, id in self.options['shortcuts']:
            if not shortcut:
                continue
            if shortcut.endswith('Escape'):
                self.useEscape = True
            if shortcut in self.exceptionShortcuts:
                self._shortcutBindWindowDict[self.videoWindow].append(id)
            elif shortcut != 'Escape' and shortcut in self.options['reservedshortcuts']:
                if (label, shortcut) not in self.stcShortcuts[-1]:
                    self._shortcutBindWindowDict[self.videoWindow].append(id)
            else:
                self._shortcutBindWindowDict[self].append(id)
        self.BindShortcutsToWindows(self.options['shortcuts'])
        #~ self.BindShortcutsToWindows(self.optionsShortcuts, forcewindow=self.scrapWindow.textCtrl)
        self.scrapWindow.BindShortcuts()
        # Bind shortcuts to the video window if necessary
        if self.separatevideowindow:
            self.BindShortcutsToWindows(self.options['shortcuts'], forcewindow=self.videoWindow)
        if True:#wx.VERSION > (2, 8):
            if self.useEscape:
                self.Bind(wx.EVT_CHAR_HOOK, self.OnCharHook)
                if self.separatevideowindow:
                    self.videoWindow.Bind(wx.EVT_CHAR_HOOK, self.OnCharHook)
            else:
                self.Unbind(wx.EVT_CHAR_HOOK)
                if self.separatevideowindow:
                    self.videoWindow.Unbind(wx.EVT_CHAR_HOOK)

    def menuInfo(self):
        self.exceptionShortcuts = [
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'Enter', 'Space', 'Insert', 'Backspace', 'Delete',
            'Home', 'End', 'PgUp', 'PgDn', 'Up', 'Down', 'Left', 'Right',
            'Numpad 0', 'Numpad 1', 'Numpad 2', 'Numpad 3', 'Numpad 4', 'Numpad 5', 'Numpad 6', 'Numpad 7', 'Numpad 8', 'Numpad 9',
            'Numpad +', 'Numpad -', 'Numpad *', 'Numpad /', 'Numpad .', 'Numpad Enter',
            '`', '-', '=', '\\', '[', ']', ';', "'", ',', '.', '/',
            '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '|', '{', '}', ':', '"', '<', '>', '?',
        ]
        self.stcShortcuts = [
            ('Shift+Down',          _('Extend selection to line down position')),
            ('Ctrl+Down',           _('Scroll down')),
            ('Alt+Shift+Down',      _('Extend rectangular selection to line down position')),
            ('Shift+Up',            _('Extend selection to line up position')),
            ('Ctrl+Up',             _('Scroll up')),
            ('Alt+Shift+Up',        _('Extend rectangular selection to line up position')),
            ('Ctrl+[',			    _('Go to previous paragraph')),
            ('Ctrl+Shift+[',		_('Extend selection to previous paragraph')),
            ('Ctrl+]',			    _('Go to next paragraph')),
            ('Ctrl+Shift+]',		_('Extend selection to next paragraph')),
            ('Shift+Left',		    _('Extend selection to previous character')),
            ('Ctrl+Left',		    _('Go to previous word')),
            ('Ctrl+Shift+Left',	    _('Extend selection to previous word')),
            ('Alt+Shift+Left',	    _('Extend rectangular selection to previous character')),
            ('Shift+Right',		    _('Extend selection to next character')),
            ('Ctrl+Right',		    _('Go to next word')),
            ('Ctrl+Shift+Right',	_('Extend selection to next word')),
            ('Alt+Shift+Right',	    _('Extend rectangular selection to next character')),
            ('Ctrl+/',		        _('Go to previous word part')),
            ('Ctrl+Shift+/',		_('Extend selection to previous word part')),
            ('Ctrl+\\',		        _('Go to next word part')),
            ('Ctrl+Shift+\\',	    _('Extend selection to next word part')),
            ('Shift+Home', 		    _('Extend selection to start of line')),
            ('Ctrl+Home', 		    _('Go to start of document')),
            ('Ctrl+Shift+Home', 	_('Extend selection to start of document')),
            ('Alt+Home', 		    _('Go to start of line')),
            ('Alt+Shift+Home', 	    _('Extend selection to start of line')),
            ('Shift+End', 		    _('Extend selection to end of line')),
            ('Ctrl+End', 		    _('Go to end of document')),
            ('Ctrl+Shift+End', 	    _('Extend selection to end of document')),
            ('Alt+End', 		    _('Go to end of line')),
            ('Alt+Shift+End', 	    _('Extend selection to end of line')),
            ('Shift+PgUp',		    _('Extend selection to previous page')),
            ('Alt+Shift+PgUp',	    _('Extend rectangular selection to previous page')),
            ('Shift+PgDn',		    _('Extend selection to next page')),
            ('Alt+Shift+PgDn',	    _('Extend rectangular selection to next page')),
            ('Shift+Delete',        _('Cut')),
            ('Ctrl+Delete',         _('Delete to end of word')),
            ('Ctrl+Shift+Delete',   _('Delete to end of line')),
            ('Shift+Insert',  	    _('Paste')),
            ('Ctrl+Insert',  	    _('Copy')),
            ('Shift+Backspace',	    _('Delete back')),
            ('Ctrl+Backspace',      _('Delete to start of word')),
            ('Alt+Backspace',       _('Undo')),
            ('Ctrl+Shift+Backspace',_('Delete to start of line')),
            ('Ctrl+Z', 			    _('Undo')),
            ('Ctrl+Y', 			    _('Redo')),
            ('Ctrl+X', 			    _('Cut')),
            ('Ctrl+C', 			    _('Copy')),
            ('Ctrl+V', 			    _('Paste')),
            ('Ctrl+A', 			    _('Select all')),
            ('Escape',              _('Cancel autocomplete or calltip')),
            ('Tab',		            _('Indent selection')),
            ('Shift+Tab',		    _('Unindent selection')),
            ('Shift+Return',        _('Newline')),
            ('Ctrl+Numpad +', 	    _('Zoom in')),
            ('Ctrl+Numpad -', 	    _('Zoom out')),
            ('Ctrl+Numpad /', 	    _('Reset zoom level to normal')),
            ('Ctrl+L', 			    _('Line cut')),
            ('Ctrl+Shift+L', 	    _('Line delete')),
            ('Ctrl+Shift+T', 	    _('Line copy')),
            ('Ctrl+T', 			    _('Transpose line with the previous')),
            ('Ctrl+D', 			    _('Line or selection duplicate')),
            ('Ctrl+U', 			    _('Convert selection to lowercase')),
            ('Ctrl+Shift+U', 	    _('Convert selection to uppercase')),
            (
            ('Edit -> Indent selection', 'Tab'),
            ('Edit -> Unindent selection', 'Shift+Tab'),
            ('Edit -> Undo', 'Ctrl+Z'),
            ('Edit -> Redo', 'Ctrl+Y'),
            ('Edit -> Cut', 'Ctrl+X'),
            ('Edit -> Copy', 'Ctrl+C'),
            ('Edit -> Paste', 'Ctrl+V'),
            ('Edit -> Select All', 'Ctrl+A'),
            ),
        ]
        """ # GPo removed, causes problems
        self.menuBookmark = self.createMenu(
            (
                (''),
                (_('sort ascending'), '', self.UpdateBookmarkMenu, _('Sort bookmarks ascending'), wx.ITEM_CHECK, True),
                (_('show time'), '', self.UpdateBookmarkMenu, _('Show bookmarks with timecode'), wx.ITEM_CHECK, False),
                (_('show title'), '', self.UpdateBookmarkMenu, _('Show bookmarks with title'), wx.ITEM_CHECK, True),
            )
        )
        """
        self.yuv2rgbDict = {
            _('Resolution-based'): 'auto',
            _('BT.709'): '709',
            _('BT.601'): '601',
            _('TV levels'): 'tv',
            _('PC levels'): 'pc',
            _('Progressive'): 'Progressive',
            _('Interlaced'): 'Interlaced',
            _('Swap UV'): 'swapuv',
        }
        reverseMatrixDict = dict([(v,k) for k,v in self.yuv2rgbDict.items()])
        self.zoomLabelDict = {
            _('25%'): '25',
            _('50%'): '50',
            _('100% (normal)'): '100',
            _('200%'): '200',
            _('300%'): '300',
            _('400%'): '400',
            _('Fill window'): 'fill',
            _('Fit inside window'): 'fit',
        }
        reverseZoomLabelDict = dict([(v,k) for k,v in self.zoomLabelDict.items()])
        self.flipLabelDict = {
            _('Vertically'): 'flipvertical',
            _('Horizontally'): 'fliphorizontal',
        }
        self.backgroundLabelDict = {
            _('Black'): (0, 0, 0),
            _('Dark grey'): (63, 63, 63),
            _('Medium grey'): (127, 127, 127),
            _('Light grey'): (191, 191, 191),
            _('White'): (255, 255, 255),
        }
        self.backgroundColorDict = dict([(v,k) for k,v in self.backgroundLabelDict.items()])

        # zoom and resample menus info
        _zoomMenu = (
            (reverseZoomLabelDict['25'], '', self.OnMenuVideoZoom, _('Zoom video preview to 25%'), wx.ITEM_RADIO, False),
            (reverseZoomLabelDict['50'], '', self.OnMenuVideoZoom, _('Zoom video preview to 50%'), wx.ITEM_RADIO, False),
            (reverseZoomLabelDict['100'], 'Numpad /', self.OnMenuVideoZoom, _('Zoom video preview to 100% (normal)'), wx.ITEM_RADIO, True),
            (reverseZoomLabelDict['200'], '', self.OnMenuVideoZoom, _('Zoom video preview to 200%'), wx.ITEM_RADIO, False),
            (reverseZoomLabelDict['300'], '', self.OnMenuVideoZoom, _('Zoom video preview to 300%'), wx.ITEM_RADIO, False),
            (reverseZoomLabelDict['400'], '', self.OnMenuVideoZoom, _('Zoom video preview to 400%'), wx.ITEM_RADIO, False),
            (reverseZoomLabelDict['fill'], '', self.OnMenuVideoZoom, _('Zoom video preview to fill the entire window'), wx.ITEM_RADIO, False),
            (reverseZoomLabelDict['fit'], '', self.OnMenuVideoZoom, _('Zoom video preview to fit inside the window'), wx.ITEM_RADIO, False),
            (''),
            (_('Zoom in'), 'Numpad +', self.OnZoomInOut, _("Enlarge preview image to next zoom level. Not work under 'Fill window' or 'Fit inside window'")),
            (_('Zoom out'), 'Numpad -', self.OnZoomInOut, _("Shrink preview image to previous zoom level. Not work under 'Fill window' or 'Fit inside window'")),
            (''),
            (_('Antialiasing'), '', self.OnMenuVideoZoomAntialias, _("If zoom not 100 %, the preview is drawing antialiased"), wx.ITEM_CHECK, self.options['zoom_antialias']),
        )
        _resampleMenu = (
            ('Resample fill', '^', self.OnMenuVideoZoomResampleFill, _("Use resample filter"), wx.ITEM_NORMAL),
            ('Resample fit', '<', self.OnMenuVideoZoomResampleFit, _("Use resample filter"), wx.ITEM_NORMAL),
            ('50% resample', '', self.OnMenuVideoZoomResampleZoom, _("Use resample filter"), wx.ITEM_NORMAL),
            ('75% resample', '', self.OnMenuVideoZoomResampleZoom, _("Use resample filter"), wx.ITEM_NORMAL),
            ('200% resample!', '', self.OnMenuVideoZoomResampleZoom, _("Use resample filter"), wx.ITEM_NORMAL),
        )
        idx = self.options['showresamplemenu']
        if idx == 1:
            _zoomMenu += ((_('Resample filter'), _resampleMenu),)
        elif idx == 2:
            _zoomMenu += ((''),) +  _resampleMenu
        # else hide and disable the resample menu
        return (
            (_('&File'),
                (_('New tab'), 'Ctrl+N', self.OnMenuFileNew, _('Create a new tab')),
                (_('New tab from template'), '', self.NewTabFromTemplate, _('Create a new tab from template **')),
                (_('Open...'), 'Ctrl+O', self.OnMenuFileOpen, _('Open an existing script')),
                (_('Undo close tab'), 'Ctrl+Shift+N', self.OnMenuFileUndoCloseTab, _('Reopen the last closed tab')),
                (_('Close tab'), 'Ctrl+W', self.OnMenuFileClose, _('Close the current tab')),
                (_('Close all tabs'), 'Ctrl+Shift+W', self.OnMenuFileCloseAllTabs, _('Close every tab')),
                (_('Rename tab'), '', self.OnMenuFileRenameTab, _('Rename the current tab. If script file is existing, also rename it')),
                (''),
                (_('Save script'), 'Ctrl+S', self.OnMenuFileSaveScript, _('Save the current script')),
                (_('Save script as...'), 'Ctrl+Shift+S', self.OnMenuFileSaveScriptAs, _('Choose where to save the current script')),
                (_('Reload script'), 'Ctrl+F5', self.OnMenuFileReloadScript, _('Reopen the current script file if it has changed')),
                (_('Reload all scripts'), '', self.OnMenuFileReloadAllScripts, _('Reopen all script files if it has changed')),
                (_("Open script's directory"), '', self.OnMenuFileOpenScriptDirectory, _('If the current script is saved to a file, open its directory')),
                (''),
                (_('Export HTML'), '', self.OnMenuFileExportHTML, _('Save the current script as a HTML document')),
                (_('&Print script'),
                    (
                    (_('Page setup'), '', self.OnMenuFilePageSetup, _('Configure page for printing')),
                    (_('Print header'), '', self.OnMenuFilePrintHeader, _('Include the script filename and page number at the top of each page'), wx.ITEM_CHECK, True),
                    (_('Wrap text'), '', self.OnMenuFileWrapText, _('Word-wrap long lines'), wx.ITEM_CHECK,  True),
                    (_('Use zoom'), '', self.OnMenuFileUseZoom, _('Apply the current zoom to the output'), wx.ITEM_CHECK,  False),
                    (_('Print preview'), '', self.OnMenuFilePrintPreview, _('Display print preview')),
                    (_('&Print'), '', self.OnMenuFilePrint, _('Print to printer or file')),
                    ),
                ),
                (''),
                (_('Load session...'), 'Alt+O', self.OnMenuFileLoadSession, _('Load a session into the tabs')),
                (_('Save session...'), 'Alt+S', self.OnMenuFileSaveSession, _('Save all the scripts as a session, including slider info')),
                (_('Backup current session'), 'Alt+B', self.OnMenuFileBackupSession, _('Backup the current session for next program run')),
                (_('Reload startup session'), 'Alt+R', self.OnMenuFileReloadLastSession, _('Load last session startup backup')),
                (''),
                (_('Next tab'), 'Ctrl+Tab', self.OnMenuFileNextTab, _('Switch to next script tab')),
                (_('Previous tab'), 'Ctrl+Shift+Tab', self.OnMenuFilePrevTab, _('Switch to previous script tab')),
                (_('Previously selected tab'), '', self.OnPreviouslySelectedTab, _('Toggle between the last two selected tabs')),
                (''),
                (_('Toggle scrap window'), 'Ctrl+Shift+P', self.OnMenuEditShowScrapWindow, _('Show the scrap window')),
                (_('Clear file history'), '', self.OnMenuFileClearRecentFiles, _('Clear the recent file list')),
                (''),
                (''),
                (_('&Exit'), 'Alt+X', self.OnMenuFileExit, _('Exit the program')),
            ),
            (_('&Edit'),
                (_('Undo'), 'Ctrl+Z', self.OnMenuEditUndo, _('Undo last text operation')),
                (_('Redo'), 'Ctrl+Y', self.OnMenuEditRedo, _('Redo last text operation')),
                (''),
                (_('Cut'), 'Ctrl+X', self.OnMenuEditCut, _('Cut the selected text')),
                (_('Copy'), 'Ctrl+C', self.OnMenuEditCopy, _('Copy the selected text')),
                (_('Paste'), 'Ctrl+V', self.OnMenuEditPaste, _('Paste the selected text')),
                (_('Delete'), '', self.OnMenuEditDelete, _('Delete the selected text')),
                (''),
                (_('Find...'), 'Ctrl+F', self.OnMenuEditFind, _('Open a find text dialog box')),
                (_('Find next'), 'F3', self.OnMenuEditFindNext, _('Find the next instance of given text')),
                (_('Find previous'), 'Shift+F3', self.OnMenuEditFindPrevious, _('Find the previous instance of given text')),
                (_('Replace...'), 'Ctrl+H', self.OnMenuEditReplace, _('Open a replace text dialog box')),
                (_('Replace next'), 'F4', self.OnMenuEditReplaceNext, _('Replace the next instance of given text')),
                (''),
                (_('Select All'), 'Ctrl+A', self.OnMenuEditSelectAll, _('Select all the text')),
                (''),
                (_('&Insert'),
                    (
                    (_('Insert snippet'), 'F7', self.OnMenuEditInsertSnippet, _('Expand a snippet tag, or select a snippet from the list')),
                    (''),
                    (_('Insert source...'), 'F9', self.OnMenuEditInsertSource, _('Choose a source file to insert into the text')),
                    (_('Insert filename...'), 'Shift+F9', self.OnMenuEditInsertFilename, _('Get a filename from a dialog box to insert into the text')),
                    (_('Insert plugin...'), 'F10', self.OnMenuEditInsertPlugin, _('Choose a plugin file to insert into the text')),
                    (''),
                    (_('Insert user slider...'), 'F12', self.OnMenuEditInsertUserSlider, _('Insert a user-scripted slider into the text')),
                    (_('Insert user slider separator'), 'Shift+F12', self.OnMenuEditInsertUserSliderSeparator, _('Insert a tag which indicates a separator in the user slider window')),
                    (''),
                    (_('Insert frame #'), 'F11', self.OnMenuEditInsertFrameNumber, _('Insert the current frame number into the text')),
                    (''),
                    (_('Tag selection for toggling...'), 'Ctrl+T', self.OnMenuEditToggleTagSelection, _('Add tags surrounding the selected text for toggling with the video preview')),
                    (_('Clear all tags'), 'Ctrl+Shift+T', self.OnMenuEditClearToggleTags, _('Clear all toggle tags from the text')),
                    (''),
                    (_('Split Clip'), '', self.OnMenuInsertSplitClip, _('Add Split Clip function. Help-> Split Clip readme ')),
                    (_('Preview filter'), 'Ctrl+P', self.OnMenuInsertPreviewFilter, _('Add Preview filter surrounding the selected lines. Help-> Preview filter readme')),
                    ),
                ),
                (''),
                (_('Indent selection'), 'Tab', self.OnMenuEditIndentSelection, _('Indent the selected lines')),
                (_('Unindent selection'), 'Shift+Tab', self.OnMenuEditUnIndentSelection, _('Unindent the selected lines')),
                (_('Block comment'), 'Ctrl+Q', self.OnMenuEditBlockComment, _('Comment or uncomment selected lines')),
                (_('Style comment'), 'Alt+Q', self.OnMenuEditStyleComment, _('Comment at start of a text style or uncomment')),
                (_('Toggle current fold'), '', self.OnMenuEditToggleCurrentFold, _('Toggle the fold point On/OFF at the current line')),
                (_('Toggle all folds'), '', self.OnMenuEditToggleAllFolds, _('Toggle all fold points On/OFF')),
                (''),
                (_('Toggle text wrap'), '', self.OnMenuEditToggleTextWrap, _('Toggle text wrap On/OFF')), # GPo 2018
                (_("Enable 'Number wheel'"), '', self.OnMenuEditNumberWheel, _('Enable/Disable selected number changing with the mouse wheel or left/right keys. Help-> Number wheel readme'), wx.ITEM_CHECK, self.options['numberwheel']),
                (''),
                (_('&AviSynth function'),
                    (
                    (_('Autocomplete'), 'Ctrl+Space', self.OnMenuEditAutocomplete, _('Show list of filternames matching the partial text at the cursor')),
                    (_('Autocomplete all'), 'Alt+Space', self.OnMenuEditAutocompleteAll, _("Disregard user's setting, show full list of filternames matching the partial text at the cursor")),
                    (_('Autocomplete parameter/filename'), 'Ctrl+Alt+Space', self.OnMenuEditAutocompleteParameterFilename, _("If the first characters typed match a parameter name, complete it. If they're typed on a string, complete the filename")),
                    (_('Show calltip'), 'Ctrl+Shift+Space', self.OnMenuEditShowCalltip, _('Show the calltip for the filter (only works if cursor within the arguments)')),
                    (_('Show function definition'), 'Ctrl+Shift+D', self.OnMenuEditShowFunctionDefinition, _('Show the AviSynth function definition dialog for the filter')),
                    (_('Filter help file'), 'Shift+F1', self.OnMenuEditFilterHelp, _("Run the help file for the filter (only works if cursor within the arguments or name is highlighted)")),
                    (_('Parse script for function definitions'), 'Ctrl+Alt+F5', self.OnMenuEditParseFunctions, _('Include functions defined in the current script in the filter database, only for this tab')),
                    ),
                ),
                (''),
                (_('&Miscellaneous'),
                    (
                    (_('Move line up'), 'Ctrl+Shift+Up', self.OnMenuEditMoveLineUp, _('Move the current line or selection up by one line')),
                    (_('Move line down'), 'Ctrl+Shift+Down', self.OnMenuEditMoveLineDown, _('Move the current line or selection down by one line')),
                    (''),
                    (_('Copy unmarked script to clipboard'), 'Ctrl+Shift+C', self.OnMenuCopyUnmarkedScript, _('Copy the current script without any AvsP markings (user-sliders, toggle tags) to the clipboard')),
                    (_('Copy avisynth error to clipboard'), '', self.OnMenuCopyAvisynthError, _('Copy the avisynth error message shown on the preview window to the clipboard')),
                    (_('Set selection as display filter...'), '', self.OnMenuCopyAsDisplayFilter, _('Shows the display filter dialog with the selected text')),
                    ),
                ),
            ),
            (_('&Video'),
                (_('Bookmarks'),  # GPo, 2018
                    (
                    (_('Bookmarks to script'), '', self.OnMenuBookmarksToScript),
                    (_('Bookmarks from script'), '', self.OnMenuBookmarksFromScript),
                    (''),
                    (_('Add/Remove bookmark'), 'Ctrl+B', self.OnMenuVideoBookmark, _('Mark the current frame on the frame slider')),
                    (_('Clear tab bookmarks'), '', self.OnMenuVideoClearTabBookmarks, _('Clears the current tab bookmarks')),
                    (_('Clear all bookmarks Globally'), '', self.OnMenuVideoGotoClearAll, _('Clears all bookmarks, clears also all tab bookmarks')),
                    #(''),
                    #(_('Reset bookmarks'), '', self.OnMenuVideoRestoreScriptBookmarks, _('Restores from script bookmarks backup.')),
                    #(_('Join bookmarks'), '', self.OnMenuVideoJoinScriptBookmarks, _('Join script backup bookmarks and timeline bookmarks')),
                    (''),
                    (_('Titled &bookmarks'),
                        (
                        (_('Move titled bookmark'), '', self.OnMenuVideoBookmarkMoveTitle, _('Move the nearest titled bookmark to the current position. A historic title will be restored if it matches the condition.')),
                        (_('Restore historic titles'), '', self.OnMenuVideoBookmarkRestoreHistory, _('Restore all historic titles')),
                        (_('Clear historic titles'), '', self.OnMenuVideoBookmarkClearHistory, _('Clear all historic titles')),
                        (_('Set title (auto)'), '', self.OnMenuVideoBookmarkAutoTitle, _("Generate titles for untitled bookmarks by the pattern - 'Chapter %02d'")),
                        (_('Set title (manual)'), '', self.OnMenuVideoBookmarkSetTitle, _('Edit title for bookmarks in a list table')),
                        (''),
                        (_('Remove all title'), '', self.OnMenuVideoBookmarkRemoveAllTitle, _('Remove all title from the bookmarks')),
                        ),
                    ),
                    ),
                ),
                (''),
                (_('Add tab to group'),
                    (
                    (_('None'), '', self.OnMenuVideoGroupAssignTabGroup, _('Not include this tab on any group'), wx.ITEM_RADIO, True),
                    ('1', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    ('2', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    ('3', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    ('4', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    ('5', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    ('6', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    ('7', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    ('8', '', self.OnMenuVideoGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                    (''),
                    (_('Clear current tab group'), '', self.OnMenuVideoGroupClearTabGroup, _('Clear current tab group')),
                    (_('Clear all tab groups'), '', self.OnMenuVideoGroupClearAllTabGroups, _('Clear all tab groups')),
                    (''),
                    (_('Apply offsets'), '', self.OnMenuVideoGroupApplyOffsets, _('Use the difference between showed frames when the tabs were added to the group as offsets'),
                        wx.ITEM_CHECK, self.options['applygroupoffsets']),
                    (_('Offset also bookmarks'), '', self.OnMenuVideoGroupOffsetBookmarks, _('Apply the offset also to the currently set bookmarks'),
                        wx.ITEM_CHECK, self.options['offsetbookmarks']),
                    (''),
                    (_('Freeze Split View frame'), '', self.OnMenuSplitViewFreeze, _("If Split View then freeze the frame number"), wx.ITEM_CHECK, False),
                    #(_('Locate frame'), '', self.OnMenuLocateFrame, _("Reade the LocateFrame readme")),
                    ),
                ),
                (_('&Navigate'),
                    (
                    #(_('Go to &bookmark'), self.menuBookmark, -1),
                    (_('Next bookmark'), 'F2', self.OnMenuVideoGotoNextBookmark, _('Go to next bookmarked frame')),
                    (_('Previous bookmark'), 'Shift+F2', self.OnMenuVideoGotoPreviousBookmark, _('Go to previous bookmarked frame')),
                    (''),
                    (_('Forward 1 frame'), 'Right', self.OnMenuVideoNextFrame, _('Show next video frame (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Backward 1 frame'), 'Left', self.OnMenuVideoPrevFrame, _('Show previous video frame (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Forward 1 second'), 'Down', self.OnMenuVideoNextSecond, _('Show video 1 second forward (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Backward 1 second'), 'Up', self.OnMenuVideoPrevSecond, _('Show video 1 second back (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Forward 1 minute'), 'PgDn', self.OnMenuVideoNextMinute, _('Show video 1 minute forward (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Backward 1 minute'), 'PgUp', self.OnMenuVideoPrevMinute, _('Show video 1 minute back (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (''),
                    (_('Forward x units'), '', self.OnMenuVideoNextCustomUnit, _('Jump forward by x units (you can specify x in the options dialog)')),
                    (_('Backwards x units'), '', self.OnMenuVideoPrevCustomUnit, _('Jump backwards by x units (you can specify x in the options dialog)')),
                    (''),
                    (_('Next I frame'), '', self.OnMenuVideoNextIFrame,  _('Jump to the next I frame, Esc breaks, max. search 350 frames')),
                    (_('Previous I frame'), '', self.OnMenuVideoPrevIFrame, _('Jump to the previous I frame, Esc breaks, max. search 350 frames')),
                    (''),
                    (_('Go to first frame'), '', self.OnMenuVideoFirstFrame, _('Go to first video frame (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Go to last frame'), '', self.OnMenuVideoLastFrame, _('Go to last video frame (keyboard shortcut active when video window focused)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (''),
                    (_('Last scrolled frame'), 'F8', self.OnMenuVideoGotoLastScrolled, _('Go to last scrolled frame')),
                    (''),
                    (_('Go to frame...'), 'Ctrl+G', self.OnMenuVideoGoto, _('Enter a video frame or time to jump to')),
                    ),
                ),
                (_('&Play video'),
                    (
                    (_('Play/pause video'), 'Ctrl+R', self.OnMenuVideoPlay, _('Play/pause video')),
                    (''),
                    (_('Increment speed'), 'Shift+Numpad +', self.OnMenuVideoPlayIncrement, _('Double the current playback speed')),
                    (_('Decrement speed'), 'Shift+Numpad -', self.OnMenuVideoPlayDecrement, _('Halve the current playback speed')),
                    (_('Normal speed'), 'Shift+Numpad /', self.OnMenuVideoPlayNormal, _('Set the playback speed to the script frame rate')),
                    (_('Maximum speed'), 'Shift+Numpad *', self.OnMenuVideoPlayMax, _('Play the video as fast as possible without dropping frames')),
                    (''),
                    (_('Play loop'), '', self.OnMenuVideoPlayLoop, _('Loop playback for trim editor selections or at the end of the clip'), wx.ITEM_CHECK, self.options['playloop']),
                    (_('Use separate thread'), '', self.OnMenuVideoSeparateThread, _('Use a separate thread for playback. If avisynth threads used, playback uses also threads'), wx.ITEM_CHECK, self.options['playbackthread']),
                    ),
                ),
                (''),
                (_('Crop editor...'), '', self.OnMenuVideoCropEditor, _('Show the crop editor dialog')),
                (_('&Trim selection editor'),
                    (
                    (_('Show trim selection editor'), '', self.OnMenuVideoTrimEditor, _('Show the trim selection editor dialog')),
                    (''),
                    (_('Set selection startpoint'), 'Home', self.OnMenuVideoTrimEditorSetStartpoint, _('Set a selection startpoint (shows the trim editor if not visible)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Set selection endpoint'), 'End', self.OnMenuVideoTrimEditorSetEndpoint, _('Set a selection endpoint (shows the trim editor if not visible)'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (''),
                    (_('Move selections before the current frame'), 'Ctrl+Alt+V', self.OnMenuVideoMoveSelectionsBeforeCurrentFrame, _('The current selections are cut from the timeline and inserted before the current frame. Bookmarks are shifted accordingly.'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (_('Move selections after the current frame'), 'Ctrl+V', self.OnMenuVideoMoveSelectionsAfterCurrentFrame, _('The current selections are cut from the timeline and inserted after the current frame. Bookmarks are shifted accordingly.'), wx.ITEM_NORMAL, None, self.videoWindow),
                    (''),
                    (_('Mark trim points'), '', self.OnSetBookmarkToTrims, _('Add bookmark to trim intersections'), wx.ITEM_CHECK, self.options['bookmarktotrim']),
                    (''),
                    (_('Selections to script'), '', self.OnSelectionsToScript, _('Save the selections into the script')),
                    (_('Selections from script'), '', self.OnSelectionsFromScript, _('Read the selections from the script')),
                    (''),
                    (_('Clear tab selections'), '', self.OnTrimDialogCancel, _('Clear tab trim editor selections (hide the trim editor if visible)')),
                    (_('Clear all selections Globally'), '', self.OnClearSelectionsGlobally, _('Clear all the tab trim editor selections (hide the trim editor if visible)')),
                    ),
                ),
                (_('Timeline range'),
                    (
                    ('100 %', '', self.OnMenuSetTimeLineRange),
                    (''),
                    ('50 frames', '', self.OnMenuSetTimeLineRange),
                    ('100 frames', '', self.OnMenuSetTimeLineRange),
                    ('200 frames', '', self.OnMenuSetTimeLineRange),
                    ('400 frames', '', self.OnMenuSetTimeLineRange),
                    ('800 frames', '', self.OnMenuSetTimeLineRange),
                    ('2000 frames', '', self.OnMenuSetTimeLineRange),
                    ('5000 frames', '', self.OnMenuSetTimeLineRange),
                    ),
                ),
                (''),
                (_('&Zoom'),
                    _zoomMenu
                ),
                (_('&Display'),
                    (
                    (_('Display filter'), '', self.OnMenuVideoDisplayFilter, _('Enable/Disable the display filter'), wx.ITEM_CHECK, False),
                    (_('Select display filter...'), '', self.OnMenuSelectDisplayFilter, _('Select the display filter from template')),
                    (_('Edit current display filter...'), '', self.OnMenuConfigureDisplayFilter, _('Edit the current display filter')),
                    (''),
                    (_('&Flip'),
                        (
                        (_('Vertically'), '', self.OnMenuVideoFlip, _('Flip video preview upside down'), wx.ITEM_CHECK, False),
                        (_('Horizontally'), '', self.OnMenuVideoFlip, _('Flip video preview from left to right'), wx.ITEM_CHECK, False),
                        ),
                    ),
                    (_('&YUV -> RGB'),
                        (
                        (reverseMatrixDict['swapuv'], '', self.OnMenuVideoYUV2RGB, _('Swap chroma channels (U and V)'), wx.ITEM_CHECK, False),
                        (''),
                        (_('Read from source or script'), '', self.OnMenuReadMatrix, _('Get the coefficients from source or script, if the matrix available'), wx.ITEM_CHECK, self.options['readmatrix']),
                        (_('Reset matrix if not found'), '', self.OnMenuResetMatrix, _('Set matrix default value (options) if matrix not found'), wx.ITEM_CHECK, self.options['resetmatrix']),
                        (reverseMatrixDict['auto'], '', self.OnMenuVideoYUV2RGB, _('Use BT.709 coefficients for HD, BT.601 for SD'), wx.ITEM_RADIO, False),
                        (reverseMatrixDict['709'], '', self.OnMenuVideoYUV2RGB, _('Use BT.709 coefficients'), wx.ITEM_RADIO, False),
                        (reverseMatrixDict['601'], '', self.OnMenuVideoYUV2RGB, _('Use BT.601 coefficients'), wx.ITEM_RADIO, False),
                        (''),
                        (reverseMatrixDict['tv'], '', self.OnMenuVideoYUV2RGB, _('Use limited range (default)'), wx.ITEM_RADIO, True),
                        (reverseMatrixDict['pc'], '', self.OnMenuVideoYUV2RGB, _('Use full range'), wx.ITEM_RADIO, False),
                        (''),
                        (reverseMatrixDict['Progressive'], '', self.OnMenuVideoYUV2RGB, _('For YV12 only, assume it is progressive (default)'), wx.ITEM_RADIO, True),
                        (reverseMatrixDict['Interlaced'], '', self.OnMenuVideoYUV2RGB, _('For YV12 only, assume it is interlaced'), wx.ITEM_RADIO, False),
                        (''),
                        (_('Current matrix to script'), '', self.OnMenuMatrixToScript, _('Write the current matrix to script. If no matrix found this matrix is used')),
                        (_('Read the matrix now'), '', self.OnMenuReadMatrixNow, _('Try to get the matrix from source or script')),
                        (''),
                        (_('Globally to default'), '', self.OnMenuResetDisplayProps, _('Reset all scripts to default values')),
                        ),
                    ),
                    (_('Bit &depth'),
                        (
                        (_('8-bit'), '', self.OnMenuVideoBitDepth, _('Regular 8-bit depth (default)'), wx.ITEM_RADIO, True),
                        (_('Stacked yuv420p10 or yuv444p10'), '', self.OnMenuVideoBitDepth, _('Stacked 16-bit, MSB on top, range reduced to 10-bit. Requires MaskTools v2 loaded'), wx.ITEM_RADIO, False),
                        (_('Stacked yuv420p16 or yuv444p16'), '', self.OnMenuVideoBitDepth, _('Stacked 16-bit, MSB on top'), wx.ITEM_RADIO, False),
                        (_('Interleaved yuv420p10 or yuv444p10'), '', self.OnMenuVideoBitDepth, _('Interleaved 16-bit (little-endian), range reduced to 10-bit. Requires MaskTools v2 loaded'), wx.ITEM_RADIO, False),
                        (_('Interleaved yuv420p16 or yuv444p16'), '', self.OnMenuVideoBitDepth, _('Interleaved 16-bit (little-endian)'), wx.ITEM_RADIO, False),
                        ),
                    ),
                    ),
                ),
                (_('Background &color'),
                    (
                    (_('Default'), '', self.OnMenuVideoBackgroundColor, _("Follow current theme"), wx.ITEM_RADIO, True),
                    (_('Black'), '', self.OnMenuVideoBackgroundColor, _('Use RGB {hex_value}').format(hex_value='#000000'), wx.ITEM_RADIO, False),
                    (_('Dark grey'), '', self.OnMenuVideoBackgroundColor, _('Use RGB {hex_value}').format(hex_value='#3F3F3F'), wx.ITEM_RADIO, False),
                    (_('Medium grey'), '', self.OnMenuVideoBackgroundColor, _('Use RGB {hex_value}').format(hex_value='#7F7F7F'), wx.ITEM_RADIO, False),
                    (_('Light grey'), '', self.OnMenuVideoBackgroundColor, _('Use RGB {hex_value}').format(hex_value='#BFBFBF'), wx.ITEM_RADIO, False),
                    (_('White'), '', self.OnMenuVideoBackgroundColor, _('Use RGB {hex_value}').format(hex_value='#FFFFFF'), wx.ITEM_RADIO, False),
                    (_('Custom'), '', self.OnMenuVideoBackgroundColor, _('Use a custom color'), wx.ITEM_RADIO, False),
                    (''),
                    (_('Select custom color'), '', self.OnMenuVideoSetCustomBackgroundColor, _("Choose the color used if 'custom' is selected")),
                    ),
                ),
                (''),
                (_('Save image as...'), '', self.OnMenuVideoSaveImage, _('Save the current frame as image file. If you not change the frame number, ''Quick save image'' uses the name.')),
                (_('Quick save image'), '', self.OnMenuVideoQuickSaveImage, _('Save the current frame with a default filename, overwriting the file if already exists. Press CTRL to reset the default name formatting')),
                (_('Copy image to clipboard'), '', self.OnMenuVideoCopyImageClipboard, _('Copy the current frame to the clipboard as a bitmap')),
                (''),
                (_('Refresh preview'), 'F5', self.OnMenuVideoRefresh, _('Force the script to reload and refresh the video frame. The fast clip is also recreated')),
                (_('Release all videos from memory'), '', self.OnMenuVideoReleaseMemory, _('Release all open videos from memory')),
                (''),
                (_('Snapshot'),
                    (
                    (_('Take snapshot 1'), '', lambda e: self.TakeSnapShot(shotIdx=0), _('Make bitmap and script snapshot')),
                    (_('Take snapshot 2'), '', lambda e: self.TakeSnapShot(shotIdx=1), _('Make bitmap and script snapshot')),
                    (_('Show/hide snapshot 1'), '', lambda e: self.ShowSnapShot(index=0, showMsg=True), _('Show or hide snapshot 1')),
                    (_('Show/hide snapshot 2'), '', lambda e: self.ShowSnapShot(index=1, showMsg=True), _('Show or hide snapshot 2')),
                    (''),
                    (_('Restore to current snapshot 1'), '', lambda e: self.RestoreSnapShotToCurrent(shotIdx=0), _('Restore to current script')),
                    (_('Restore to current snapshot 2'), '', lambda e: self.RestoreSnapShotToCurrent(shotIdx=1), _('Restore to current script')),
                    (_('New tab from snapshot 1'), '', lambda e: self.NewTabFromSnapShot(shotIdx=0), _('Copy snap shot 1 to new tab')),
                    (_('New tab from snapshot 2'), '', lambda e: self.NewTabFromSnapShot(shotIdx=1), _('Copy snap shot 2 to new tab')),
                    (''),
                    (_('Auto take snapshot 2'), '', self.OnMenuAutoTakeSnapShot, _('Automatically takes snapshot 2 on clip refresh'), wx.ITEM_CHECK, self.options['autosnapshot']),
                    (''),
                    (_('Clear tab snapshots'), '', self.OnMenuClearTabSnapShot, _('Clears the current tab snapshots')),
                    (_('Clear all snapshots Globally'), '', self.OnMenuClearAllSnapShots, _('Clears all snapshots Globally')),
                    ),
                ),
                (_('Preview filter'),
                    (
                    (_('None'), 'Ctrl+Numpad 0', self.OnMenuPreviewFilter, _('Preview filter off'), wx.ITEM_RADIO, True),
                    (_('1'), 'Ctrl+Numpad 1', self.OnMenuPreviewFilter, _('Preview filter 1'), wx.ITEM_RADIO, False),
                    (_('2'), 'Ctrl+Numpad 2', self.OnMenuPreviewFilter, _('Preview filter 2'), wx.ITEM_RADIO, False),
                    (_('3'), 'Ctrl+Numpad 3', self.OnMenuPreviewFilter, _('Preview filter 3'), wx.ITEM_RADIO, False),
                    (_('4'), 'Ctrl+Numpad 4', self.OnMenuPreviewFilter, _('Preview filter 4'), wx.ITEM_RADIO, False),
                    (_('5'), 'Ctrl+Numpad 5', self.OnMenuPreviewFilter, _('Preview filter 5'), wx.ITEM_RADIO, False),
                    (''),
                    (_('Save preview filters'), '', self.OnMenuSavePreviewFilters, _('Save preview filters for later use (Overrides the previous saved)')),
                    (_('Write all to script'), 'Alt+Numpad 0', self.OnMenuRestoreAllPreviewFilters, _('Write all preview filters to script')),
                    (_('Write to script'),
                        (
                        (_('1'), 'Alt+Numpad 1', self.OnMenuRestorePreviewFilter, _('Write Preview filter to script'),wx.ITEM_NORMAL),
                        (_('2'), 'Alt+Numpad 2', self.OnMenuRestorePreviewFilter, _('Write Preview filter to script'),wx.ITEM_NORMAL),
                        (_('3'), 'Alt+Numpad 3', self.OnMenuRestorePreviewFilter, _('Write Preview filter to script'),wx.ITEM_NORMAL),
                        (_('4'), 'Alt+Numpad 4', self.OnMenuRestorePreviewFilter, _('Write Preview filter to script'),wx.ITEM_NORMAL),
                        (_('5'), 'Alt+Numpad 5', self.OnMenuRestorePreviewFilter, _('Write Preview filter to script'),wx.ITEM_NORMAL),
                        ),
                    ),
                    ),
                ),
                (_('Split View on/off'), '', self.OnMenuSplitView, _('Shows the selected and the next or previous tab in one view (video width and height must be the same)'), wx.ITEM_CHECK, False),
                (_('Split view alternate'), '', self.OnMenuSplitViewEx, _('Shows the selected and the next or previous tab in one view (video width and height must be the same)'), wx.ITEM_CHECK, False),
                (_('Split Clip on/off'), '', self.SplitClipCtrl.Toggle, _("Enable/disable the 'Split Clip' (Help -> readme Split Clip)")),
                (''),
                (_('Fullscreen'), '', self.OnMenuToggleFullscreen, _('Enable/disable Fullscreen mode. Ctrl + double click (Esc chancel)')),
                (_('Toggle extended left move'), '', self.OnMenuExtendedMove, _('Expands the left shift area of the video window')),
                (_('Save view pos on tab change'), '', self.OnMenuVideoSaveViewPos, _('Save/Restore last display viewing position on tab change'), wx.ITEM_CHECK, False),
                (_('Save pos && zoom on tab change'), '', self.OnMenuVideoSaveZoom, _('Save/Restore last position and zoom settings on tab change'), wx.ITEM_CHECK, False),
                (''),
                (_('Additional'),
                    (
                    (_('Resize video window'), '', self.OnMenuVideoResizeOnZoom, _('Adjusts the video window height to the output height (zooming with Keyboard)'), wx.ITEM_CHECK, self.options['resizevideowindow']),
                    (_('Use previous frame time'), '', self.OnMenuFrameToFrameTime, _('On refresh video: Use previous frame time if frame count and frame rate different'), wx.ITEM_CHECK, self.options['frametoframetime']),
                    (_('Restore split clip if enabled'), '', self.OnMenuUseSplitClip, _("On refresh video: Restore the 'Split Clip' if it enabled"), wx.ITEM_CHECK, self.options['usesplitclip']),
                    (''),
                    (_('Show/Hide the preview'), 'Shift+F5', self.OnMenuVideoToggle, _('Toggle the video preview')),
                    (_('Switch video/text focus'), 'Escape', self.OnMenuVideoSwitchMode, _('Switch focus between the video preview and the text editor')),
                    (_('Toggle the slider sidebar'), 'Alt+F5', self.OnMenuVideoToggleSliderWindow, _('Show/hide the slider sidebar (double-click the divider for the same effect)')),
                    (_('Toggle preview placement'), '', self.OnMenuVideoTogglePlacement, _('When not using a separate window for the video preview, toggle between showing it at the bottom (default) or to the right')),
                    #(_('Copy hex color value'), '', self.OnCopyColorValue, _('Copy color values to scrap and clipboard')),
                    ),
                ),
                (_('Tools'),
                    (
                    (_('Run analysis pass'), '', self.OnMenuVideoRunAnalysisPass, _('Request every video frame once (analysis pass for two-pass filters)')),
                    (_('Run FPS analysis'), '', self.OnMenuVideoRunFPSAnalysis, _('Analysis pass for frame per second measurement (Average)')),
                    (_('Locate frame'), '', self.OnMenuLocateFrame, _("Reade the LocateFrame readme")),
                    (''),
                    (_('External player'), 'F6', self.OnMenuVideoExternalPlayer, _('Play the current script in an external program')),
                    (_('External tool arg1'), '', self.OnMenuExternalToolArg1, _('Run the current script with an external program and arg1')),
                    (_('External tool arg2'), '', self.OnMenuExternalToolArg2, _('Run the current script with an external program and arg2')),
                    ),
                ),
                (_('Frame properties'), '', self.OnMenuVideoTogglePropWindow, _('Show/Hide the properties window')),
                (_('Video information'), '', self.OnMenuVideoInfo, _('Show information about the video in a dialog box')),
            ),
            (_('&Options'),
                (_('Always on top'), '', self.OnMenuOptionsAlwaysOnTop, _('Keep this window always on top of others'), wx.ITEM_CHECK, self.options['alwaysontop']),
                (_('Video preview always on top'), '', self.OnMenuOptionsPreviewAlwaysOnTop, _('If the video preview is detached, keep it always on top of other windows'), wx.ITEM_CHECK, self.options['previewalwaysontop']),
                (_('Disable video preview'), '', self.OnMenuOptionsDisablePreview, _('If checked, the video preview will not be shown under any circumstances'), wx.ITEM_CHECK, self.options['disablepreview']),
                (_('Multiline tab style'), '', self.OnMenuOptionsMultilineTabStyle, _('Toggle multiline tab style'), wx.ITEM_CHECK, self.options['multilinetab']),
                (_('Hide video window scrollbars'), '', self.OnMenuOptionsHideScrollbars, _('Hide the video window scrollbars'), wx.ITEM_CHECK, self.options['hidescrollbars']),
                (''),
                (_("Use 'Ultra Fast Clip'"), '',self.OnMenuOptionsFastClip, _('/**avsp_split**/ must be written in to the script. Read the Fast Clip readme'), wx.ITEM_CHECK, self.options['usefastclip']),
                (''),
                (_('Accessing AviSynth in threads'), '', self.OnMenuOptionsAviThread, _('Use threads when accessing avisynth (load/release clip and get frame)'), wx.ITEM_CHECK, self.options['avithread']),
                (_('Use advanced frame thread'), '', self.OnMenuOptionsUseNewFrameThread, _('For info read the readme_threads.txt'), wx.ITEM_CHECK, self.options['usenewframethread']),
                (_('On cancel assign the clip later'), '', self.OnMenuOptionsAviThreadAssignLater, _('AvsPmod should normally be closed after a thread has been canceled by the user. This option tries to assign the clip to the script after the thread has internaly finished.'), wx.ITEM_CHECK, self.options['avithreadassignlater']),
                (_('Detach Thread ( test only! ) ...'), '', self.OnMenuDetachThread, _('Warning! test only')),
                (''),
                (_('Associate .avs files with AvsPmod'), '', self.OnMenuOptionsAssociate, _('Configure this computer to open .avs files with AvsP when double-clicked. Run again to disassociate')),
                (''),
                (_('Fonts and colors...'), '', self.OnMenuOptionsFontsAndColors, _('Edit the various AviSynth script fonts and colors')),
                (_('Make fonts && colors backup'), '', self.OnMenuOptionsFontsAndColorsWriteBackup, _('Make script fonts and colors backup')),
                (_('Load fonts && colors backup'), '', self.OnMenuOptionsFontsAndColorsReadBackup, _('Restores script fonts and colors from backup')),
                (''),
                (_('AviSynth function definition...'), '', self.OnMenuOptionsFilters, _('Add or override AviSynth functions in the database')),
                (_('Extension templates...'), '', self.OnMenuOptionsTemplates, _('Edit the extension-based templates for inserting sources')),
                (''),
                (_('Resample filter...'), '', self.OnMenuOptionsResizeFilter, _('Edit resample filter for fit, fill and resample zoom')),
                (_('Display filters...'), '', self.OnMenuOptionsDisplayFilter, _('Edit display filters')),
                (_('Apply filters...'), '', self.OnMenuOptionsApplyFilter, _('Edit insertable timeline selections filters')),
                (_('Snippets...'), '', self.OnMenuOptionsSnippets, _('Edit insertable text snippets')),
                (''),
                (_('Keyboard shortcuts...'), '', self.OnMenuConfigureShortcuts, _('Configure the program keyboard shortcuts')),
                (_('Program settings...'), '', self.OnMenuOptionsSettings, _('Configure program settings')),
            ),
            (_('&Help'),
                (_('Avisynth help'), 'F1', self.OnMenuHelpAvisynth, _('Open the avisynth help html')),
                (_('Tutorials (AvsP)'),
                    (
                    (_('Tutorials home'), '', self.OnMenuHelpAnimatedTutorial, _('Index page from the AvsP website')),
                    (_('Text features'), '', self.OnMenuHelpTextFeatures, _('Learn more about AvsP text features (from the AvsP website)')),
                    (_('Video features'), '', self.OnMenuHelpVideoFeatures, _('Learn more about AvsP video features (from the AvsP website)')),
                    (_('User sliders'), '', self.OnMenuHelpUserSliderFeatures, _('Learn more about AvsP user sliders (from the AvsP website)')),
                    (_('Macros'), '', self.OnMenuHelpMacroFeatures, _('Learn more about AvsP macros (from the AvsP website)')),
                    ),
                ),
                (''),
                (_('Video tutorials && more'), '', self.OnMenuHelpExampleVideos, _('On Google Drive')),
                (_('Accessing in threads readme'), '', self.OnMenuHelpAccessInThreads, _('Open the accessing in threads readme')),
                (_('Preview filter example'), '', self.OnMenuHelpPreviewFilters, _('Open the Preview filter examples')),
                (_('Apply filters readme'), '', self.OnMenuHelpApplyFilters, _('Open the Apply filters readme')),
                (_('Resample filter readme'), '', self.OnMenuHelpResampleFilter, _('Open the Resample filters readme')),
                (_('Split Clip readme'), '', self.OnMenuHelpSplitClip, _('Open the Split Clip readme')),
                (_('Fast Clip readme'), '', self.OnMenuHelpFastClip, _('Open the Fast Clip readme')),
                (_('Locate frame readme'), '', self.OnMenuHelpLocateFrame, _('Open the Locate frame readme')),
                (_('Number wheel readme'), '', self.OnMenuHelpNumberWheel, _('Open the Number wheel readme')),
                (''),
                (_('DPI info'), '', self.OnMenuDPIInfo, _('DPI information')),
                #(_('Active video thread count'), '', self.OnMenuTest, _('Prints the active running thread count. Normaly 0')),
                (_('Show available system memory'), '', self.OnMenuShowFreeMemory, _('Displays the available memory in the status bar')),
                (_('Open Avisynth plugins folder'), '', self.OnMenuHelpAvisynthPlugins, _('Open the avisynth plugins folder, or the last folder from which a plugin was loaded')),
                (''),
                (_('Changelog'), '', self.OnMenuHelpChangelog, _('Open the changelog file')),
                (_('About AvsPmod'), '', self.OnMenuHelpAbout, _('About this program')),
                #(_('Reload Avisynth'), '', self.OnMenuReloadAvisnth, ''),
                #(_('Test'), '', self.OnMenuTest, _('Test')),
            ),
        )

    def buttonInfo(self):
        f = self.options['ppiscalingvideocontrols']
        if f != 0:
            f = f/10.0
        factor = max(self.ppi_factor + f, 1)
        int16 = int(16*factor)
        bmpPlay = play_icon.getImage()
        bmpPause = pause_icon.getImage()
        bmpExternal = external_icon.getImage()
        bmpRight = next_icon.getImage()
        bmpSkipRight = skip_icon.getImage()
        bmpPlay = bmpPlay.Scale(int16,int16)
        bmpPause = bmpPause.Scale(int16,int16)
        bmpExternal = bmpExternal.Scale(int16,int16)
        bmpRight = bmpRight.Scale(int16,int16)
        bmpSkipRight = bmpSkipRight.Scale(int16,int16)
        self.bmpPlay = wx.BitmapFromImage(bmpPlay)
        self.bmpPause = wx.BitmapFromImage(bmpPause)
        bmpExternal = wx.BitmapFromImage(bmpExternal)
        self.bmpRightTriangle = spin_icon.GetBitmap() #wx.BitmapFromImage(play_icon.getImage().Scale(10,10))
        self.bmpLeftTriangle = self.bmpRightTriangle.ConvertToImage().Mirror().ConvertToBitmap()
        bmpRight = wx.BitmapFromImage(bmpRight)
        bmpLeft = bmpRight.ConvertToImage().Mirror().ConvertToBitmap()
        self.bmpVidUp = self.bmpPlay.ConvertToImage().Rotate90(False).ConvertToBitmap()
        self.bmpVidDown = self.bmpPlay.ConvertToImage().Rotate90().ConvertToBitmap()
        bmpSkipRight = wx.BitmapFromImage(bmpSkipRight)
        bmpSkipLeft = bmpSkipRight.ConvertToImage().Mirror().ConvertToBitmap()
        return (
            (self.bmpVidUp, self.OnMenuVideoToggle, _('Toggle the video preview')),
            (bmpSkipLeft, self.OnButtonVideoGotoPreviousBookmark,_('Previous bookmark')),
            (bmpLeft, self.OnMenuVideoPrevFrame, _('Jump back. Right click for options')),
            (bmpRight, self.OnMenuVideoNextFrame, _('Jump forward. Right click for options')),
            (bmpSkipRight, self.OnButtonVideoGotoNextBookmark,_('Next bookmark')),
            (self.bmpPlay, self.OnMenuVideoPlay, _('Play/pause video. Right click for options.')),
            (bmpExternal, self.OnMenuVideoExternalPlayer, _('Run the script with an external program')),
        )

    def createToolsMenu(self, shortcutList, oldShortcuts):
        menuInfo = []
        self.toolsImportNames = {}
        appendedList = ['toolsmenu']
        # First add items defined by ToolsMenu.py
        try:
            items = __import__('ToolsMenu').menuInfo
        except ImportError:
            items = []
        for item in items:
            if len(item) == 3:
                importName, menuLabel, statusString = item
                id = wx.NewId()
                self.toolsImportNames[id] = importName
                appendedList.append(importName.lower())
                menuInfo.append((menuLabel, '', self.OnMenuToolsRunSelected, statusString, id))
            else:
                menuInfo.append('')
        baseSize = len(menuInfo)
        # Then add any additional python files
        if os.path.isdir(self.toolsfolder):
            namelist = os.listdir(self.toolsfolder)
            namelist.sort()
            for name in namelist:
                root, ext = os.path.splitext(name)
                if ext.lower().startswith('.py') and root.lower() not in appendedList:
                    f = open(os.path.join(self.toolsfolder, name))
                    text = f.read()
                    f.close()
                    if not re.findall(r'\bdef\s+avsp_run\s*\(\):', text):
                        continue
                    splitroot = root.split(']',1)
                    if len(splitroot) == 2 and root.startswith('['):
                        menuLabel = splitroot[1].strip()
                    else:
                        menuLabel = root
                    if len(menuInfo) == baseSize:
                        menuInfo.append('')
                    if menuLabel.strip().startswith('---'):
                        menuInfo.append('')
                    else:
                        id = wx.NewId()
                        self.toolsImportNames[id] = root
                        appendedList.append(root.lower())
                        menuInfo.append((menuLabel, '', self.OnMenuToolsRunSelected, _('Run the selected tool'), id))
        if len(menuInfo) == 0:
            menuInfo.append((''))
        menu = self.createMenu(menuInfo, _('&Tools'), shortcutList, oldShortcuts)
        self.toolsMenuPos = 3
        self.GetMenuBar().Insert(self.toolsMenuPos, menu, _('&Tools'))

    def createMacroMenu(self, shortcutList, oldShortcuts):
        menuInfo = []
        self.macrosImportNames = {}
        self.macrosStack = []
        if os.path.isdir(self.macrofolder):
            def createMenuList(menuList, namelist, dirname):
                namelist.sort()
                for name in namelist:
                    fullname = os.path.join(dirname, name)
                    if os.path.isdir(fullname):
                        submenuList = []
                        createMenuList(submenuList, os.listdir(fullname), fullname)
                        if submenuList:
                            splitname = name.split(']',1)
                            if len(splitname) == 2 and name.startswith('['):
                                name = splitname[1].strip()
                            menuList.append((_(name), submenuList))
                for name in namelist:
                    fullname = os.path.join(dirname, name)
                    root, ext = os.path.splitext(name)
                    if ext.lower() == '.py':
                        splitroot = root.split(']',1)
                        if len(splitroot) == 2 and root.startswith('['):
                            root = splitroot[1].strip()
                        if root.strip().startswith('---'):
                            menuList.append('')
                        else:
                            id = wx.NewId()
                            self.macrosImportNames[id] = fullname
                            if root.strip().startswith('ccc'):
                                root = root.strip()[3:].strip()
                                if not root:
                                    root = self.getMacrosLabelFromFile(fullname)
                                menuList.append((_(root), '', self.OnMenuMacroRunSelected, _('A macro check item'), (wx.ITEM_CHECK, False, id)))
                            elif root.strip().startswith('CCC'):
                                root = root.strip()[3:].strip()
                                if not root:
                                    root = self.getMacrosLabelFromFile(fullname)
                                menuList.append((_(root), '', self.OnMenuMacroRunSelected, _('A macro check item'), (wx.ITEM_CHECK, True, id)))
                            elif root.strip().startswith('rrr'):
                                if not root:
                                    root = self.getMacrosLabelFromFile(fullname)
                                root = root.strip()[3:].strip()
                                menuList.append((_(root), '', self.OnMenuMacroRunSelected, _('A macro radio item'), (wx.ITEM_RADIO, False, id)))
                            elif root.strip().startswith('RRR'):
                                if not root:
                                    root = self.getMacrosLabelFromFile(fullname)
                                root = root.strip()[3:].strip()
                                menuList.append((_(root), '', self.OnMenuMacroRunSelected, _('A macro radio item'), (wx.ITEM_RADIO, True, id)))
                            else:
                                if not root:
                                    root = self.getMacrosLabelFromFile(fullname)
                                menuList.append((_(root), '', self.OnMenuMacroRunSelected, _('Run selected macro'), id))
            createMenuList(menuInfo, os.listdir(self.macrofolder), self.macrofolder)

            menuInfo.append((''))
            menuInfo.append(('macros_readme.txt', '', self.OnMenuMacrosReadme, _('View the readme for making macros')))
            menuInfo.append((_('Open macros folder'), '', self.OnMenuMacrosFolder, _('Open the macros folder')))
        else:
            menuInfo.append((''))
        menu = self.createMenu(menuInfo, _('&Macros'), shortcutList, oldShortcuts)
        self.macroMenuPos = 4
        self.GetMenuBar().Insert(self.macroMenuPos, menu, _('&Macros'))

    def createScriptNotebook(self):
        # Create the notebook

        class Notebook(wx.Notebook):

            def SetPageText(self, index, text):
                script = self.GetPage(index)
                if script.group is not None:
                    text = u'[{0}] {1}'.format(script.group, text)
                aviOK = self.app.previewOK(script)
                if script.GetModify():
                    text =  '* ' + text if aviOK else '>* ' + text
                elif not aviOK:
                    text = '>' + text
                return wx.Notebook.SetPageText(self, index, text)

            def GetPageText(self, index, full=False):
                text = wx.Notebook.GetPageText(self, index)
                if not full:
                    script = self.GetPage(index)
                    if text.startswith('>'):
                        text = text[1:]
                    if script.GetModify():
                        text = text[2:]
                    if script.group is not None and text.startswith('['):
                        text = text[4:]
                return text

            def UpdatePageText(self, index):
                text = wx.Notebook.GetPageText(self, index)
                script = self.GetPage(index)
                if text.startswith('>'):
                    text = text[1:]

                if script.old_modified:
                    text = text[2:]

                if script.old_group != script.group:
                    if script.old_group is not None and text.startswith('['):
                        text = text[4:]
                    if script.group is not None:
                        text = u'[{0}] {1}'.format(script.group, text)

                modified = script.GetModify()
                aviOK = self.app.previewOK(script)
                if modified:
                    text =  '* ' + text if aviOK else '>* ' + text
                elif not aviOK:
                    text = '>' + text
                script.old_modified = modified
                script.old_group = script.group
                return wx.Notebook.SetPageText(self, index, text)

        style = wx.NO_BORDER
        if self.options['multilinetab']:
            style |= wx.NB_MULTILINE
        if self.options['fixedwidthtab']:
            style |= wx.NB_FIXEDWIDTH
        nb = Notebook(self.mainSplitter, wx.ID_ANY, style=style)
        nb.PPIScale = 1
        if (self.ppi_factor > 1) or (self.options['ppiscalingscripttabs'] != 0):
            if self.options['ppiscalingscripttabs'] != 0:
                s_tab = self.options['ppiscalingscripttabs'] / 10.0
            else:
                s_tab = 0
            f = max(self.ppi_factor + s_tab, 1)
            if f > 1:
                #nb.SetTabSize((-1, int(22*f)))
                font = nb.GetFont()
                font.Scale(f)
                nb.SetFont(font)
                nb.PPIScale = f
        nb.app = self
        # Create the right-click menu
        menuInfo = (
            (_('Close'), '', self.OnMenuFileClose),
            #(_('Close all others'), '', self.OnMenuFilesOthersClose),
            # Bad if multitabline style
            #(_('Close...'),
                #(
                #(_('Close all others'), '', self.OnMenuFilesOthersClose),
                #(_('Close all left'), '', self.OnMenuFilesCloseLeft),
                #(_('Close all right'), '', self.OnMenuFilesCloseRight),
                #),
            #),
            (_('Rename'), '', self.OnMenuFileRenameTab),
            (_('Group'),
                (
                (_('None'), '', self.OnGroupAssignTabGroup, _('Not include this tab on any group'), wx.ITEM_RADIO, True),
                ('1', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                ('2', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                ('3', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                ('4', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                ('5', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                ('6', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                ('7', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                ('8', '', self.OnGroupAssignTabGroup, _('Add tab to this group'), wx.ITEM_RADIO, False),
                (''),
                (_('Clear current tab group'), '', self.OnGroupClearTabGroup, _('Clear current tab group')),
                (_('Clear all tab groups'), '', self.OnGroupClearAllTabGroups, _('Clear all tab groups')),
                (''),
                (_('Apply offsets'), '', self.OnGroupApplyOffsets, _('Use the difference between showed frames when the tabs were added to the group as offsets'),
                    wx.ITEM_CHECK, self.options['applygroupoffsets']),
                (_('Offset also bookmarks'), '', self.OnGroupOffsetBookmarks, _('Apply the offset also to the currently set bookmarks'),
                    wx.ITEM_CHECK, self.options['offsetbookmarks']),
                (''),
                (_('Freeze Split View frame'), '', self.OnMenuSplitViewFreeze, _("If Split View then freeze the frame number"), wx.ITEM_CHECK, False),
                #(_('Locate frame'), '', self.OnMenuLocateFrame, _("Reade the LocateFrame readme")),
                ),
            ),
            (''),
            (_('Save'), '', self.OnMenuFileSaveScript),
            (_('Save as...'), '', self.OnMenuFileSaveScriptAs),
            (_('Reload'), '', self.OnMenuFileReloadScript),
            (_('Reload all'), '', self.OnMenuFileReloadAllScripts),
            (_('Open directory'), '', self.OnMenuFileOpenScriptDirectory),
            (''),
            (_('Bookmarks to script'), '', self.OnMenuBookmarksToScript),     # GPo, 2018
            (_('Bookmarks from script'), '', self.OnMenuBookmarksFromScript), # GPo, 2018
            (''),
            (_('Release video memory'), '', self.OnMenuScriptReleaseMemory), # GPo 2020
            (_('Release all other video memory'), '', self.OnMenuOtherScriptReleaseMemory), # GPo 2020
            (''),
            (_('Tab change loads bookmarks'), '', self.OnMenuTabChangeLoadBookmarks, '', wx.ITEM_CHECK, self.options['tabsbookmarksfromscript']), # GPo 2019
            (_('Save view pos on tab change'), '', self.OnMenuVideoSaveViewPos, _('Save/Restore last display viewing position on tab change'), wx.ITEM_CHECK, False),
            (_('Save pos && zoom on tab change'), '', self.OnMenuVideoSaveZoom, _('Save/Restore last zoom settings on tab change'), wx.ITEM_CHECK, False),
            (_('Resize video window'), '', self.OnMenuVideoResizeOnZoom, _('Adjusts the video window height to the output height (zooming with Keyboard)'), wx.ITEM_CHECK, self.options['resizevideowindow']),
            (''),
            (_('Copy to new tab'), '', self.OnMenuEditCopyToNewTab),
            (_('Split View insert tab'), '', self.OnMenuCopyToNewTabNext),
            (''),
            (_('Auto preview'), '', self.OnMenuAutoHidePreview, '', wx.ITEM_CHECK, self.options['tabautopreview']),
            (''),
            (_('Sort by name'), '', self.OnSortTabsAlpha),
            (_('Reposition to'),                                       # index must be the last or you must change the ContextMenu
                (
                (''),
                ),
            ),
        )
        menu = self.createMenu(menuInfo)
        nb.contextMenu = menu
        nb.dragging = False
        nb.LockPage = False
        nb.oldpage = None

        if self.options['usetabimages']:
            color1 = wx.SystemSettings.GetColour(wx.SYS_COLOUR_SCROLLBAR)
            color2 = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)
            color3 = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)
            color4 = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)
            # Create the mask
            sTab = 0 if self.options['ppiscalingscripttabs'] == 0 else float(self.options['ppiscalingscripttabs']/10.0)
            factor = max(self.ppi_factor + sTab, 1)
            w = h = int(factor*15)
            bmpMask = wx.EmptyBitmap(w, h)
            mdc = wx.MemoryDC()
            mdc.SelectObject(bmpMask)
            mdc.DrawRoundedRectangle(0,0,w,h,int(factor*3))
            mdc = None
            mask = wx.Mask(bmpMask)
            # Create the bitmap
            bmpBase = wx.EmptyBitmap(w, h)
            bmpBase.SetMask(mask)
            mdc = wx.MemoryDC()
            mdc.SelectObject(bmpBase)
            mdc.SetBackground(wx.Brush(color1))
            mdc.Clear()
            mdc.SetPen(wx.Pen(color2))
            mdc.SetBrush(wx.Brush(color2))
            mdc.DrawPolygon([wx.Point(0,h), wx.Point(w,h), wx.Point(w,0)])
            mdc.SetPen(wx.Pen(color3))
            mdc.SetBrush(wx.Brush(color3))
            th = 3
            mdc.DrawRoundedRectangle(th,th,w-int(factor*2)*th,h-int(factor*2)*th,0)
            mdc = None
            imageBase = bmpBase.ConvertToImage()
            il = wx.ImageList(w, h)
            for i in xrange(10):
                bmp = wx.BitmapFromImage(imageBase)
                mdc = wx.MemoryDC()
                mdc.SelectObject(bmp)
                mdc.SetTextForeground(color4)
                mdc.SetFont(wx.Font(int(factor*8), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, faceName='courier new'))
                mdc.DrawText(str((i+1) % 10), int(factor*4),0)
                mdc = None
                il.Add(bmp)
            nb.AssignImageList(il)
        # Event binding
        nb.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDownNotebook)
        nb.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDownNotebook)
        nb.Bind(wx.EVT_LEFT_UP, self.OnLeftUpNotebook)
        nb.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClickNotebook)
        nb.Bind(wx.EVT_RIGHT_UP, self.OnRightClickNotebook)
        nb.Bind(wx.EVT_MOTION, self.OnMouseMotionNotebook)
        nb.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheelNotebook)
        return nb

    def GetThemeColor(self, ident, typ):
        attr = self.options['textstyles'][ident].split(',')
        for i in xrange(len(attr)):
            if attr[i].startswith(typ):
                hex = attr[i].split('#')[1]
                r,g,b = tuple(int(hex[i:i+2], 16) for i in (0, 2 ,4))
                return wx.Colour(r,g,b)

    # GPo 2021
    class sliderWindowEx(wx.ScrolledWindow):
        #def __init__(self, parent, app, id=wx.ID_ANY, pos=(0,0), size=(10,10), style=wx.STATIC_BORDER|wx.TAB_TRAVERSAL|wx.FULL_REPAINT_ON_RESIZE):
        def __init__(self, parent, app, id=wx.ID_ANY, pos=(0,0), size=(10,10), style=wx.STATIC_BORDER|wx.CLIP_CHILDREN):
        #def __init__(self, parent, app, id=wx.ID_ANY, pos=(0,0), size=(10,10), style=wx.STATIC_BORDER|wx.NO_FULL_REPAINT_ON_RESIZE|wx.TAB_TRAVERSAL|wx.CLIP_CHILDREN):
            wx.ScrolledWindow.__init__(self, parent, id, pos=pos, size=size, style=style)
            # dpi font size
            f = app.options['ppiscalingsliderwindow']
            if f != 0:
                f = f/10.0
            factor = max(app.ppi_factor + f, 1)
            if factor > 1:
                font = self.GetFont()
                dpi.SetFontSize(font, factor)
                self.SetFont(font)

            self.SetDoubleBuffered(True)
            self.SetScrollRate(intPPI(40), intPPI(40))
            # if not wx.FULL_REPAINT_ON_RESIZE set, we must repaint it on resize if double buffered
            def _OnSize(event):
                self.Refresh()
                event.Skip()
            self.Bind(wx.EVT_SIZE, _OnSize)
            def OnPaint(event):
                #dc = wx.BufferedPaintDC(self)
                dc = wx.PaintDC(self)
                dc.SetBackground(wx.Brush(self.GetBackgroundColour()))
                dc.Clear()
                if self.app.splitView:
                    dc.SetFont(self.GetFont())
                    dc.SetTextForeground(self.GetForegroundColour())
                    dc.DrawText('SplitView L' if self.app.splitView_next else 'SplitView R', intPPI(5), self.app.currentScript.chkPreviewFilter.GetPosition()[1])
                """
                elif self.previewFilterTime > 0:
                    if self.app.ShowPFilterTime and self.app.currentScript.previewFilterIdx > 0:
                        dc.SetFont(self.GetFont())
                        dc.SetTextForeground(self.GetForegroundColour())
                        dc.DrawText('Preview Filter: %.4f' % (self.previewFilterTime), intPPI(5), self.app.currentScript.chkPreviewFilter.GetPosition()[1])
                    else:
                        self.previewFilterTime = 0
                """
                event.Skip()
            self.Bind(wx.EVT_PAINT, OnPaint)

            self.parent = parent
            self.app = app
            self.foreTextCtrl = None
            self.backTextCtrl = None
            self.foreDefValue = None
            self.boldDefValue = None
            self.foreExtraBtn1 = None
            self.backSlider = None
            self.customTheme = False
            self.previewFilterTime = 0
            def OnMouseAux1Down(event):
                self.app.GotoNextBookmark(reverse=True, forceCursor=True)
            def OnMouseAux2Down(event):
                self.app.GotoNextBookmark(reverse=False, forceCursor=True)
            """
            def OnMouseWheel(event): # Win10
                if app.options['mousewheelfunc'] == 'frame_step':
                    self.app.OnMouseWheelVideoWindow(event)
            """
            """
            def OnMouseMove(event):
                pass
            self.Bind(wx.EVT_MOTION, OnMouseMove)
            """

            self.Bind(wx.EVT_MOUSE_AUX1_DOWN, OnMouseAux1Down)
            self.Bind(wx.EVT_MOUSE_AUX2_DOWN, OnMouseAux2Down)
            """
            if app.WinVersion >= 8:
                self.Bind(wx.EVT_MOUSEWHEEL, OnMouseWheel)
            """
            if self.app.options['sliderwindowcustomtheme']:
                self.SetThemeColors()

        def SetSystemColors(self):
            self.customTheme = False
            self.SetBackgroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW))
            self.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))
        def SetThemeColors(self):

            def GetColour(ident, typ):
                color = self.app.GetThemeColor(ident, typ)
                if color:
                    return color
                raise

            try:
                self.SetForegroundColour(GetColour('sliderwindow', 'fore'))
                self.SetBackgroundColour(GetColour('sliderwindow', 'back'))
                self.foreTextCtrl = GetColour('sliderwindowtextctrl', 'fore')
                self.backTextCtrl = GetColour('sliderwindowtextctrl', 'back')
                self.foreDefValue = GetColour('sliderwindowdefvalue', 'fore')
                self.forePrevFilter = GetColour('sliderwindowprevfilter', 'fore')
                self.forePrevFilter2 = GetColour('sliderwindowprevfilter', 'back')
                self.boldDefValue = True
                self.foreExtraBtn1 = GetColour('sliderwindowextrabtn1', 'fore')
                if self.app.options['usesliderwindowbackslider']:
                    self.backSlider = GetColour('sliderwindowbackslider', 'back')
                else:
                    self.backSlider = self.GetBackgroundColour()
            except:
                self.SetSystemColors()
                return
            self.customTheme = True
            return True
        """
        def PaintPFilterTime(self):
            if self.previewFilterTime > 0:
                dc = wx.ClientDC(self)
                dc.SetFont(self.GetFont())
                dc.SetTextForeground(self.GetForegroundColour())
                dc.DrawText('Preview Filter: %.4f' % (self.previewFilterTime), intPPI(5), self.app.currentScript.chkPreviewFilter.GetPosition()[1])
            else:
                self.RefreshRect(wx.Rect(0, self.app.currentScript.chkPreviewFilter.GetPosition()[1], self.GetSize()[0], self.GetCharHeight()))
        """

    def createScriptWindow(self):
        int5 = intPPI(5)
        round5 = roundPPI(5)
        # Create the instance of the window                         # GPo 2020, size,pos wx 2.9
        scriptWindow = AvsStyledTextCtrl(self.scriptNotebook, self, pos=(-50,-50), size=(10,10), style=wx.STATIC_BORDER)
        # Bind variables to the window instance
        scriptWindow.filename = ""
        scriptWindow.workdir = ""
        scriptWindow.encoding = 'latin1'
        scriptWindow.eol = None
        scriptWindow.AVI = None
        scriptWindow.display_clip_refresh_needed = False
        scriptWindow.previewtxt = []
        scriptWindow.sliderTexts = []
        scriptWindow.sliderProperties = []
        scriptWindow.toggleTags = []
        scriptWindow.autoSliderInfo = []
        scriptWindow.lastSplitVideoPos = None
        scriptWindow.lastSplitVideoPosShown = None
        scriptWindow.lastSplitSliderPos = self.options['sliderwindowwidth']
        scriptWindow.userHidSliders = False
        scriptWindow.lastFramenum = 0
        scriptWindow.lastLength = None
        scriptWindow.group = None
        scriptWindow.group_frame = 0
        scriptWindow.old_group = None
        scriptWindow.old_modified = False
        scriptWindow.sliderWindowShown = not self.options['keepsliderwindowhidden']
        scriptWindow.autocrop_values = None
        scriptWindow.bookmarks = {}         # GPo
        scriptWindow.selections = {}        # GPo
        scriptWindow.SliderFoldsBackup = {} # GPo
        scriptWindow.previewFilterIdx = 0       # GPo actice index
        scriptWindow.lastpreviewFilterIdx = 0   # GPo does not reset on disable only on Error
        scriptWindow.AviThread = None       # booth threads (clip and frame thread if not 'usenewframethread')
        scriptWindow.FrameThread = self.FrameThread(scriptWindow) if self.options['usenewframethread'] and self.options['avithread'] else None # FrameThread is a bit faster
        scriptWindow.PlayThread = None
        scriptWindow.matrix = self.options['defaultmatrix'].split(',') # ['auto', 'tv']
        scriptWindow.snapShots = {
            'shot1': utils.emptySnapShot,  # [-1, None, "", 0] FrameNr, Bitmap, script, previewFilterIdx
            'shot2': utils.emptySnapShot   # also used for autosnapshot
            }
        scriptWindow.resizeFilter = (False, self.options['resizefilter'], 1, True)
        scriptWindow.lastZoom = None # GPo, 2021 script last zoom settings
        scriptWindow.refreshAVI = True  # GPo self.refreshAVI isn't optimal, it is Global!
        scriptWindow.disableFastClipOnce = False
        try:
            scriptWindow.contextMenu = self.menuBackups[0] if self.menuBackups else self.GetMenuBar().GetMenu(1)
        except AttributeError:
            pass
        # GPo slider window checkbox ( Disable refresh )
        def OnChekboxDisableRefresh(event):
            ctrl = event.GetEventObject()
            if not ctrl.IsChecked():
                scriptChanged = self.ScriptChanged(self.currentScript)
                self.SliderShowVideoFrame(True, scriptChanged, self.currentScript, scriptChanged)

        def OnCheckboxPreviewFilter(event):
            ctrl = event.GetEventObject()
            script = self.currentScript
            idx = 0 if not ctrl.IsChecked() else script.lastpreviewFilterIdx if script.lastpreviewFilterIdx > 0 else 1
            self.OnMenuPreviewFilter(index=idx, updateUserSliders=True)

        def OnRightUpScriptWindow(event):
            event.Skip()
            ctrl = event.GetEventObject() # same as self.currentScript
            ctrl.IsDClicked = False
            if event.LeftIsDown():
                pos = ctrl.GetCurrentPos()
                start = ctrl.WordStartPosition(pos,1)
                end = ctrl.WordEndPosition(pos,1)
                word = ctrl.GetRange(start, end)
                if word == 'avsp_split':
                    word = ctrl.GetRange(start-3, end)
                    if word == '/**avsp_split':
                        ctrl.InsertText(start, ' ')
                    elif word == '** avsp_split':
                        ctrl.SetTargetStart(start-1)
                        ctrl.SetTargetEnd(start)
                        ctrl.ReplaceTarget('')
                    pos = ctrl.GetCurrentPos()
                    wx.CallLater(700, ctrl.SetSelection, pos, pos)
                    return
                """
                elif word.lower() == 'false':
                    ctrl.SetTargetStart(start)
                    ctrl.SetTargetEnd(end)
                    ctrl.ReplaceTarget('True' if word.isupper() else 'true')
                    #ctrl.ReplaceSelection('True' if word.isupper() else 'true')
                    return
                elif word.lower() == 'true':
                    ctrl.SetTargetStart(start)
                    ctrl.SetTargetEnd(end)
                    #ctrl.ReplaceTarget('False' if word.isupper() else 'false')
                    #ctrl.SetSelection(start, end)
                    #ctrl.ReplaceSelection('False' if word.isupper() else 'false')
                    return
                """
                sel = ctrl.GetSelectedText()
                if sel.lower() == 'false':
                    ctrl.ReplaceSelection('True' if sel[:1].isupper() else 'true')
                elif sel.lower() == 'true':
                    ctrl.ReplaceSelection('False' if sel[:1].isupper() else 'false')
                else:
                    ctrl.BlockComment('#', ['~','#','>'], False)
                pos = ctrl.GetCurrentPos()
                wx.CallLater(700, ctrl.SetSelection, pos, pos)
                """
                event = wx.CommandEvent(wx.wxEVT_LEFT_UP, ctrl.GetId())
                event.SetEventObject(ctrl)
                ctrl.GetEventHandler().ProcessEvent(event)
                """
        def AddProperties(isTop=True):
            propLabel = wx.StaticText(scriptWindow.sliderWindow, wx.ID_ANY, label=_('Frame properties'))
            propLabel.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
            propLabel.Bind(wx.EVT_LEFT_DOWN, lambda event: self.propWindow.Toggle())
            if isTop: scriptWindow.videoSidebarSizer.Add(propLabel, 0, wx.ALIGN_CENTER)
            else: scriptWindow.videoSidebarSizer.Add(propLabel, 0, wx.ALIGN_CENTER|wx.TOP, int5)
            scriptWindow.videoSidebarSizer.Add(wx.StaticLine(scriptWindow.sliderWindow), 0, wx.EXPAND|wx.LEFT|wx.RIGHT, int5)
            scriptWindow.videoSidebarSizer.Add(scriptWindow.propertySizer, 0, wx.EXPAND|wx.LEFT, int5)

        # GPo 2020, sliderWindowEx
        scriptWindow.sliderWindow = self.sliderWindowEx(self.videoSplitter, self)
        scriptWindow.sliderSizer = wx.GridBagSizer(hgap=0, vgap=intPPI(10))
        if wx.VERSION < (2, 9):
            scriptWindow.sliderSizer.AddGrowableCol(3)
        scriptWindow.sliderSizerNew = wx.GridBagSizer(hgap=0, vgap=0)
        if wx.VERSION < (2, 9):
            scriptWindow.sliderSizerNew.AddGrowableCol(3)
        scriptWindow.sliderSizerNew.SetEmptyCellSize((0,0))
        scriptWindow.toggleTagSizer = wx.BoxSizer(wx.VERTICAL)
        ### GPo new, disable slider refresh and preview filter checkbox
        toolBoxSizer = wx.BoxSizer(wx.HORIZONTAL)
        # preview filter box
        scriptWindow.chkPreviewFilter = wx.CheckBox(scriptWindow.sliderWindow, wx.ID_ANY, label=_('Preview filter '))
        scriptWindow.chkPreviewFilter.SetValue(False)
        scriptWindow.chkPreviewFilter.Bind(wx.EVT_CHECKBOX, OnCheckboxPreviewFilter)
        toolBoxSizer.Add(scriptWindow.chkPreviewFilter, 1, wx.TOP|wx.RIGHT|wx.ALIGN_RIGHT, round5)
        # refresh box
        scriptWindow.chkDisableRefresh = wx.CheckBox(scriptWindow.sliderWindow, wx.ID_ANY, label=_('Disable refresh '))
        scriptWindow.chkDisableRefresh.SetValue(self.options['sliderdisablerefresh'])
        scriptWindow.chkDisableRefresh.Bind(wx.EVT_CHECKBOX, OnChekboxDisableRefresh)
        toolBoxSizer.Add(scriptWindow.chkDisableRefresh, 0, wx.TOP|wx.RIGHT|wx.ALIGN_RIGHT, round5)
        ###
        scriptWindow.videoSidebarSizer = wx.BoxSizer(wx.VERTICAL)
        scriptWindow.videoSidebarSizer.Add(scriptWindow.toggleTagSizer, 0, wx.TOP|wx.LEFT, int5)
        scriptWindow.videoSidebarSizer.Add(toolBoxSizer, 0, wx.RIGHT|wx.ALIGN_RIGHT, int5)
        ### GPo new, frame properties parent textCtrl
        scriptWindow.propertySizer = wx.BoxSizer(wx.VERTICAL)
        if self.propWindowParent > 0:
            scriptWindow.propertySizer.Add(self.propWindow.textCtrl, 0, wx.EXPAND|wx.TOP|wx.RIGHT, int5)
            i = self.options['propwindowparentsize']
            self.propWindow.textCtrl.SetMinSize((50, i))
            scriptWindow.propertySizer.SetMinSize((50,i))
            scriptWindow.propertySizer.SetDimension((0,0), (50,i))
            if self.propWindowParent == 1: # On Top
                AddProperties()

        scriptWindow.videoSidebarSizer.Add(scriptWindow.sliderSizerNew, 0, wx.EXPAND|wx.LEFT, int5)
        scriptWindow.videoSidebarSizer.Add(scriptWindow.sliderSizer, 0, wx.EXPAND|wx.LEFT, int5)
        if self.propWindowParent == 2: # On Bottom
            AddProperties(False)

        if self.propWindowParent < 1: # add propertySizer anyway (give it a parent)
            scriptWindow.videoSidebarSizer.Add(scriptWindow.propertySizer, 0, wx.EXPAND|wx.LEFT, int5)

        scriptWindow.sliderWindow.SetSizer(scriptWindow.videoSidebarSizer)
        scriptWindow.sliderWindow.Bind(wx.EVT_LEFT_DOWN, lambda event: self.videoWindow.SetFocus())
        scriptWindow.oldSliderTexts = []
        scriptWindow.oldAutoSliderInfo = []
        scriptWindow.oldToggleTags = []
        scriptWindow.sliderToggleLabels = []

        # Event binding
        scriptWindow.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)
        scriptWindow.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDownScriptWindow)
        scriptWindow.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUpScriptWindow)
        scriptWindow.Bind(wx.EVT_SET_FOCUS, self.OnFocusScriptWindow)
        scriptWindow.Bind(stc.EVT_STC_UPDATEUI, self.OnScriptTextChange)
        scriptWindow.Bind(stc.EVT_STC_SAVEPOINTLEFT, lambda event: self.UpdateScriptTabname(event.GetEventObject()))
        scriptWindow.Bind(stc.EVT_STC_SAVEPOINTREACHED, lambda event: self.UpdateScriptTabname(event.GetEventObject()))
        scriptWindow.Bind(wx.EVT_KEY_UP, self.OnScriptKeyUp)
        scriptWindow.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost) # GPo 2020
        scriptWindow.sliderWindow.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost) # GPo 2020
        scriptWindow.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheelScriptWindow)
        scriptWindow.Bind(wx.EVT_RIGHT_UP, OnRightUpScriptWindow)
        self.BindObjMouseAux(scriptWindow) # GPo 2020

        # Drag-and-drop target
        scriptWindow.SetDropTarget(self.scriptDropTarget(scriptWindow, self))
        return scriptWindow

    def createVideoWindow(self, parent):
        videoWindow = wx.ScrolledWindow(parent, pos=(0,0), style=wx.STATIC_BORDER|wx.WANTS_CHARS|wx.FULL_REPAINT_ON_RESIZE)
        videoWindow.SetScrollRate(1, 1)
        if self.options['hidescrollbars']:
            videoWindow.ShowScrollbars(wx.SHOW_SB_NEVER, wx.SHOW_SB_NEVER)
        # Event binding
        videoWindow.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)
        videoWindow.Bind(wx.EVT_SET_FOCUS, self.OnFocusVideoWindow)
        videoWindow.Bind(wx.EVT_PAINT, self.OnPaintVideoWindow)
        videoWindow.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        videoWindow.Bind(wx.EVT_KEY_DOWN, self.OnKeyDownVideoWindow)
        videoWindow.Bind(wx.EVT_KEY_UP, self.OnKeyUpVideoWindow)
        videoWindow.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheelVideoWindow)
        videoWindow.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDownVideoWindow)
        videoWindow.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDownVideoWindow)
        videoWindow.Bind(wx.EVT_MOTION, self.OnMouseMotionVideoWindow)
        videoWindow.Bind(wx.EVT_LEAVE_WINDOW, self.OnMouseLeaveVideoWindow)
        videoWindow.Bind(wx.EVT_LEFT_UP, self.OnLeftUpVideoWindow)
        videoWindow.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClickVideoWindow)    # GPo 2018
        videoWindow.Bind(wx.EVT_RIGHT_UP, self.OnRightUpVideoWindow)          # GPo 2018
        videoWindow.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)  # GPo 2020
        videoWindow.Bind(wx.EVT_SCROLLWIN, self.OnScrollVideoWindow)          # GPo 2020
        self.BindObjMouseAux(videoWindow)                                     # GPo 2020
        return videoWindow

    def OnStatusBarContextMenu(self, event=None):
        def OnMenuCustomRange(event):
            self.StopPlayback()
            sel = ''
            start, stop = self.ValueInSliderSelection(self.GetFrameNumber(), returnStartStop=True)
            if start is not None:
                sel = '%i,%i' % (start, stop)
            dlg = wx.TextEntryDialog(self, _('Frame range 30 to n.. or set start,end separated by comma'), _('Custom frame range'), sel)
            ID = dlg.ShowModal()
            label = dlg.GetValue()
            dlg.Destroy()
            if ID == wx.ID_OK:
                label = label.strip()
                splitval = label.split(',')
                if len(splitval) == 2:
                    valStart = splitval[0].strip()
                    valEnd = splitval[1].strip()
                    if valStart.isdigit() and valEnd.isdigit():
                        self.OnMenuSetTimeLineRange(r_start=int(valStart), r_end=int(valEnd))
                        return
                elif label != '' and label.isdigit():
                    val = max(30, int(label))
                    self.OnMenuSetTimeLineRange(frange=val)
                    return
                wx.Bell()
        def OnMenuProcent(event):
            id = popup.FindItem(_('Percent'))
            subMenu = popup.FindItemById(id).GetSubMenu()
            item = subMenu.FindItemById(event.GetId())
            i = item.GetLabel().replace('%', '')
            if not i.isdigit():
                return
            val = round(float(self.videoSlider.GetMax())/100.0*float(i))
            val += val % 2
            self.OnMenuSetTimeLineRange(frange=max(30, val))
        def OnMenuShowNothing(event):
            for slider in self.GetVideoSliderList():
                slider.showNumbers = not event.IsChecked()
                slider.SetValue(self.GetFrameNumber())
        def OnMenuShowTime(event):
            for slider in self.GetVideoSliderList():
                slider.showTime = event.IsChecked()
                slider.SetValue(self.GetFrameNumber())
        def OnMenuAutoReset(event):
            self.options['timelineautoreset'] = event.IsChecked()
            self.timelineAutoReset = event.IsChecked()
        def OnMenuAutoScroll(event):
            self.options['timelineautoscroll'] = event.IsChecked()
            self.timelineAutoScroll = event.IsChecked()
        def OnMenuSetValue(event):
            item = popup.FindItemById(event.GetId())
            label = item.GetLabel()
            val = 0 if label == '100 %' else label[:-len(' frames')]
            self.OnMenuSetTimeLineRange(frange=val)
            self.SetVideoStatusText()
        def createMenu(label):
            if label:
                id = wx.NewId()
                if label == _('Show nothing'):
                    popup.Append(id, label, kind=wx.ITEM_CHECK)
                    popup.Check(id, not self.videoSlider.showNumbers)
                    self.Bind(wx.EVT_MENU, OnMenuShowNothing, id=id)
                elif label == _('Show time'):
                    popup.Append(id, label, kind=wx.ITEM_CHECK)
                    popup.Check(id, self.videoSlider.showTime)
                    self.Bind(wx.EVT_MENU, OnMenuShowTime, id=id)
                elif label == _('Auto scroll'):
                    popup.Append(id, label, kind=wx.ITEM_CHECK)
                    popup.Check(id, self.timelineAutoScroll)
                    self.Bind(wx.EVT_MENU, OnMenuAutoScroll, id=id)
                elif label == _('Auto reset'):
                    popup.Append(id, label, kind=wx.ITEM_CHECK)
                    popup.Check(id, self.timelineAutoReset)
                    self.Bind(wx.EVT_MENU, OnMenuAutoReset, id=id)
                elif label == _('Custom...'):
                    popup.Append(id, label, kind=wx.ITEM_NORMAL)
                    self.Bind(wx.EVT_MENU, OnMenuCustomRange, id=id)
                elif label == _('Percent'):
                    id = None
                    subLabels = ['10%', '25%', '34%', '50%']
                    subMenu = wx.Menu()
                    for lab in subLabels:
                        subid = wx.NewId()
                        subMenu.Append(subid, lab, kind=wx.ITEM_NORMAL)
                        self.Bind(wx.EVT_MENU, OnMenuProcent, id=subid)
                    popup.AppendSubMenu(subMenu, label)
                else:
                    popup.Append(id, label, kind=wx.ITEM_NORMAL)
                    self.Bind(wx.EVT_MENU, OnMenuSetValue, id=id)
            else: popup.AppendSeparator()

        if not self.StatusBarContextMenu:
            menu = [_('Show nothing'), _('Show time'), '', _('Auto reset'), _('Auto scroll'), '', _('Custom...'), _('Percent'), '', '50 frames', '100 frames',
                    '200 frames', '400 frames', '800 frames', '2000 frames', '5000 frames', '', '100 %']
            popup = wx.Menu()
            for item in menu: createMenu(item)
            self.StatusBarContextMenu = popup
        if self.previewWindowVisible:
            self.videoWindow.SetFocus()
        self.PopupMenu(self.StatusBarContextMenu)

    def createVideoControls(self, parent, primary=True):
        f = self.options['ppiscalingvideocontrols']
        if f != 0:
            f = f/10.0
        factor = max(self.ppi_factor + f, 1)
        if wx.VERSION < (2, 9):
            height = int(24*factor)
            panel = wx.Panel(parent, style=wx.BORDER_NONE, size=(-1, height))
        else:
            height = int(30*factor)
            panel = wx.Panel(parent, size=(-1, height))
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        videoControlWidgets = []
        self.videoSlider2 = None
        # Create the playback buttons
        for bitmap, handler, statusTxt in self.buttonInfo():
            button = self.createToolbarButton(panel, bitmap, handler, statusTxt=statusTxt)
            if handler == self.OnMenuVideoToggle:
                if primary:
                    self.toggleButton = button
                else:
                    self.toggleButton2 = button
                    self.toggleButton2.SetBitmapLabel(self.bmpVidDown)
            elif handler == self.OnMenuVideoPlay:
                button.Bind(wx.EVT_CONTEXT_MENU, self.OnPlayButtonContextMenu) # GPo 2020
                if primary:
                    self.play_button = button
                else:
                    self.play_button2 = button
            elif handler == self.OnMenuVideoNextFrame or handler == self.OnMenuVideoPrevFrame:
                button.Bind(wx.EVT_CONTEXT_MENU, self.OnButtonFrameStepContextMenu) # GPo 2020

            button.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost) # GPo 2020
            sizer.Add(button, 0, wx.ALIGN_CENTER_VERTICAL)#, wx.EXPAND)#, wx.ALIGN_BOTTOM)#, wx.ALL, 1)
            videoControlWidgets.append(button)
        # Create the frame textbox
        frameTextCtrl = wx.TextCtrl(panel, wx.ID_ANY, size=(int(80*factor),-1), style=wx.TE_RIGHT|wx.TE_PROCESS_ENTER)
        if factor > 1:
            font = frameTextCtrl.GetFont()
            #~font.SetPointSize(int(font.GetPointSize()*factor))
            dpi.SetFontSize(font, factor)
            frameTextCtrl.SetFont(font) # GPo 2020
        frameTextCtrl.Bind(wx.EVT_TEXT_ENTER, self.OnButtonTextKillFocus)
        frameTextCtrl.Bind(wx.EVT_KILL_FOCUS, self.OnButtonTextKillFocus)
        frameTextCtrl.Bind(wx.EVT_SET_FOCUS, self.OnButtonTextSetFocus)
        frameTextCtrl.Bind(wx.EVT_CONTEXT_MENU, self.OnButtonTextContextMenu)
        frameTextCtrl.Replace(0, -1, str(0))
        sizer.Add(frameTextCtrl, 0, wx.ALIGN_CENTRE_VERTICAL|wx.LEFT, int(4*factor))
        videoControlWidgets.append(frameTextCtrl)
        if primary:
            self.frameTextCtrl = frameTextCtrl
        else:
            self.frameTextCtrl2 = frameTextCtrl
        # Create the video slider
        if primary:
            self.videoSlider = SliderPlus(panel, self, wx.ID_ANY, 0, 0, 240-1, dpiScale=factor,
                                            titleDict=self.titleDict)
            self.videoSlider.Bind(wx.EVT_SCROLL_THUMBTRACK, self.OnSliderChanged)
            self.videoSlider.Bind(wx.EVT_SCROLL_ENDSCROLL, self.OnSliderReleased)
            self.videoSlider.Bind(wx.EVT_RIGHT_UP, self.OnSliderRightUp)
            self.videoSlider.Bind(wx.EVT_MIDDLE_DOWN, self.OnSliderMiddleDown)
            self.videoSlider.Bind(wx.EVT_LEFT_UP, self.OnSliderLeftUp)
            self.videoSlider.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)  # GPo 2020
            sizer.Add(self.videoSlider, 1, wx.EXPAND)
            videoControlWidgets.append(self.videoSlider)
            self.videoSlider.bookmarksHilightColor = wx.Brush(self.options['bookmarkshilightcolor'])  # GPo
            self.videoSlider.selectionsHilightColor = wx.Brush(self.options['selectionshilightcolor'])  # GPo
        else:
            self.videoSlider2 = SliderPlus(panel, self, wx.ID_ANY, 0, 0, 240-1, dpiScale=factor,
                                            titleDict=self.titleDict)
            self.videoSlider2.Bind(wx.EVT_SCROLL_THUMBTRACK, self.OnSliderChanged)
            self.videoSlider2.Bind(wx.EVT_SCROLL_ENDSCROLL, self.OnSliderReleased)
            self.videoSlider2.Bind(wx.EVT_RIGHT_UP, self.OnSliderRightUp)
            self.videoSlider2.Bind(wx.EVT_MIDDLE_DOWN, self.OnSliderMiddleDown)
            self.videoSlider2.Bind(wx.EVT_LEFT_UP, self.OnSliderLeftUp)
            self.videoSlider2.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)  # GPo 2020
            sizer.Add(self.videoSlider2, 1, wx.EXPAND)
            videoControlWidgets.append(self.videoSlider2)
            self.videoSlider2.bookmarksHilightColor = wx.Brush(self.options['bookmarkshilightcolor'])  # GPo
            self.videoSlider2.selectionsHilightColor = wx.Brush(self.options['selectionshilightcolor'])  # GPo
        if primary:
            self.videoControlWidgets = videoControlWidgets
        else:
            self.videoControlWidgets2 = videoControlWidgets

        if self.options['disablepreview'] and primary:
            for ctrl in self.videoControlWidgets:
                ctrl.Disable()
                ctrl.Refresh()

        # GPo,  Win10 hack
        if self.WinVersion >= 8:
            for ctrl in videoControlWidgets:
                if ctrl != frameTextCtrl:
                    ctrl.Bind(wx.EVT_MOUSEWHEEL, self.OnVideoControlsMouseWheel)

        def OnMouseAux1Down(event, isAux2=False):
            if wx.GetKeyState(wx.WXK_SHIFT):
                self.GotoNextBookmark(reverse=not isAux2, forceCursor=True, bmtype=[1,2])
            elif wx.GetKeyState(wx.WXK_ALT):
                self.GotoNextBookmark(reverse=not isAux2, forceCursor=True, bmtype=[3]) # titled bookmarks
            else:
                self.GotoNextBookmark(reverse=not isAux2, forceCursor=True)
        def OnMouseAux2Down(event):
            OnMouseAux1Down(event, True)
        def OnStatusbarLeftDown(event):
            self.mouseDownXY = event.GetPosition()
            statusBar = event.GetEventObject()
            if not statusBar.HasCapture():
                statusBar.CaptureMouse()
            event.Skip()
        def OnStatusbarLeftUp(event):
            statusBar = event.GetEventObject()
            if statusBar.HasCapture():
                statusBar.ReleaseMouse()
                if self.playing_video == '':
                    wx.CallAfter(self.PlayPauseVideo)
            if self.previewWindowVisible:
                self.videoWindow.SetFocus()
            event.Skip()
        def OnStatusbarMouseMove(event):
            if event.LeftIsDown and statusBar.HasCapture() and self.mouseDownXY is not None and self.timelineRange > 0:
                x = event.GetPosition()[0]
                if x != self.mouseDownXY[0]:
                    val = 0 if not event.ShiftDown() else max(int(self.videoSlider.maxValue/self.options['timelinestatusbarmovesense']) *4, 1)
                    fullRange = event.ControlDown() or event.ShiftDown()
                    if self.playing_video:
                        self.CheckPlayback()
                    if x > self.mouseDownXY[0]:
                        self.MoveTimelineRange(1, val, not fullRange)
                    elif x < self.mouseDownXY[0]:
                        self.MoveTimelineRange(0, val, not fullRange)
                self.mouseDownXY = event.GetPosition()
                event.Skip()
        def OnStatusbarDClick(event):
            if self.timelineRange > 0:
                if event.GetPosition()[0] > self.GetSize()[0]/2.0:
                    if event.ControlDown() or event.ShiftDown():
                        self.MoveTimelineRange(1, self.timelineRange if not event.ShiftDown() else self.timelineRange*4, False, False, True)
                    else: self.MoveTimelineRange(1, self.GetFrameNumber()-self.videoSlider.startOffset, True, True, True)
                else:
                    if event.ControlDown() or event.ShiftDown():
                        self.MoveTimelineRange(0, self.timelineRange if not event.ShiftDown() else self.timelineRange*4, False, False, True)
                    else: self.MoveTimelineRange(0, self.videoSlider.GetVirtualMax() - self.GetFrameNumber(), True, True, True)
            event.Skip()
        def OnStatusbarMiddleUp(event):
            if self.timelineRange > 0:
                self.OnMenuSetTimeLineRange(None, self.timelineRange, self.currentframenum)
                frame = self.GetFrameNumber()
                if frame in self.GetBookmarkFrameList():
                    color = wx.RED
                else:
                    color = wx.BLACK
                self.frameTextCtrl.SetForegroundColour(color)
                self.frameTextCtrl.ChangeValue(str(frame))
                self.frameTextCtrl.Update()
                if self.separatevideowindow:
                    self.frameTextCtrl2.SetForegroundColour(color)
                    self.frameTextCtrl2.ChangeValue(str(frame))
                    self.frameTextCtrl2.Update()
                self.SetVideoStatusText()
            event.Skip()

        statusBar = self.GetStatusBar() if primary else self.videoStatusBar

        if wx.VERSION >= (2,9):   # GPo 2020, bind mouse brows buttons
            panel.Bind(wx.EVT_MOUSE_AUX1_DOWN, OnMouseAux1Down)
            panel.Bind(wx.EVT_MOUSE_AUX2_DOWN, OnMouseAux2Down)
            for child in panel.GetChildren():
                child.Bind(wx.EVT_MOUSE_AUX1_DOWN, OnMouseAux1Down)
                child.Bind(wx.EVT_MOUSE_AUX2_DOWN, OnMouseAux2Down)
            statusBar.Bind(wx.EVT_MOUSE_AUX1_DOWN, OnMouseAux1Down)
            statusBar.Bind(wx.EVT_MOUSE_AUX2_DOWN, OnMouseAux2Down)

        statusBar.Bind(wx.EVT_MOUSEWHEEL, self.OnVideoControlsMouseWheel)
        statusBar.Bind(wx.EVT_RIGHT_UP, self.OnStatusBarContextMenu)
        statusBar.Bind(wx.EVT_MOTION, OnStatusbarMouseMove)
        statusBar.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)
        statusBar.Bind(wx.EVT_LEFT_DOWN, OnStatusbarLeftDown)
        statusBar.Bind(wx.EVT_LEFT_UP, OnStatusbarLeftUp)
        statusBar.Bind(wx.EVT_LEFT_DCLICK, OnStatusbarDClick)
        statusBar.Bind(wx.EVT_MIDDLE_UP, OnStatusbarMiddleUp)

        # Set the sizer and return the panel
        panel.SetSizer(sizer)
        return panel

    def createCropDialog(self, parent):
        dlg = wx.Dialog(parent, wx.ID_ANY, _('Crop editor'),
                        style=wx.DEFAULT_DIALOG_STYLE|wx.STAY_ON_TOP)
        SetFontPPI(dlg)
        dlg.ctrls = {}
        # Create the crop spin controls
        spinSizer = wx.GridBagSizer(hgap=5, vgap=5)
        spinInfo = (
            ('left', (1,0), (1,1)),
            ('top', (0,2), (0,3)),
            ('-right', (1,4), (1,5)),
            ('-bottom', (2,2), (2,3)),
        )
        width = intPPI(50) if wx.version() >= '2.9' else intPPI(55) # fix for wxPython v2.8
        for name, txtPos, spinPos in spinInfo:
            staticText = wx.StaticText(dlg, wx.ID_ANY, name)
            spinCtrl = wx.SpinCtrl(dlg, wx.ID_ANY, '', size=(width,-1))
            spinCtrl.Bind(wx.EVT_TEXT, self.OnCropDialogSpinTextChange)
            spinSizer.Add(staticText, txtPos, flag=wx.ALIGN_CENTER|wx.RIGHT, border=5)
            spinSizer.Add(spinCtrl, spinPos, flag=wx.EXPAND|wx.RIGHT, border=0)
            dlg.ctrls[name] = spinCtrl
            dlg.ctrls[name+'Label'] = staticText
        # Create a static text message
        staticText = wx.StaticText(dlg, wx.ID_ANY,
            _(
                'You can drag the crop regions with the left mouse button when '
                'this dialog is visible, cropping the edge closest to the '
                'initial mouse click.'
            )
        )
        staticText.Wrap(spinSizer.GetMinSize()[0])
        # Create the autocrop controls
        buttonAutocrop = wx.Button(dlg, wx.ID_ANY, _('Auto-crop'))
        buttonAutocrop.SetMinSize(wx.Size(
            buttonAutocrop.GetTextExtent(_('Cancel') + ' (10/10)    ')[0], -1))
        buttonAutocrop.running = False
        dlg.Bind(wx.EVT_BUTTON, self.OnCropAutocrop, buttonAutocrop)
        choiceBoxMod = wx.Choice(
            dlg, wx.ID_ANY, choices=('mod 1','mod 2','mod 4')
            )
        choiceBoxMod.SetSelection(0)
        def OnCoiceBoxMod(event):
            parent.currentScript.autocrop_values = None
            event.Skip()
        choiceBoxMod.Bind(wx.EVT_CHOICE, OnCoiceBoxMod)
        dlg.ctrls['choiceMod'] = choiceBoxMod
        spinAutocrop = wx.SpinCtrl(dlg, wx.ID_ANY, size=(intPPI(100),-1),
            value=u'{0} ({1})'.format(_('Samples'), self.options['autocrop_samples']),
            min=1, initial=self.options['autocrop_samples'],
            style=wx.TE_PROCESS_ENTER|wx.SP_ARROW_KEYS|wx.ALIGN_RIGHT)
        dlg.Bind(wx.EVT_SPINCTRL, self.OnCropAutocropSamples, spinAutocrop)
        autocropSizer = wx.BoxSizer(wx.HORIZONTAL)
        autocropSizer.Add(buttonAutocrop, 0, wx.ALIGN_CENTER|wx.ALL, intPPI(5))
        autocropSizer.Add(choiceBoxMod, 0, wx.ALIGN_CENTER|wx.ALL, intPPI(5))
        autocropSizer.Add(spinAutocrop, 0, wx.ALIGN_CENTER|wx.ALL, intPPI(5))
        # Create the choice box for insertion options
        choiceBox = wx.Choice(
            dlg, wx.ID_ANY,
            choices=(
                _('At script end'),
                _('At script cursor'),
                _('Copy to clipboard')
            )
        )
        choiceBox.SetSelection(self.options['cropchoice'])
        choiceLabel = wx.StaticText(dlg, wx.ID_ANY, _('Insert Crop() command:'))
        choiceSizer = wx.BoxSizer(wx.HORIZONTAL)
        choiceSizer.Add(choiceLabel, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, intPPI(5))
        choiceSizer.Add(choiceBox, 1, wx.EXPAND|wx.LEFT, intPPI(5))
        dlg.ctrls['choiceInsert'] = choiceBox
        # Create the dialog buttons
        buttonApply = wx.Button(dlg, wx.ID_OK, _('Apply'))
        dlg.Bind(wx.EVT_BUTTON, self.OnCropDialogApply, buttonApply)
        buttonCancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        dlg.Bind(wx.EVT_BUTTON, self.OnCropDialogCancel, buttonCancel)
        buttonSizer = wx.BoxSizer(wx.HORIZONTAL)
        buttonSizer.Add(buttonApply, 0, wx.ALL, intPPI(5))
        buttonSizer.Add(buttonCancel, 0, wx.ALL, intPPI(5))
        # Size the elements
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(spinSizer, 0, wx.ALL, intPPI(10))
        sizer.Add(autocropSizer, 0, wx.ALIGN_CENTER)
        sizer.Add(choiceSizer, 0, wx.TOP|wx.BOTTOM, intPPI(10))
        sizer.Add(wx.StaticLine(dlg), 0, wx.EXPAND)
        sizer.Add(staticText, 0, wx.ALIGN_CENTER|wx.EXPAND|wx.ALL, intPPI(5))
        sizer.Add(buttonSizer, 0, wx.ALIGN_CENTER|wx.ALL, intPPI(10))
        dlg.SetSizer(sizer)
        dlg.Fit()
        # Events
        dlg.Bind(wx.EVT_CLOSE, self.OnCropDialogCancel)
        buttonApply.SetDefault()
        return dlg

    def createTrimDialog(self, parent):
        dlg = wx.Dialog(parent, wx.ID_ANY, _('Trim editor'),
                        style=wx.DEFAULT_DIALOG_STYLE|wx.STAY_ON_TOP)
        dlg.ctrls = {}
        SetFontPPI(dlg)
        dlg.oldSelections = {}
        dlg.oldhighligthBookmarks = None
        # Create the radio box for Crop() options
        radioBoxTrim = wx.RadioBox(
            dlg, wx.ID_ANY, _('Selection options'),
            choices=(
                _('Keep selected regions'),
                _('Keep unselected regions')
            ),
            majorDimension=2,
            style=wx.RA_SPECIFY_ROWS,
        )
        def OnRadioBoxTrim(event):
            if event.GetSelection() == 0:
                self.invertSelection = False
            else:
                self.invertSelection = True
            self.ShowVideoFrame()
            event.Skip()
        radioBoxTrim.Bind(wx.EVT_RADIOBOX, OnRadioBoxTrim)
        radioBoxTrim.SetSelection(self.options['trimreversechoice'])
        dlg.ctrls['radioTrim'] = radioBoxTrim
        # Create the checkbox for marking frames
        checkBox = wx.CheckBox(dlg, wx.ID_ANY, _('Mark video frames inside/outside selection'))
        def OnCheckBox(event):
            self.markFrameInOut = event.IsChecked()
            self.ShowVideoFrame()
            event.Skip()
        checkBox.Bind(wx.EVT_CHECKBOX, OnCheckBox)
        checkBox.SetValue(self.options['trimmarkframes'])
        # Create a checkbox and a spinctrl for using Dissolve()
        checkBox2 = wx.CheckBox(dlg, wx.ID_ANY, _('Use Dissolve() with overlap frames:'))
        def OnCheckBox2(event):
            if event.IsChecked():
                spinCtrl.Enable(True)
                if checkBox3.IsChecked():
                    choiceLabel.SetLabel(clipDissolveTxt)
                else:
                    choiceLabel.SetLabel(dissolveTxt)
            else:
                spinCtrl.Enable(False)
                if checkBox3.IsChecked():
                   choiceLabel.SetLabel(clipTxt)
                else:
                    choiceLabel.SetLabel(trimTxt)
        checkBox2.Bind(wx.EVT_CHECKBOX, OnCheckBox2)
        # GPo create checkbox for single clips c0..cn
        checkBox3 = wx.CheckBox(dlg, wx.ID_ANY, _('Single clips (c0..cn) with prefix:'))
        clipPrefix = wx.TextCtrl(dlg, wx.ID_ANY, value='c', size=(intPPI(50),-1))
        clipPrefix.Enable(False)
        def OnCheckBox3(event):
            if event.IsChecked():
                clipPrefix.Enable(True)
                if checkBox2.IsChecked():
                    choiceLabel.SetLabel(clipDissolveTxt)
                else:
                    choiceLabel.SetLabel(clipTxt)
            else:
                clipPrefix.Enable(False)
                if checkBox2.IsChecked():
                    choiceLabel.SetLabel(dissolveTxt)
                else:
                    choiceLabel.SetLabel(trimTxt)
        checkBox3.Bind(wx.EVT_CHECKBOX, OnCheckBox3)
        ###
        dlg.ctrls['useDissolve'] = checkBox2
        dlg.ctrls['singleClips'] = checkBox3
        dlg.ctrls['clipPrefix']  = clipPrefix
        spinCtrl = wx.SpinCtrl(dlg, wx.ID_ANY, size=(intPPI(50), -1), max=999)
        spinCtrl.SetValue(25)
        spinCtrl.Enable(False)
        if wx.VERSION < (2, 8):
            spinCtrl.Bind(wx.EVT_TEXT, self.OnTrimDialogSpinTextChange)
        dlg.ctrls['dissolveOverlap'] = spinCtrl
        dissolveSizer = wx.BoxSizer(wx.HORIZONTAL)
        dissolveSizer.Add(checkBox2, 0, wx.TOP, intPPI(3))
        dissolveSizer.Add(spinCtrl)
        clipSizer = wx.BoxSizer(wx.HORIZONTAL)  # GPo
        clipSizer.Add(checkBox3, 0, wx.TOP, intPPI(3))
        clipSizer.Add(clipPrefix)
        # Create the choice box for insertion options
        choiceBoxInsert = wx.Choice(
            dlg, wx.ID_ANY,
            choices=(
                _('At script end'),
                _('At script cursor'),
                _('Copy to clipboard')
            )
        )
        choiceBoxInsert.SetSelection(self.options['triminsertchoice'])
        trimTxt = _('Insert Trim() commands: ')
        clipTxt = _('Insert clips commands: ')
        dissolveTxt = _('Insert Dissolve(trim,) commands: ')
        clipDissolveTxt = _('Insert Dissolve(clips,) commands: ')
        labelSize = dlg.GetTextExtent(clipDissolveTxt)
        choiceLabel = wx.StaticText(dlg, wx.ID_ANY, _('Insert Trim() commands: '),
                                    size=labelSize, style=wx.ALIGN_RIGHT|wx.ST_NO_AUTORESIZE)
        choiceSizer = wx.BoxSizer(wx.HORIZONTAL)
        choiceSizer.Add(choiceLabel, 0, wx.ALIGN_CENTER_VERTICAL)
        choiceSizer.Add(choiceBoxInsert, 0, wx.RIGHT, intPPI(5))
        dlg.ctrls['choiceInsert'] = choiceBoxInsert
        # Create a static text message
        staticText = wx.StaticText(dlg, wx.ID_ANY,
            _(
                'Use the buttons which appear on the video slider '
                'handle to create the frame selections to trim.'
            )
        )
        staticText.Wrap(choiceSizer.GetMinSize()[0])
        # videoSlider hide the numbers if dialog shown
        dlg.oldSliderShowNumbers = self.videoSlider.showNumbers
        checkBox4 = wx.CheckBox(dlg, wx.ID_ANY, _('Hide timeline numbers'))
        def OnCheckBox4(event):
            self.options['timelinehidenumbers'] = event.IsChecked()
            for slider in self.GetVideoSliderList():
                slider.showNumbers = not event.IsChecked()
                slider.SetValue(slider.GetValue())
            event.Skip()
        checkBox4.Bind(wx.EVT_CHECKBOX, OnCheckBox4)
        checkBox4.SetValue(self.options['timelinehidenumbers'])
        # Create the dialog buttons
        buttonApply = wx.Button(dlg, wx.ID_OK, _('Apply'))
        dlg.Bind(wx.EVT_BUTTON, self.OnTrimDialogApply, buttonApply)
        buttonCancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        dlg.Bind(wx.EVT_BUTTON, self.OnTrimDialogCancel, buttonCancel)
        buttonClear = wx.Button(dlg, wx.ID_CLEAR, _('Clear'))
        dlg.Bind(wx.EVT_BUTTON, self.OnTrimDialogClear, buttonClear)
        buttonSizer = wx.BoxSizer(wx.HORIZONTAL)
        buttonSizer.Add(buttonClear, 0, wx.ALL, intPPI(5))
        buttonSizer.Add(buttonCancel, 0, wx.ALL, intPPI(5))
        buttonSizer.Add(buttonApply, 0, wx.ALL, intPPI(5))
        # Size the elements
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(radioBoxTrim, 0, wx.EXPAND|wx.ALIGN_CENTER|wx.ALL, intPPI(5))
        sizer.Add(checkBox, 0, wx.ALL, intPPI(10))
        sizer.Add(dissolveSizer, 0, wx.LEFT|wx.RIGHT|wx.BOTTOM, intPPI(10))
        sizer.Add(clipSizer, 0, wx.LEFT|wx.RIGHT|wx.BOTTOM, intPPI(10))
        sizer.Add(choiceSizer, 0, wx.ALL, intPPI(5))
        sizer.Add(wx.StaticLine(dlg), 0, wx.EXPAND|wx.TOP, intPPI(5))
        sizer.Add(checkBox4, 0, wx.ALL, intPPI(10))
        sizer.Add(staticText, 0, wx.ALIGN_CENTER|wx.EXPAND|wx.ALL, intPPI(5))
        sizer.Add(buttonSizer, 0, wx.ALIGN_CENTER|wx.ALL, intPPI(10))
        dlg.SetSizer(sizer)
        dlg.Fit()
        # Events
        dlg.Bind(wx.EVT_CLOSE, self.OnTrimDialogCancel)
        buttonApply.SetDefault()
        return dlg

    # Event functions
    def OnClose(self, event):
        self.ExitProgram()

    # GPo 2020, restart the app
    def RestartApp(self):
        self.ExitProgram(restart=True)

    # GPo 2020, return -1 to avoid error on mouse cature lost (videoWindow, videoSlider, etc)
    # Is really stupid, that should suppress wx itself if there is no return by the program.
    def OnMouseCaptureLost(self, event):
        return -1

    def OnMenuBar(self, event): # GPo 2020, changed
        x_menu = event.GetMenu()
        if x_menu is None:
            event.Skip()
            return
        x_id = event.GetMenuId()

        if x_id == 0: # then Menubar or menu top level
            self.currentScript.refreshAVI = True
            if x_menu is self.tab_group_menu:
                group = self.currentScript.group
                if group == None:
                    group = _('None')
                id = x_menu.FindItem(group)
                x_menu.Check(id, True)
                id = x_menu.FindItem(_('Apply offsets'))
                x_menu.Check(id, self.options['applygroupoffsets'])
                id = x_menu.FindItem(_('Offset also bookmarks'))
                x_menu.Check(id, self.options['offsetbookmarks'])
                id = x_menu.FindItem(_('Freeze Split View frame'))
                x_menu.Check(id, self.splitView_freeze)
            else:
                title = x_menu.GetTitle()
                if title == _('&Video'):
                    menu_id = x_menu.FindItem(_('Save view pos on tab change'))
                    if menu_id != wx.NOT_FOUND:
                        # then the video menu and update
                        menu = x_menu.FindItemById(menu_id)
                        menu.Check(self.saveViewPos==1)
                        menu_id = x_menu.FindItem(_('Save pos && zoom on tab change'))
                        if menu_id != wx.NOT_FOUND:
                            menu = x_menu.FindItemById(menu_id)
                            menu.Check(self.saveViewPos==2)
                        menu_id = x_menu.FindItem(_('Split View on/off'))
                        if menu_id != wx.NOT_FOUND:
                            menu = x_menu.FindItemById(menu_id)
                            menu.Check(self.splitView)
                        menu_id = x_menu.FindItem(_('Split View alternate'))
                        if menu_id != wx.NOT_FOUND:
                            menu = x_menu.FindItemById(menu_id)
                            menu.Check(self.splitViewEx)

                    d = {} # do not use self.previewFilterDict or SplitClip cannot found changes
                    self.UpdatePreviewFilterMenu(self.ParseScriptPreviewFilters(d))
                elif title == _('&Optionen'):
                    menu_id = x_menu.FindItem(_('Multiline tab style'))
                    if menu_id != wx.NOT_FOUND:
                        menu = x_menu.FindItemById(menu_id)
                        menu.Check(self.options['multilinetab'])
        event.Skip()

    def OnMenuFileNew(self, event):
        self.NewTab()

    def OnMenuFileOpen(self, event):
        self.OpenFile()

    def OnMenuFileUndoCloseTab(self, event):
        self.UndoCloseTab()

    def OnMenuFileClose(self, event):
        if self.previewWindowVisible:
            index = self.scriptNotebook.GetSelection()
            script = None
            if index + 1 < self.scriptNotebook.GetPageCount():  # hide the prview if next AVI is None
                script,idx = self.getScriptAtIndex(index+1)
            elif index > 0:                                     # the last one
                script,idx = self.getScriptAtIndex(index-1)
            if not script or script.AVI is None:
                self.HidePreviewWindow()
        self.CloseTab(prompt=True)

    def OnMenuFilesOthersClose(self, event):
        idx = self.scriptNotebook.GetSelection()
        count = self.scriptNotebook.GetPageCount()-1
        for index in xrange(count,-1,-1):
            if index != idx:
                self.CloseTab(index, prompt=True)
    """
    def OnMenuFilesCloseLeft(self, event):
        idx = self.scriptNotebook.GetSelection()
        count = self.scriptNotebook.GetPageCount()-1
        for index in xrange(idx-1,-1,-1):
            self.CloseTab(index, prompt=True)

    def OnMenuFilesCloseRight(self, event):
        idx = self.scriptNotebook.GetSelection()
        count = self.scriptNotebook.GetPageCount()-1
        for index in xrange(count-idx,idx+1,-1):
            self.CloseTab(index, prompt=True)
    """
    def OnMenuFileCloseAllTabs(self, event):
        self.CloseAllTabs()

    def OnMenuFileSaveScript(self, event):
        index = self.scriptNotebook.GetSelection()
        script = self.scriptNotebook.GetPage(index)
        self.SaveScript(script.filename, index)

    def OnMenuFileSaveScriptAs(self, event):
        self.SaveScript()

    def OnMenuFileReloadScript(self, event=None, script=None):
        reloaded = 0
        bell = script is not None
        if script is None:
            script = self.currentScript
        if os.path.isfile(script.filename):
            txt, script.encoding, script.eol = self.GetMarkedScriptFromFile(script.filename)
            if txt != script.GetText():
                script.ParseFunctions(txt)
                pos = script.GetCurrentPos()
                script.SetText(txt)
                script.EmptyUndoBuffer()
                script.SetSavePoint()
                script.GotoPos(pos)
                self.DeleteAllSelections()
                refresh = True
                reloaded += 1
                script.refreshAVI = True
            else: # GPo 2020
                refresh = script.AVI is not None and self.options['usefastclip'] # if usefast then refresh the clip
                script.SetModified(False)
                script.old_modified = False
                self.UpdateScriptTabname(script=script)

            # GPo 2020, on reload reset all
            script.disableFastClipOnce = True
            script.bookmarks = None
            self.titleDict.clear()
            if self.options['bookmarksfromscript']:
                self.OnMenuBookmarksFromScript(difWarn=False)
            if refresh and self.previewWindowVisible:
                self.ShowVideoFrame(forceRefresh=True, forceLayout=True, forceCursor=True, disableFastClip=True, focus=self.options['focusonrefresh'])
        elif bell:
            wx.Bell()
        return reloaded

    def OnMenuFileReloadAllScripts(self, event):
        msg = False
        reloaded = 0
        pagecount = self.scriptNotebook.GetPageCount()
        try:
            for i in range(pagecount):
                script = self.scriptNotebook.GetPage(i)
                if script.filename and script.GetModify():
                    if not msg and pagecount > 1:
                        msg = True
                        dlg = wx.MessageDialog(self, 'Reload all changed scripts?', 'Reload all', wx.YES_NO)
                        id = dlg.ShowModal()
                        dlg.Destroy()
                        if id != wx.ID_YES:
                            return
                        wx.BeginBusyCursor()
                    if self.previewWindowVisible:
                        self.HidePreviewWindow()
                    reloaded += self.OnMenuFileReloadScript(script=script)
            self.StatusbarTimer_Start(txt= 'Scripts reloaded: %i' % reloaded)
        finally:
            if wx.IsBusy():
                wx.EndBusyCursor()

    def OnMenuFileOpenScriptDirectory(self, event):
        dirname, basename = os.path.split(self.currentScript.filename)
        if basename:
            if os.path.isdir(dirname):
                if os.path.isfile(self.currentScript.filename) and os.name == 'nt':
                    subprocess.Popen(r'explorer /select, ' + self.currentScript.filename)
                else: startfile(dirname)
            else:
                wx.MessageBox(u'\n\n'.join((_("The script's directory doesn't exist anymore!"),
                              dirname)), _('Error'), style=wx.OK|wx.ICON_ERROR)

    # GPo, 2018
    def OnMenuBookmarksToScript(self, event):
        bmlist = self.MacroGetBookmarkFrameList(title=True)
        if not bmlist:
            wx.Bell()
            return
        Book_Ident = '#Bookmarks:'
        sBookmarks = '#Bookmarks: '
        bmlist.sort()
        script = self.currentScript
        for frame, title in bmlist:
            sBookmarks += u'{0} {1},'.format(frame, title)
        lines = script.GetText().split('\n')
        for x, line in enumerate(lines):
            if line.strip().startswith(Book_Ident):
                if line != sBookmarks:
                    posA = script.PositionFromLine(x)
                    script.SetTargetStart(posA)
                    script.SetTargetEnd(script.GetLineEndPosition(x))
                    script.ReplaceTarget(sBookmarks)
                    script.Colourise(posA, posA + len(sBookmarks)+2)
                return
        b = ''
        if len(lines) > 1:
            if lines[1].strip() != '':
                b = '\n'
            if lines[0].strip() != '':
                b = '\n\n'
        script.InsertText(0, sBookmarks + b)
        script.Colourise(0, len(sBookmarks + b)+2)

    def BookmarkDictFromScript(self, script):
        Book_Ident = '#Bookmarks:'
        lines = script.GetText().split('\n')
        bookmarkDict = {}
        sBookmarks = ''
        for line in lines:
            if line.strip().startswith(Book_Ident):
                sBookmarks = line.strip().strip(Book_Ident)
                break
        if not sBookmarks:
            return bookmarkDict
        try:
            for index in sBookmarks.split(','):
                s = index.strip()
                if s != '':
                    nb = {}
                    title = ''
                    nb = s.split(' ')
                    if (len(nb) > 0) and (nb[0].isdigit()):
                        if len(nb) > 1:
                            title = s[len(nb[0])+1:].strip()
                        bookmarkDict[int(nb[0])] = title
        except AttributeError:
            wx.Bell()
            bookmarkDict = {}
        return bookmarkDict

    # GPo, 2018
    def OnMenuBookmarksFromScript(self, event=None, getOnlyCount=False, script=None, difWarn=None, getOnlyDict=False):

        def compareBookmarks(script, bookmarkDict, difWarn):
            if difWarn is None:
                difWarn = self.options['warnscriptbookmarksdif']
            if not difWarn or not script.bookmarks:
                return True

            re = True
            if len(script.bookmarks) >= len(bookmarkDict):
                for i, item in enumerate(script.bookmarks.items()):
                    if not item[0] in bookmarkDict:
                        re = False
                        break
                    elif item[1] != bookmarkDict[item[0]]: # check the title
                        re = False
                        break
            else:
                for i, item in enumerate(bookmarkDict.items()):
                    if not item[0] in script.bookmarks:
                        re = False
                        break
                    elif item[1] != script.bookmarks[item[0]]: # check the title
                        re = False
                        break
            if not re:
                dlg = wx.MessageDialog(self,
                    'Bookmarks different. Set tab last bookmarks?\nTab: %i - Script: %i'
                    % (len(script.bookmarks), len(bookmarkDict)), _('Bookmarks'), wx.YES_NO)
                ID = dlg.ShowModal()
                dlg.Destroy()
                if ID == wx.ID_YES:
                    self.SetTabBookmarks(script.bookmarks)
                    return False
            return True


        if script is None:
            script = self.currentScript

        """
        Book_Ident = '#Bookmarks:'
        lines = script.GetText().split('\n')
        sBookmarks = ''
        for line in lines:
            if line.strip().startswith(Book_Ident):
                sBookmarks = line.strip().strip(Book_Ident)
                break
        if not sBookmarks:
            return 0
        bookmarkDict = {}
        try:
            for index in sBookmarks.split(','):
                s = index.strip()
                if s != '':
                    nb = {}
                    title = ''
                    nb = s.split(' ')
                    if (len(nb) > 0) and (nb[0].isdigit()):
                        if len(nb) > 1:
                            title = s[len(nb[0])+1:].strip()
                        bookmarkDict[int(nb[0])] = title
        except AttributeError:
            wx.Bell()
            return 0
        """
        # GPo, new
        bookmarkDict = self.BookmarkDictFromScript(script)
        if not bookmarkDict:
            return 0

        if bookmarkDict and not getOnlyCount:
            self.SetTabBookmarks(bookmarkDict)
            if event is not None: # no difWarn on menu itself (event)
                difWarn = False
            if compareBookmarks(script, bookmarkDict, difWarn):
                script.bookmarks = None
                script.bookmarks = self.GetBookmarkDict()# dict(bookmarkDict)
            if event is not None:  # On Menu click start statusbar timer
                self.StatusbarTimer_Start(txt='%d Bookmarks imported' % len(bookmarkDict))

        return len(bookmarkDict)

    def OnSelectionsToScript(self, event=None):
        selections = self.videoSlider.selections
        if not selections:
            wx.Bell()
            return
        Sel_Ident = '#Selections:'
        sSelections = '#Selections: '
        Book_Ident = '#Bookmarks:'
        script = self.currentScript
        bmLine = -1
        try:
            for start, end in selections:
                sSelections += u'{0}-{1},'.format(start, end)
            lines = script.GetText().split('\n')
            for x, line in enumerate(lines):
                if line.strip().startswith(Sel_Ident):
                    if line != sSelections:
                        script.SetTargetStart(script.PositionFromLine(x))
                        script.SetTargetEnd(script.GetLineEndPosition(x))
                        script.ReplaceTarget(sSelections)
                    return
                elif (bmLine < 0) and line.strip().startswith(Book_Ident):
                    bmLine = x + 1

            if bmLine < 0:
                for x, line in enumerate(lines):
                    if line.strip().startswith(Book_Ident):
                        bmLine = x + 1
                        break
        except AttributeError:
            wx.Bell()
            return

        if bmLine > -1:
            posA = script.PositionFromLine(bmLine)
            script.InsertText(posA, sSelections + '\n')
            script.Colourise(posA, posA + len(sSelections)+2)
        else:
            b = ''
            if len(lines) > 1:
                if lines[1].strip() != '':
                    b = '\n'
                if lines[0].strip() != '':
                    b = '\n\n'
            script.InsertText(0, sSelections + b)
            script.Colourise(0, len(sSelections+b)+2)

    def OnSelectionsFromScript(self, event=None, onlyReturnDict=False):
        Sel_Ident = '#Selections:'
        script = self.currentScript
        lines = script.GetText().split('\n')
        sSelections = ''
        for line in lines:
            if line.strip().startswith(Sel_Ident):
                sSelections = line.strip().strip(Sel_Ident)
                break
        if not sSelections:
            return 0
        selDict = {}
        try:
            for index in sSelections.split(','):
                s = index.strip()
                if s != '':
                    nb = {}
                    nb = s.split('-')
                    if len(nb) > 1:
                        start = nb[0].strip()
                        end = nb[1].strip()
                        if (start.isdigit() and end.isdigit()) and (int(start) < int(end)):
                            selDict[int(start)] = 1
                            selDict[int(end)] = 2
            if onlyReturnDict:
                return selDict
            if selDict:
                self.currentScript.selections = None
                self.currentScript.selections = selDict
                self.SetSelectionsDict(selDict)
        except AttributeError:
            wx.Bell()
            return 0

    def OnMenuSetTimeLineRange(self, event=None, frange=0, r_center=None, r_start=None, r_end=None, r_maxrange=None):
        if event:
            label = ''
            menus = [self.GetMenuBar().GetMenu(2), self.videoWindow.contextMenu]
            for menu in menus:
                id = menu.FindItem(_('Timeline range'))
                item = menu.FindItemById(id).GetSubMenu()
                if item:
                    item = item.FindItemById(event.GetId())
                if item:
                    label = item.GetLabel()
                if label:
                    break
            if not label:
                return
            if label in ('100 %', ''):
                fValue = 0
            else:
                fValue = int(label[:-len(' frame')])
        else:
            fValue = int(frange)

        if self.playing_video:
            self.PlayPauseVideo()
            self.playing_video = ''

        script = self.currentScript
        if r_center is not None:
            frame = r_center
        else:
            frame = self.GetFrameNumber()

        if r_maxrange is not None:
            valueMax = r_maxrange
        elif script.AVI is not None:
            valueMax = script.AVI.Framecount-1
        else:
            valueMax = script.lastLength if script.lastLength is not None else self.videoSlider.GetMax()

        if r_start is not None and r_end is not None:
            r_start = max(0, r_start)
            r_end = min(valueMax, r_end)
            if r_end - r_start < 30:
                return
            for slider in self.GetVideoSliderList():
                slider.SetOffset(r_start, valueMax- (r_end-r_start))
                slider.SetRange(0, r_end-r_start, refresh=True)
                if frame >= r_start and frame <= r_end:
                    slider.SetValue(frame)
                else:
                    slider.SetValue(r_start)
                    wx.CallAfter(self.ShowVideoFrame, r_start)
            #fValue = int((r_end-r_start) / 2)
            fValue = r_end-r_start
        else:
            if fValue > valueMax-30:
                fValue = 0

            for slider in self.GetVideoSliderList():
                if fValue == 0:
                    slider.SetOffset(0, 0)
                    slider.SetRange(0, valueMax,  refresh=True)
                elif fValue < valueMax-30:
                    start = max(frame - int(fValue/2.0), 0)
                    end = min(frame + int(fValue/2.0), valueMax)
                    if end - start < fValue:
                        if start == 0:
                            end = min(valueMax, start + fValue)
                        elif end == valueMax:
                            start = max(0, end - fValue)
                    slider.SetOffset(start, valueMax- (end-start))
                    slider.SetRange(0, end-start, refresh=True)
                slider.SetValue(frame)

        self.timelineRange = fValue

        if self.playing_video == '':
            wx.CallAfter(self.PlayPauseVideo)
        return True

    def MoveTimelineRange(self, direction, frames=0, limitRange=True, moveSlider=False, checkPlayback=False):
        if not self.videoSlider.offsetSet:
            return
        if checkPlayback:
            self.CheckPlayback()
        curRange = self.videoSlider.maxValue
        if frames < 1:
            frames = max(int(curRange/self.options['timelinestatusbarmovesense']), 1)

        curVal = self.videoSlider.GetValue()
        # leaves the slider on place if not limitRange
        curOffsetPos = curVal - self.videoSlider.startOffset
        # moves the slider to range center if not limitRange
        #~curOffsetPos = int(curRange/2)

        if direction > 0: # move to timeline end
            solPos = self.videoSlider.startOffset + frames
            newStart = min(solPos, self.videoSlider.GetMax()-curRange)
            if limitRange:
                newStart = min(newStart, curVal)
                framenum = curVal
            else:
                framenum = newStart + curOffsetPos
                if moveSlider and curVal < framenum:
                    framenum = newStart
        else:
            solPos = self.videoSlider.startOffset - frames
            newStart = max(0, solPos)
            if limitRange:
                newStart = max(newStart, curVal-curRange)
                framenum = curVal
            else:
                framenum = newStart + curOffsetPos
                if moveSlider and curVal > framenum:
                    if self.options['timelinemoveslidertostart']:
                        framenum = newStart
                    else:
                        framenum = newStart + curRange

        self.videoSlider.SetOffset(newStart,  self.videoSlider.GetMax() - curRange)
        self.videoSlider.SetValue(framenum) # needed always for refresh
        if self.separatevideowindow:
            self.videoSlider2.SetOffset(newStart,  self.videoSlider.GetMax() - curRange)
            self.videoSlider2.SetValue(framenum)

        if not limitRange:
            if framenum in self.GetBookmarkFrameList():
                color = wx.RED
            else:
                color = wx.BLACK

            self.frameTextCtrl.SetForegroundColour(color)
            self.frameTextCtrl.Replace(0, -1, str(framenum))
            if self.separatevideowindow:
                self.videoSlider2.SetValue(framenum)
                self.frameTextCtrl2.SetForegroundColour(color)
                self.frameTextCtrl2.Replace(0, -1, str(framenum))
            self.SetVideoStatusText()
        if checkPlayback:
            self.CheckPlayback()

    # GPo 2020, find menu item and sub item by name (multible used, so make one function)
    def FindMenuItem(self, menuBarIdx, itemLabel, subLabel=''):
        rmenus = []
        if menuBarIdx == 2:
            menus = [self.GetMenuBar().GetMenu(2), self.videoWindow.contextMenu]
        else:
            menus = [self.GetMenuBar().GetMenu(menuBarIdx)]
        for menu in menus:
            id = menu.FindItem(_(itemLabel))
            if id == wx.NOT_FOUND:
                return rmenus
            if subLabel:
                rmenu = menu.FindItemById(id).GetSubMenu()
                if rmenu:
                    rmenu = rmenu.FindItemById(rmenu.FindItem(_(subLabel)))
            else:
                rmenu = menu.FindItemById(id)
            if rmenu:
                rmenus.append(rmenu)
        return rmenus # return list of found menus (menubar, context menu)

    def OnMenuTabChangeLoadBookmarks(self, event):
        if event:
            self.tabChangeLoadBookmarks = event.IsChecked()
            if self.tabChangeLoadBookmarks:
                self.SetSelectionsDict(self.currentScript.selections)
                if self.options['bookmarksfromscript']:
                    self.OnMenuBookmarksFromScript()
            if self.options['offsetbookmarks']:
                self.options['offsetbookmarks'] = False
                wx.MessageBox(_("'Groups offset bookmarks' has been switched off, otherwise undefined assignments will occur"))

        menus = self.FindMenuItem(2, 'Bookmarks', 'Clear tab bookmarks')
        if menus:
            for menu in menus:
                menu.Enable(self.tabChangeLoadBookmarks)

    def OnMenuFileRenameTab(self, index, pos=None):
        if not self.scriptNotebook.dblClicked\
        and not self.titleEntry\
        and not self.scriptNotebook.HasCapture()\
        and not (pos and index != self.scriptNotebook.GetSelection()):
            if pos == None:
                index = self.scriptNotebook.GetSelection()
                h = self.scriptNotebook.GetCharHeight() + 6
                for row in range(self.scriptNotebook.GetRowCount()):
                    y = h * row + h/2
                    for x in range(0, self.scriptNotebook.GetSizeTuple()[0], h):
                        ipage = self.scriptNotebook.HitTest((x, y))[0]
                        if ipage == index:
                            pos = (x, y)
                            break
                    if pos:
                        break
            if pos == None:
                return
            x, y = pos
            ipage = index
            while ipage == index:
                x -= 1
                ipage = self.scriptNotebook.HitTest((x, y))[0]
            left = x + 1
            x, y = pos
            ipage = index
            while ipage == index:
                y -= 1
                ipage = self.scriptNotebook.HitTest((x, y))[0]
            top = y + 1
            x, y = pos
            ipage = index
            while ipage == index:
                x += 1
                ipage = self.scriptNotebook.HitTest((x, y))[0]
            right = x - 1
            x, y = pos
            ipage = index
            while ipage == index:
                y += 1
                ipage = self.scriptNotebook.HitTest((x, y))[0]
            bottom = y - 1
            title = self.scriptNotebook.GetPageText(index)
            self.titleEntry = wx.TextCtrl(self.scriptNotebook, -1, title, pos=(left, top), size=(right-left, bottom-top), style=wx.TE_PROCESS_ENTER|wx.BORDER_SIMPLE)
            self.titleEntry.SetFocus()
            self.titleEntry.SetSelection(-1, -1)

            def OnTabKillFocus(event):
                if self.FindFocus() == self.scriptNotebook:
                    if self.scriptNotebook.GetPageImage(index) == -1:
                        self.currentScript.SetFocus()
                    else:
                        self.videoWindow.SetFocus()
                title = self.titleEntry.GetLineText(0)
                if not self.RenameScript(title):
                    wx.Bell()
                self.IdleCall.append((self.titleEntry.Destroy, tuple(), {}))

            def CheckTabPosition():
                try:
                    if self.titleEntry:
                        if self.scriptNotebook.HitTest((left, top))[0] != index\
                        or self.scriptNotebook.HitTest((right, bottom))[0] != index:
                            self.scriptNotebook.SetFocus()
                        else:
                            wx.CallLater(300, CheckTabPosition)
                except wx.PyDeadObjectError:
                    pass

            self.titleEntry.Bind(wx.EVT_KILL_FOCUS, OnTabKillFocus)
            self.titleEntry.Bind(wx.EVT_TEXT_ENTER, OnTabKillFocus)
            wx.CallLater(300, CheckTabPosition)
        if self.scriptNotebook.dblClicked:
            wx.CallLater(300, setattr, self.scriptNotebook, 'dblClicked' ,False)

    def OnMenuFileExportHTML(self, event):
        self.ExportHTML()

    def OnMenuFilePageSetup(self, event):
        setup_dlg = wx.PageSetupDialog(self, self.print_data)
        if setup_dlg.ShowModal() == wx.ID_OK:
            self.print_data = wx.PageSetupDialogData(setup_dlg.GetPageSetupData())
        setup_dlg.Destroy()

    def OnMenuFilePrintHeader(self, event):
        self.print_header = not self.print_header

    def OnMenuFileWrapText(self, event):
        self.print_wrap = not self.print_wrap

    def OnMenuFileUseZoom(self, event):
        self.print_zoom = not self.print_zoom

    def OnMenuFilePrintPreview(self, event):
        filename = self.GetProposedPath(only='base')
        printout = STCPrintout(self.currentScript, page_setup_data=self.print_data,
                               header=self.print_header, title=filename, job_title=filename,
                               zoom=self.print_zoom, wrap=self.print_wrap)
        printout2 = STCPrintout(self.currentScript, page_setup_data=self.print_data,
                                header=self.print_header, title=filename, job_title=filename,
                                zoom=self.print_zoom, wrap=self.print_wrap)
        preview = wx.PrintPreview(printout, printout2, self.print_data.GetPrintData())
        preview.SetZoom(100)
        if preview.IsOk():
            pre_frame = wx.PreviewFrame(preview, self, _("Print Preview"))
            dsize = wx.GetDisplaySize()
            pre_frame.SetInitialSize((self.GetSize()[0],
                                      dsize.GetHeight() - 100))
            pre_frame.Initialize()
            pre_frame.Show()
        else:
            wx.MessageBox(_("Failed to create print preview"),
                          _("Print Error"),
                          style=wx.ICON_ERROR|wx.OK)

    def OnMenuFilePrint(self, event):
        pdd = wx.PrintDialogData(self.print_data.GetPrintData())
        printer = wx.Printer(pdd)
        filename = self.GetProposedPath(only='base')
        printout = STCPrintout(self.currentScript, page_setup_data=self.print_data,
                               header=self.print_header, title=filename, job_title=filename,
                               zoom=self.print_zoom, wrap=self.print_wrap)
        result = printer.Print(self.currentScript, printout)
        if result:
            self.print_data.SetPrintData(printer.GetPrintDialogData().GetPrintData())
        elif printer.GetLastError() == wx.PRINTER_ERROR:
            wx.MessageBox(_("There was an error when printing.\n"
                            "Check that your printer is properly connected."),
                          _("Printer Error"),
                          style=wx.ICON_ERROR|wx.OK)
        printout.Destroy()

    def OnMenuFileLoadSession(self, event=None, filename=None, saveSession=True):
        if not self.LoadSession(filename=filename):
            wx.MessageBox(_('Damaged session file'), _('Error'), wx.OK|wx.ICON_ERROR)
            return
        if saveSession:
            self.SaveSession(self.lastSessionFilename, saverecentdir=False, previewvisible=False)

    def OnMenuFileReloadLastSession(self, event):
        backup = os.path.splitext(self.lastSessionFilename)[0]
        if os.path.isfile(backup + 'backup.ses'):
            if not self.BackupSessionEx():
                return
            self.CloseAllTabs(discard=True, showSaveDlg=False)
            wx.GetApp().SafeYieldFor(self.scriptNotebook, wx.wxEVT_ANY)
            self.OnMenuFileLoadSession(filename=backup + 'backup.ses', saveSession=False)
        else: wx.MessageBox(backup + 'backup.ses', 'File not found')

    def OnMenuFileSaveSession(self, event):
        self.SaveSession()

    def OnMenuFileBackupSession(self, event):
        self.SaveSession(self.lastSessionFilename, saverecentdir=False, previewvisible=False)

    def OnMenuFileNextTab(self, event):
        self.SelectTab(inc=1)

    def OnMenuFilePrevTab(self, event):
        self.SelectTab(inc=-1)

    def OnMenuFileRecentFile(self, event):
        # First find the position of the clicked menu item
        id = event.GetId()
        menuItem = self.GetMenuBar().FindItemById(id)
        menu = menuItem.GetMenu()
        nMenuItems = menu.GetMenuItemCount()
        pos = None
        for i in xrange(nMenuItems):
            if menu.FindItemByPosition(i).GetId() == id:
                pos = i
                break
        if pos is None:
            return
        # Find the menu position of the first filename
        firstpos = None
        i = nMenuItems - 1 - 2
        while i >= 0:
            menuItem = menu.FindItemByPosition(i)
            if menuItem.IsSeparator():
                firstpos = i + 1
                break
            i -= 1
        if firstpos is None:
            return
        # Compute the relative position
        relpos = pos - firstpos
        # Open the corresponding filename
        try:
            filename = self.options['recentfiles'][relpos]
            if os.path.isfile(filename):
                self.OpenFile(filename)
            else:
                wx.MessageBox(_('File does not exist!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
        except IndexError:
            pass

    def OnMenuFileExit(self, event):
        self.ExitProgram()

    def OnMenuEditUndo(self, event):
        script = self.currentScript
        script.Undo()

    def OnMenuEditRedo(self, event):
        script = self.currentScript
        script.Redo()

    def OnMenuEditCut(self, event):
        script = self.currentScript
        script.Cut()

    def OnMenuEditCopy(self, event):
        script = self.currentScript
        script.Copy()

    def OnMenuEditPaste(self, event):
        script = self.currentScript
        script.Paste()

    def OnMenuEditDelete(self, event):
        script = self.currentScript
        script.ReplaceSelection('')

    def OnMenuEditFind(self, event):
        script = self.currentScript
        if self.replaceDialog.IsShown():
            script.ShowFindReplaceDialog(find=True)
        else:
            script.ShowQuickFindDialog()

    def OnMenuEditFindNext(self, event):
        script = self.currentScript
        script.FindNext()

    def OnMenuEditFindPrevious(self, event):
        script = self.currentScript
        script.FindPrevious()

    def OnMenuEditReplace(self, event):
        script = self.currentScript
        script.ShowFindReplaceDialog()

    def OnMenuEditReplaceNext(self, event):
        script = self.currentScript
        script.ReplaceNext()

    def OnMenuEditSelectAll(self, event):
        script = self.currentScript
        script.SelectAll()

    def OnMenuEditInsertSnippet(self, event):
        self.currentScript.InsertSnippet()

    def OnMenuEditInsertSource(self, event):
        self.InsertSource(check_selection=True)

    def OnMenuEditInsertFilename(self, event):
        filefilter = _('All files') + ' (*.*)|*.*'
        initial_dir = self.GetProposedPath(only='dir')
        dlg = wx.FileDialog(self, _('Select a file'), initial_dir, '', filefilter, wx.OPEN)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            filename = dlg.GetPath()
            self.InsertText(filename, pos=None)
            dirname = os.path.dirname(filename)
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname
        dlg.Destroy()

    def OnMenuEditInsertPlugin(self, event):
        self.InsertPlugin()

    def OnMenuEditInsertFrameNumber(self, event):
        self.InsertFrameNumber()

    def OnMenuEditInsertUserSlider(self, event):
        self.InsertUserSlider()

    def OnMenuEditInsertUserSliderSeparator(self, event):
        script = self.currentScript
        dlg = wx.TextEntryDialog(self, _('Enter separator label'), _('Create a separator label'))
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            label = dlg.GetValue()
            if label != '':
                script.ReplaceSelection('[<separator="%s">]' % label.replace(',', '_'))
            else:
                script.ReplaceSelection('[<separator>]')
        dlg.Destroy()

    def OnMenuEditToggleTagSelection(self, event=None, label=None):
        script = self.currentScript
        scriptChanged = self.ScriptChanged(script)
        startpos, endpos = script.GetSelection()
        while (unichr(script.GetCharAt(startpos)) == ' ') and (startpos < endpos):
            startpos += 1
        # Get the name of the tag
        if label is None:
            # GPo, new
            word = script.GetTextRange(script.WordStartPosition(startpos, 1), script.WordEndPosition(startpos, 1)).strip()
            s = '#>' if self.options['savetoggletags'] else ''
            if len(word) > 1:
                s += word
            ##
            dlg = wx.TextEntryDialog(self, _('Enter tag name:'), _('Tag definition'), s)
            if dlg.ShowModal() == wx.ID_OK:
                label = dlg.GetValue().strip()
            dlg.Destroy()
        # Insert the tags into the text
        if label:
            startline = script.LineFromPosition(startpos)
            endline = script.LineFromPosition(endpos)
            firstpos = script.PositionFromLine(startline)
            lastpos = script.GetLineEndPosition(endline)
            lastfirstpos = script.PositionFromLine(endline)
            extraB = extraC = ''
            extraAA = extraBB = ''
            if label.startswith('#>'): # GPo new
                label = label[2:].lstrip()
                extraC = '#>'
            if startpos == firstpos and (endpos == lastpos or endpos == lastfirstpos):
                extraAA = '\n'
                if endpos == lastpos:
                    extraB = '\n'
                if endpos == lastfirstpos:
                    extraBB = '\n'
            elif startpos == endpos: # GPo, nothing selected also the current line
                startpos = firstpos
                endpos = lastpos
                extraAA = extraB = '\n'
            if not extraAA or not extraB:
                extraC = ''
            script.InsertText(endpos, '%s%s[/%s]%s' % (extraB, extraC, label, extraBB))
            script.InsertText(startpos, '%s[%s]%s' % (extraC, label, extraAA))
            # then we can set the preview text, tags as default enabled
            if not scriptChanged and label.find('=') < 0:
                script.Colourise(startpos, script.GetTextLength())
                script.previewtxt = self.ScriptChanged(script, return_styledtext=True)[1]
            self.UpdateUserSliders()

    """
    def OnMenuEditClearToggleTags(self, event):
        script = self.currentScript
        script.SetText(self.cleanToggleTags(script.GetText()))
        script.Colourise(0, script.GetTextLength()) # GPo 2021
    """
    # GPo 2021, changed
    def OnMenuEditClearToggleTags(self, event=None, removeFilters=True):
        script = self.currentScript
        scriptTxt = script.GetText().rstrip()
        txt = self.cleanToggleTags(scriptTxt, removeFilters)
        txt = self.stripComment_2(txt)
        if txt != scriptTxt:
            pos = script.GetCurrentPos()
            script.Freeze()
            script.SetText(txt)
            script.GotoPos(pos)
            script.Thaw()
            script.Colourise(0, script.GetTextLength())
            script.ToggleTags = []
            self.UpdateUserSliders()

    def OnMenuEditClearToggleTags2(self, event=None):
        self.OnMenuEditClearToggleTags(removeFilters=False)

    def OnMenuInsertSplitClip(self, event):
        script = self.currentScript
        startpos = script.GetSelectionStart()
        startline = script.LineFromPosition(startpos)
        firstpos = script.PositionFromLine(startline)
        script.InsertText(firstpos, '/**avsp_split**/')

    def OnMenuInsertPreviewFilter(self, event):
        script = self.currentScript
        startpos, endpos = script.GetSelection()
        startline = script.LineFromPosition(startpos)
        endline = script.LineFromPosition(endpos)
        firstpos = script.PositionFromLine(startline)
        lastpos = script.GetLineEndPosition(endline)
        script.InsertText(lastpos, '\n**/')
        script.InsertText(firstpos, '/**avsp_filter\n')

    def OnMenuEditIndentSelection(self, event=None):
        self.currentScript.CmdKeyExecute(stc.STC_CMD_TAB)

    def OnMenuEditUnIndentSelection(self, event):
        script = self.currentScript
        lineA = script.LineFromPosition(script.GetSelectionStart())
        lineB = script.LineFromPosition(script.GetSelectionEnd())
        if lineA==lineB:
            script.GotoLine(lineA)
            posA = script.GetCurrentPos()
            script.CmdKeyExecute(stc.STC_CMD_BACKTAB)
            posB = script.GetLineEndPosition(lineA)
            script.SetSelection(posB,posA)
        else:
            script.CmdKeyExecute(stc.STC_CMD_BACKTAB)

    def OnMenuEditBlockComment(self, event):
        script = self.currentScript
        script.BlockComment()

    def OnMenuEditStyleComment(self, event):
        script = self.currentScript
        script.StyleComment()

    def OnMenuEditToggleCurrentFold(self, event):
        script = self.currentScript
        script.ToggleFold(script.GetCurrentLine())

    def OnMenuEditToggleAllFolds(self, event):
        script = self.currentScript
        script.FoldAll()

    # GPo 2018
    def OnMenuEditToggleTextWrap(self, event):
        script = self.currentScript
        if script.GetWrapMode() == stc.STC_WRAP_NONE:
            script.SetWrapMode(stc.STC_WRAP_WORD)
        else:
            script.SetWrapMode(stc.STC_WRAP_NONE)

    def OnMenuEditNumberWheel(self, event):
        self.options['numberwheel'] = event.IsChecked()
        for i in range(self.scriptNotebook.GetPageCount()):
            self.scriptNotebook.GetPage(i).IsDClicked = False
        self.UpdateMenuItem(_("Enable 'Number wheel'"), event.IsChecked(), 'edit')

    def OnMenuEditMoveLineUp(self, event):
        self.currentScript.MoveSelectionByOneLine(up=True)
        self.AutoUpdateVideo(force=True)

    def OnMenuEditMoveLineDown(self, event):
        self.currentScript.MoveSelectionByOneLine(up=False)
        self.AutoUpdateVideo(force=True)

    def OnMenuEditAutocomplete(self, event):
        script = self.currentScript
        if script.AutoCompActive():
            script.CmdKeyExecute(wx.stc.STC_CMD_CANCEL)
            if script.autocomplete_case == 'function':
                    return
        script.ShowAutocomplete()

    def OnMenuEditAutocompleteAll(self, event):
        script = self.currentScript
        if script.AutoCompActive():
            script.CmdKeyExecute(wx.stc.STC_CMD_CANCEL)
            if script.autocomplete_case == 'function':
                    return
        script.ShowAutocomplete(all=True)

    def OnMenuEditAutocompleteParameterFilename(self, event):
        script = self.currentScript
        pos = script.GetCurrentPos() - 1
        if script.IsString(pos):
            if script.AutoCompActive():
                script.CmdKeyExecute(wx.stc.STC_CMD_CANCEL)
                if script.autocomplete_case == 'filename':
                    return
            script.AutocompleteFilename()
        else:
            if script.AutoCompActive():
                script.CmdKeyExecute(wx.stc.STC_CMD_CANCEL)
                if script.autocomplete_case in ('parameter name',
                                                'parameter value'):
                    return
            # prefer name over value
            while pos >= 0:
                chr = unichr(script.GetCharAt(pos))
                if chr == '=':
                    return script.AutocompleteParameterValue()
                elif not (chr.isspace() or chr == '\\'):
                    return script.AutocompleteParameterName()
                pos -= 1

    def OnMenuEditShowCalltip(self, event):
        if self.currentScript.CallTipActive():
            self.calltipstemporal = False   # GPo
            self.currentScript.CmdKeyExecute(wx.stc.STC_CMD_CANCEL)
            wx.Bell()
        else:
            self.calltipstemporal = True    # GPo
            self.currentScript.UpdateCalltip(force=True)

    def OnMenuEditShowFunctionDefinition(self, event):
        script = self.currentScript
        name = script.GetSelectedText() or script.GetFilterNameAtCursor()
        if name in script.avsfilterdict.own_dict:
            args = script.avsfilterdict[name][0]
        else:
            args = None
        self.ShowFunctionDefinitionDialog(functionName=name, functionArgs=args)

    def OnMenuEditFilterHelp(self, event):
        script = self.currentScript
        word = script.GetSelectedText() or script.GetFilterNameAtCursor()
        script.ShowFilterDocumentation(word)

    def OnMenuEditParseFunctions(self, event):
        self.currentScript.ParseFunctions(refresh_highlighting=True)

    def OnMenuEditCopyToNewTab(self, event):
        self.NewTab(copytab=True)

    # copy and insert tab next to current and enable split view
    def OnMenuCopyToNewTabNext(self, event):
        if self.splitView:
            self.OnMenuSplitView(event=None)
        script = self.currentScript
        re = self.NewTab(copytab=True, select=False, insertnext=True)
        if re == False:  # crop dlg or trim dlg shown
            return
        wx.SafeYield(self.videoWindow, True)
        self.OnMenuSplitView(event=None)
        if isinstance(re, int):
            try:
                self.scriptNotebook.SetSelection(re)
            except:
                pass

    def OnMenuCopyUnmarkedScript(self, event):
        txt = self.getCleanText(self.currentScript.GetText()).replace('\n', '\r\n')
        text_data = wx.TextDataObject(txt)
        if wx.TheClipboard.Open():
            wx.TheClipboard.SetData(text_data)
            wx.TheClipboard.Close()

    def OnMenuCopyAvisynthError(self, event):
        if self.currentScript.AVI:
            error_message = self.currentScript.AVI.error_message or self.currentScript.AVI.clip.get_error()
            if error_message and not wx.TheClipboard.IsOpened():
                text_data = wx.TextDataObject(error_message)
                wx.TheClipboard.Open()
                wx.TheClipboard.SetData(text_data)
                wx.TheClipboard.Close()
            elif not error_message:
                wx.MessageBox(_('There is no error that can be copied to the clipboard.'), 'Information')
            elif wx.TheClipboard.IsOpened():
                wx.MessageBox(_('Cannot copy to the clipboard.'), 'Clipboard error')

    def OnMenuCopyStatusBar(self, event):
        if not wx.TheClipboard.IsOpened():
            statusBar = self.GetStatusBar()
            text = ' '.join(statusBar.GetFields())
            text_data = wx.TextDataObject(text)
            wx.TheClipboard.Open()
            wx.TheClipboard.SetData(text_data)
            wx.TheClipboard.Close()

    def OnMenuEditShowScrapWindow(self, event):
        scrap = self.scrapWindow
        if scrap.IsShown():
            scrap.Hide()
        else:
            scrap.Show()

    def OnMenuVideoTogglePropWindow(self, event):
        self.propWindow.Toggle()

    # GPo new, PropWindow show/hide calls this function and enable or disable read frame props
    def SetReadFrameProps(self, enabled):
        self.CheckPlayback()
        self.readFrameProps = enabled
        for i in xrange(self.scriptNotebook.GetPageCount()):
            script = self.scriptNotebook.GetPage(i)
            if script.AVI is not None:
                script.AVI.SetReadFrameProps(self.readFrameProps,
                    callBack=script==self.currentScript)
        if not self.readFrameProps:
            self.propWindow.Clear()
        self.CheckPlayback() # playback disabled read frame props temporally

    def OnMenuVideoBookmark(self, event):
        framenum = self.GetFrameNumber()
        self.AddFrameBookmark(framenum)

    """
    def OnMenuVideoRestoreScriptBookmarks(self, event):
        if len(self.currentScript.bookmarks) < 1:
            wx.MessageBox('No bookmarks to restore', 'Restore bookmarks', wx.OK)
            return
        self.SetBookmarkFrameList(self.currentScript.bookmarks)

    def OnMenuVideoJoinScriptBookmarks(self, event):
        if len(self.currentScript.bookmarks) < 1:
            wx.MessageBox('No bookmarks to join', 'Join bookmarks', wx.OK)
            return
        bookmarks = self.GetBookmarkFrameList(copy=True)
        for item in self.currentScript.bookmarks.items():
            if not item[0] in bookmarks:
                bookmarks[item[0]] = 0
        self.SetBookmarkFrameList(bookmarks)
    """
    def OnMenuVideoGotoFrameNumber(self, event):
        self.CheckPlayback()
        menuItem = self.GetMenuBar().FindItemById(event.GetId())
        framenum = int(menuItem.GetLabel().split()[0])
        self.ShowVideoFrame(framenum)
        self.CheckPlayback()

    def OnMenuVideoBookmarkMoveTitle(self, event):
        if type(event) is int:
            curr = event
        else:
            curr = self.GetFrameNumber()
        bookmarkList = [bookmark for bookmark, title in self.GetBookmarkFrameList().items()]
        diffList = [(abs(curr - i), i) for i in self.titleDict if self.titleDict[i]]
        if not diffList:
            return
        diff, bookmark = min(diffList)
        if bookmark not in bookmarkList:
            self.AddFrameBookmark(bookmark)
            return
        if not diff:
            return
        self.titleDict[curr] = self.titleDict[bookmark]
        del self.titleDict[bookmark]
        if curr not in bookmarkList:
            self.AddFrameBookmark(curr, refreshProgram=False)
        self.DeleteFrameBookmark(bookmark)

    def OnMenuVideoBookmarkRestoreHistory(self, event):
        bookmarkList = [bookmark for bookmark, title in self.GetBookmarkFrameList().items()]
        for bookmark in self.titleDict.keys():
            if bookmark not in bookmarkList and self.titleDict[bookmark]:
                self.OnMenuVideoBookmarkMoveTitle(bookmark)

    def OnMenuVideoBookmarkClearHistory(self, event=None, start=0, end=None):
        bookmarkList = [bookmark for bookmark, title in self.GetBookmarkFrameList().items()]
        for bookmark in self.titleDict.keys():
            if ((bookmark not in bookmarkList or not self.titleDict[bookmark]) and
                bookmark >= start and (end is None or bookmark <= end)):
                del self.titleDict[bookmark]

    def OnMenuVideoBookmarkAutoTitle(self, event):
        bookmarkList = [bookmark for bookmark, title in self.GetBookmarkFrameList().items()]
        bookmarkList.sort()
        for i in range(len(bookmarkList)):
            if bookmarkList[i] not in self.titleDict:
                self.titleDict[bookmarkList[i]] = _('Chapter') + (' %02d' % (i+1))
        self.UpdateBookmarkMenu()
        if self.previewWindowVisible:
            self.videoSlider.Refresh()
            if self.separatevideowindow:
                self.videoSlider2.Refresh()

    def OnMenuVideoBookmarkSetTitle(self, event):
        bookmarkInfo = []
        historyList = []
        titleList = []
        bookmarkList = [bookmark for bookmark, bmtype in self.GetBookmarkFrameList().items()]
        for bookmark in self.titleDict:
            if bookmark in bookmarkList:
                titleList.append(bookmark)
            else:
                historyList.append(bookmark)
        bookmarkList += historyList
        if not bookmarkList:
            return
        for bookmark in bookmarkList:
            if self.currentScript.AVI:
                sec = bookmark / self.currentScript.AVI.Framerate
                min, sec = divmod(sec, 60)
                hr, min = divmod(min, 60)
                timecode = '%02d:%02d:%06.3f' % (hr, min, sec)
            else:
                timecode = '??:??:??.???'
            title = self.titleDict.get(bookmark, '')
            bookmarkInfo.append((bookmark, timecode, title))
        bookmarkInfo.sort()
        dlg = wx.Dialog(self, wx.ID_ANY, _('Set title for bookmarks'), size=(450, 270), style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        attrTitle = wx.ListItemAttr()
        attrTitle.SetTextColour(wx.BLUE)
        attrHistory = wx.ListItemAttr()
        attrHistory.SetTextColour(wx.RED)
        # Define the virtual list control
        class VListCtrl(wxp.ListCtrl):
            def OnGetItemText(self, item, column):
                bookmark, timecode, title = bookmarkInfo[item]
                if column == 0:
                    return title
                elif column == 1:
                    if bookmark in historyList:
                        return '* ' + str(bookmark)
                    return str(bookmark)
                return timecode

            def OnGetItemAttr(self, item):
                bookmark, timecode, title = bookmarkInfo[item]
                if bookmark in titleList:
                    return attrTitle
                elif bookmark in historyList:
                    return attrHistory

        listCtrl = VListCtrl(dlg, wx.ID_ANY, style=wx.LC_REPORT|wx.LC_SINGLE_SEL|wx.LC_VIRTUAL|wx.LC_EDIT_LABELS|wx.LC_HRULES|wx.LC_VRULES)
        listCtrl.InsertColumn(0, _('Title'))
        listCtrl.InsertColumn(1, _('Frame No.'), wx.LIST_FORMAT_RIGHT)
        listCtrl.InsertColumn(2, _('Time **'))
        listCtrl.SetItemCount(len(bookmarkInfo))
        listCtrl.setResizeColumn(1)
        listCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE_USEHEADER)
        listCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)

        def OnListCtrlActivated(event):
            listCtrl.EditLabel(event.GetIndex())

        def OnListCtrlEndLabelEdit(event):
            i = event.GetIndex()
            bookmark, timecode, oldTitle = bookmarkInfo[i]
            newTitle = event.GetLabel().strip()
            if bookmark not in historyList:
                if oldTitle and not newTitle:
                    titleList.remove(bookmark)
                if not oldTitle and newTitle:
                    titleList.append(bookmark)
            bookmarkInfo[i] = (bookmark, timecode, newTitle)

        listCtrl.Bind(wx.EVT_LIST_ITEM_ACTIVATED, OnListCtrlActivated)
        listCtrl.Bind(wx.EVT_LIST_END_LABEL_EDIT, OnListCtrlEndLabelEdit)
        label = wx.StaticText(dlg, wx.ID_ANY, _('Left-click on a selected item or double-click to edit.\n\n'
                                                '*  RED - a historic title, not a real bookmark.\n'
                                                '** Time may be unavailable or incorrect before preview refreshed.'
                                                ))
        # Standard buttons
        okay  = wx.Button(dlg, wx.ID_OK, _('OK'))
        cancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        # Size the elements
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add(listCtrl, 1, wx.EXPAND|wx.ALL, 5)
        dlgSizer.Add(label, 0, wx.LEFT, 5)
        dlgSizer.Add(btns, 0, wx.EXPAND|wx.ALL, 5)
        dlg.SetSizer(dlgSizer)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            for bookmark, timecode, title in bookmarkInfo:
                self.titleDict[bookmark] = title
                if not title:
                    del self.titleDict[bookmark]
            self.UpdateBookmarkMenu()
            if self.previewWindowVisible:
                self.videoSlider.Refresh()
                if self.separatevideowindow:
                    self.videoSlider2.Refresh()
        dlg.Destroy()

    def OnMenuVideoBookmarkRemoveAllTitle(self, event):
        self.titleDict.clear()
        self.currentScript.bookmarks = None
        self.currentScript.bookmarks = self.GetBookmarkDict()
        self.UpdateBookmarkMenu()
        self.videoSlider.Refresh()
        if self.separatevideowindow:
            self.videoSlider2.Refresh()

    def OnMenuVideoGroupApplyOffsets(self, event):
        self.OnGroupApplyOffsets(event)

    def OnMenuVideoGroupOffsetBookmarks(self, event):
        self.OnGroupOffsetBookmarks(event)

    def OnMenuVideoGroupClearTabGroup(self, event):
        self.OnGroupClearTabGroup(event)

    def OnMenuVideoGroupClearAllTabGroups(self, event):
        self.OnGroupClearAllTabGroups(event)

    def OnMenuVideoGroupAssignTabGroup(self, event):
        item = self.tab_group_menu.FindItemById(event.GetId())
        if item == None:
            item = self.videoWindow.contextMenu.FindItemById(event.GetId())
        if item == None:
            event.Skip()
            return
        label = item.GetLabel()
        self.AssignTabGroup(label)
        if self.splitView:
            self.options['applygroupoffsets'] = True
            index = self.scriptNotebook.GetSelection()
            index = index+1 if self.splitView_next else index-1
            if index >- 1 and index < self.scriptNotebook.GetPageCount():
                self.AssignTabGroup(label, index)
                if label != _('None'):
                    self.splitView_freeze = False # auto disable freeze state
                if self.previewWindowVisible and label == _('None'):
                    self.videoWindow.Refresh()

    def OnMenuVideoGotoLastScrolled(self, event):
        self.CheckPlayback()
        curPos = self.videoSlider.GetValue()
        self.ShowVideoFrame(self.lastshownframe)
        self.lastshownframe = curPos
        self.CheckPlayback()

    def OnMenuVideoGotoNextBookmark(self, event, previous=False):
        self.GotoNextBookmark(forceCursor=True)

    def OnMenuVideoGotoPreviousBookmark(self, event):
        self.GotoNextBookmark(reverse=True, forceCursor=True)

     # GPo 2020, for button extra function, for Shift, Alt
    def OnButtonVideoGotoNextBookmark(self, event, reverse=False):
        if wx.GetKeyState(wx.WXK_SHIFT):
            self.GotoNextBookmark(reverse=reverse, forceCursor=True, bmtype=[1,2])
        elif wx.GetKeyState(wx.WXK_ALT):
            self.GotoNextBookmark(reverse=reverse, forceCursor=True, bmtype=[3]) # only titled bookmarks
        else:
            self.GotoNextBookmark(reverse=reverse, forceCursor=True)

    def OnButtonVideoGotoPreviousBookmark(self, event):
        self.OnButtonVideoGotoNextBookmark(event, True)

    def OnMenuVideoGotoClearAll(self, event):
        self.DeleteAllFrameBookmarks(bmtype=0)
        self.titleDict.clear()
        # GPo clear all script bookmarks
        for index in xrange(self.scriptNotebook.GetPageCount()):
            self.scriptNotebook.GetPage(index).bookmarks.clear()

    def OnMenuVideoClearTabBookmarks(self, event):
        self.DeleteAllFrameBookmarks(bmtype=0)
        self.titleDict.clear()
        self.currentScript.bookmarks.clear()

    def OnMenuVideoGoto(self, event):
        if not self.separatevideowindow or not self.previewWindowVisible or self.FindFocus() != self.videoWindow:
            frameTextCtrl = self.frameTextCtrl
        else:
            frameTextCtrl = self.frameTextCtrl2
        frameTextCtrl.SetFocus()

    def OnMenuVideoPrevFrame(self, event):
        unit = 'frames'
        offset = -1
        if event is not None:
            ctrl = event.GetEventObject()
            if isinstance(ctrl, wxButtons.GenBitmapButton):
                sel = self.options['buttonjumpchoice']
                if sel == 1:
                    unit = 'sec'
                elif sel == 2:
                    unit = 'min'
                elif sel == 3:
                    offset = -self.options['customjump']
                    unit = self.options['customjumpunits']
                elif sel == 4:
                    self.JumpToNext_I_Frame(True)
                    return

        if not self.separatevideowindow:
            self.ShowVideoOffset(offset, units=unit)
        else:
            if event is not None and event.GetEventObject() in self.videoControlWidgets and self.previewWindowVisible:
                self.ShowVideoOffset(offset, units=unit, focus=False)
                self.currentScript.SetFocus()
            else:
                self.ShowVideoOffset(offset, units=unit)

    def OnMenuVideoNextFrame(self, event):
        unit = 'frames'
        offset = +1
        if event is not None:
            ctrl = event.GetEventObject()
            if isinstance(ctrl, wxButtons.GenBitmapButton):
                sel = self.options['buttonjumpchoice']
                if sel == 1:
                    unit = 'sec'
                elif sel == 2:
                    unit = 'min'
                elif sel == 3:
                    offset = + self.options['customjump']
                    unit = self.options['customjumpunits']
                elif sel == 4:
                    self.JumpToNext_I_Frame(False)
                    return

        if not self.separatevideowindow:
            self.ShowVideoOffset(offset, units=unit)
        else:
            if event is not None and event.GetEventObject() in self.videoControlWidgets and self.previewWindowVisible:
                self.ShowVideoOffset(offset, units=unit, focus=False)
                self.currentScript.SetFocus()
            else:
                self.ShowVideoOffset(offset, units=unit)

    def OnMenuVideoPrevSecond(self, event):
        self.ShowVideoOffset(-1, units='sec')

    def OnMenuVideoNextSecond(self, event):
        self.ShowVideoOffset(+1, units='sec')

    def OnMenuVideoPrevMinute(self, event):
        self.ShowVideoOffset(-1, units='min')

    def OnMenuVideoNextMinute(self, event):
        self.ShowVideoOffset(+1, units='min')

    def OnMenuVideoFirstFrame(self, event):
        self.CheckPlayback()
        self.ShowVideoFrame(0)
        self.CheckPlayback()

    def OnMenuVideoLastFrame(self, event):
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
        self.ShowVideoFrame(-1)

    def OnMenuVideoPrevCustomUnit(self, event):
        offset = -self.options['customjump']
        units = self.options['customjumpunits']
        self.ShowVideoOffset(offset, units=units)

    def OnMenuVideoNextCustomUnit(self, event):
        offset = +self.options['customjump']
        units = self.options['customjumpunits']
        self.ShowVideoOffset(offset, units=units)

    def OnMenuVideoNextIFrame(self, event):
        self.JumpToNext_I_Frame(maxLoop=350)

    def OnMenuVideoPrevIFrame(self, event):
        self.JumpToNext_I_Frame(reverse=True, maxLoop=350)

    def OnMenuVideoSaveImage(self, event):
        self.SaveImage()

    def OnMenuVideoQuickSaveImage(self, event):
        reset = wx.GetKeyState(wx.WXK_CONTROL) # GPo 2020, reset the name format to default
        path = self.SaveImage(silent=True, resetFormat=reset)
        if path:
            self.StatusbarTimer_Start(txt=_(u'Image saved to "{0}"').format(path))

    def OnMenuVideoCopyImageClipboard(self, event):
        script = self.currentScript
        if script is None or script.AVI is None:
            wx.MessageBox(_('No image to save'), _('Error'),
                          style=wx.OK|wx.ICON_ERROR)
            return False
        w = script.AVI.DisplayWidth
        h = script.AVI.DisplayHeight
        bmp = wx.EmptyBitmap(w, h)
        mdc = wx.MemoryDC()
        mdc.SelectObject(bmp)
        if not self.GetAviDisplayFrame(self.currentScript, self.currentframenum, False) or\
            not script.AVI.DrawFrame(self.currentframenum, mdc):
                wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=self.currentframenum),
                              script.AVI.clip.get_error())), _('Error'), style=wx.OK|wx.ICON_ERROR)
                return False
        bmp_data = wx.BitmapDataObject(bmp)
        if wx.TheClipboard.Open():
            wx.TheClipboard.SetData(bmp_data)
            wx.TheClipboard.Close()
        else:
            wx.MessageBox(_("Couldn't open clipboard"), _('Error'),
                          style=wx.OK|wx.ICON_ERROR)
            return False
        return True

    def OnMenuVideoCropEditor(self, event):
        script = self.currentScript
        dlg = self.cropDialog
        if dlg.IsShown():
            return
        self.StopPlayback()
        # GPo 2018
        self.extended_move = False
        self.splitView = False
        self.zoom_antialias = False
        # Show the video preview
        if not self.ShowVideoFrame(forceLayout=True):
            self.zoom_antialias = self.options['zoom_antialias']
            return False
        if script.AVI.DisplayWidth != script.AVI.Width or \
                script.AVI.DisplayHeight != script.AVI.Height:
            wx.MessageBox(_('Cannot use crop editor\nDisplay clip and source clip have different dimensions'),
                          _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        # Set the spin control ranges
        w = script.AVI.Width
        h = script.AVI.Height
        for key in ('left', '-right'):
            dlg.ctrls[key].SetRange(0, w-self.options['cropminx'])
            dlg.ctrls[key].SetValue(0)
            dlg.ctrls[key].SetSelection(0,-1)
        for key in ('top', '-bottom'):
            dlg.ctrls[key].SetRange(0, h-self.options['cropminy'])
            dlg.ctrls[key].SetValue(0)
            dlg.ctrls[key].SetSelection(0,-1)
        # Show the crop dialog
        self.SetDialogPositionNextToVideo(dlg)
        self.PaintCropWarnings()
        dlg.Show()
        dlg.ctrls['left'].SetFocus()
        dlg.ctrls['left'].SetSelection(0,-1)
        # Set the crop status text
        self.SetVideoStatusText()

    def OnMenuToggleFullscreen(self, event):
        obj = self if not self.separatevideowindow else self.videoDialog
        if self.currentScript.AVI or obj.IsFullScreen():
            self.OnLeftDClickVideoWindow(None, toggleFullscreen=True)

    def OnMenuExtendedMove(self, event):
        if not self.KeyUpVideoWndow:
            return
        self.KeyUpVideoWndow = False
        wx.CallLater(400, self.OnKeyUpVideoWindow, None)
        self.extended_move = not self.extended_move
        self.ShowVideoFrame(forceLayout=True)

    def OnMenuSplitViewEx(self, event):
        self.splitViewEx = not self.splitViewEx
        if self.splitView:
            self.videoWindow.Refresh()
        elif self.splitViewEx:
            self.OnMenuSplitView()

    def OnMenuSplitView(self, event=None):
        self.splitView = not self.splitView
        xy = None # for splitView_lastShown view pos x,y

        if self.splitView:
            script = None
            self.splitView = False

            if not self.previewWindowVisible:
                self.refreshAVI = True
                self.zoom_antialias = False
                if not self.ShowVideoFrame():
                    self.ResetZoomAntialias(forceYield=False)
                    return
                if self.separatevideowindow:
                    self.videoDialog.Refresh()
                    self.videoDialog.Update()
                self.Refresh()
                self.Update()
                self.ResetZoomAntialias()

            pageCount = self.scriptNotebook.GetPageCount()
            index = self.scriptNotebook.GetSelection()
            currScript = self.currentScript
            if currScript.AVI.IsErrorClip():
                return

            if pageCount == 1:
                self.NewTab(copytab=True)
                if self.scriptNotebook.GetPageCount() < 2:
                    return
                self.splitView_next = False # false, new index is 1 and not 0
                script,idx = self.getScriptAtIndex(1)
            elif pageCount == 2 and index == 0:
                self.splitView_next = True
                script,i = self.getScriptAtIndex(1)
            else:
                if index == pageCount - 1: # on last tab use previous tab
                    self.splitView_next = False
                else: self.splitView_next = True
                if self.splitView_next:
                    script,idx = self.getScriptAtIndex(index + 1)
                else: script,idx = self.getScriptAtIndex(index - 1)

            if self.splitView_nextScript is not None and self.splitView_nextScript is self.getScriptAtIndex(index - 1)[0]:
                script,idx = self.getScriptAtIndex(index - 1)
                self.splitView_next = False

            if script is not None:
                w = currScript.AVI.DisplayWidth
                h = currScript.AVI.DisplayHeight
                self.refreshAVI = True

                if currScript.resizeFilter[0] or currScript.resizeFilter[0] != script.resizeFilter[0]:
                    script.resizeFilter = currScript.resizeFilter
                    script.display_clip_refresh_needed = True
                    resizeInfo = self.GetResizeFilterInfo(script, fixed_Size=wx.Size(w,h))
                else: resizeInfo = None

                needUpdate = not self.previewOK(script)
                if self.UpdateScriptAVI(script=script, forceRefresh=False, prompt=False,
                        resizeFilterInfo=resizeInfo) is not None and script.AVI is not None:
                    if needUpdate:
                        self.UpdateScriptTabname(script)
                    if not script.AVI.IsErrorClip():
                        if script.AVI.DisplayWidth != w or script.AVI.DisplayHeight != h:
                            dlg = wx.MessageDialog(self, 'Both videos must have the same width and height.\nCopy current tab to next?','Split View Error')
                            ID = dlg.ShowModal()
                            dlg.Destroy()
                            if ID == wx.ID_OK:
                                self.OnMenuCopyToNewTabNext(None)
                            return
                        wx.BeginBusyCursor()
                        # must be before  get display frame
                        if script.AVI.current_frame > -1:
                            script.lastFramenum = script.AVI.current_frame
                        else:
                            if script.lastFramenum is None:
                                script.lastFramenum = self.currentframenum
                        #"""
                        try:
                            #re = self.GetAviDisplayFrame(script, self.currentframenum, srcFrame=True)
                            re = self.GetAviDisplayFrame(script, script.lastFramenum, srcFrame=True)
                            if not re and self.currentScript == script:
                                self.HidePreviewWindow()
                        finally:
                            wx.EndBusyCursor()
                        if re and script.AVI.display_clip.get_error() is None:
                            self.splitView = True
                            frame, dwidth, zoom, vstart = self.splitView_lastShown
                            if frame == self.currentframenum  and dwidth == self.currentScript.AVI.DisplayWidth:# and self.zoomfactor == zoom:
                                self.zoomfactor = zoom
                                xy = vstart # restore the view pos
                        else: wx.Bell()
                        """
                        self.splitView = True
                        frame, dwidth, zoom, vstart = self.splitView_lastShown
                        if frame == self.currentframenum  and dwidth == self.currentScript.AVI.DisplayWidth:# and self.zoomfactor == zoom:
                            self.zoomfactor = zoom
                            xy = vstart # restore the view pos
                        """

                    else: wx.Bell()
            else: wx.Bell()

        elif self.previewOK(): # save the last splitView view pos x,y
            self.splitView_lastShown = (self.currentframenum, self.currentScript.AVI.DisplayWidth, self.zoomfactor, self.videoWindow.GetViewStart())
        else:
            self.splitView_lastShown = (None, None, None, None)
        self.zoom_antialias = False
        self.ShowVideoFrame(forceLayout=True, forceCursor=True,  scroll=xy)
        if self.extended_width > 0:
            self.OnEraseBackground()
        self.ResetZoomAntialias()

    def KillFilterClip(self):
        script = self.currentScript
        if script.AVI is not None and script.AVI.preview_filter:
            self.CheckPlayback()
            script.AVI.KillFilterClip()
            self.bmpVideo = None
            self.videoWindow.Refresh()
            self.SetPreviewFilterMenus()
            self.SetVideoStatusText()
            self.CheckPlayback()
            return True

    def SetPreviewFilterMenus(self, setIdx=0):
        script = self.currentScript
        setIdx = min(setIdx, 5) # max menu filter item count
        if setIdx < 1:
            self.UpdateMenuItem(_('Preview filter'), True, 'video', [_('None')])
            script.chkPreviewFilter.SetValue(False)
        else:
            self.UpdateVideoSubMenuByPosition(_('Preview filter'), setIdx, True)
            script.chkPreviewFilter.SetValue(True)
        script.previewFilterIdx = setIdx

    #@AsyncCallWrapper
    def OnMenuPreviewFilter(self, event=None, index=None, updateUserSliders=True, scroll=None, focus=True):
        def updateState(state, t=0):
            # update the menu items
            if state < 1: # filter disabled
                self.UpdateVideoSubMenuByPosition(_('Preview filter'), 0, True)
                script.lastpreviewFilterIdx = script.previewFilterIdx
                script.previewFilterIdx = 0
                script.chkPreviewFilter.SetValue(False)
            elif ret: # filter OK
                self.UpdateVideoSubMenuByPosition(_('Preview filter'), state, True)
                script.previewFilterIdx = state
                script.lastpreviewFilterIdx = state
                #if self.ShowPFilterTime:
                    #script.sliderWindow.previewFilterTime = t
                script.chkPreviewFilter.SetValue(True)
            else: # preview filter failed, disable it
                self.UpdateVideoSubMenuByPosition(_('Preview filter'), 0, True)
                script.lastpreviewFilterIdx = script.previewFilterIdx
                script.previewFilterIdx = 0
                script.chkPreviewFilter.SetValue(False)
            #script.sliderWindow.PaintPFilterTime()

        script = self.currentScript
        #script.sliderWindow.previewFilterTime = 0
        self.CheckPlayback()

        if event is not None:
            vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
            id = event.GetId()
            for vidmenu in vidmenus:
                menu = vidmenu.FindItemById(vidmenu.FindItem(_('Preview filter'))).GetSubMenu()
                menuItem = menu.FindItemById(id)
                if menuItem:
                    label = menuItem.GetLabel()
                    if label == _('None'):
                        lKey = 0
                    else:
                        lKey = int(label[:1])
                    break
        elif index is not None:
            lKey = index
        else:
            return
        if lKey > 5:
            return

        ret = None
        self.previewFilterDict.clear() # GPo new
        needStatus = True

        # if preview not OK force show video frame, or we cannot put the preview
        if lKey > 0:
            previewOK = self.previewOK(script)
            if not previewOK:
                self.refreshAVI = True
                self.ShowVideoFrame(forceLayout=True, focus=focus)
                previewOK = self.previewOK(script)

        # find and count the script preview filters, else KillFilter
        if lKey > 0 and previewOK:
            self.ParseScriptPreviewFilters(None)
            if self.previewFilterDict:
                maxKey = min(len(self.previewFilterDict), 5) # max 5 menu items, select max the last
                lKey = min(lKey, maxKey)
                ident,arg,pos = self.previewFilterDict[lKey]
                if arg:
                    wx.BeginBusyCursor()
                    #t = time.time()
                    ret, err = script.AVI.CreateFilterClip(arg)
                    updateState(lKey) #~updateState(lKey, time.time() - t)
                    wx.EndBusyCursor()
                    if err:
                        wx.MessageBox(err, "Preview filter")
                        script.display_clip_refresh_needed = True
                        self.refreshAVI = True #updateUserSliders
                    else:
                        script.display_clip_refresh_needed = False # GPo new resizeFilter
                    needStatus = not self.ShowVideoFrame(userScrolling=not updateUserSliders, scroll=scroll, focus=focus)
                else:
                    updateState(0)
                    if script.AVI is not None and script.AVI.preview_filter:
                        script.AVI.KillFilterClip()
                        needStatus = not self.ShowVideoFrame(userScrolling=not updateUserSliders, scroll=scroll, focus=focus)
            else:
                updateState(0) # bevor showing the frame, it's better to update the State
                needStatus = not self.KillFilterClip()
        else:
            updateState(0)
            if script.AVI is not None and script.AVI.preview_filter:
                script.AVI.KillFilterClip()
            if lKey > -1 and self.previewOK(script):
                needStatus = not self.ShowVideoFrame(userScrolling=not updateUserSliders, scroll=scroll, focus=focus)

        if updateUserSliders:
            if script.sliderWindowShown:
                script.sliderWindow.Update() # force Update before create the sliders new (mutch better as without)
            self.UpdateUserSliders()
        if needStatus and focus:
            self.SetVideoStatusText()
        self.CheckPlayback()

    def ParseScriptPreviewFilters(self, filterDict=None, cleanText=True):
        # it is fast, max 1 ms for 800 line script and one filter at the end
        #print('parse')
        if filterDict is None:
            self.previewFilterDict.clear()
            filterDict = self.previewFilterDict
        else:
            filterDict.clear

        arg = ''
        found = False
        script = self.currentScript

        if cleanText:
            lines = self.getCleanText(script.GetText()).split('\n')
        else:
            lines = script.GetText().split('\n')

        key = 0
        start = idx = -1
        if lines:
            #for idx, line in enumerate(lines):
            for line in lines:
                idx += 1
                if found:
                    if line.lstrip().startswith('**/'):
                        found = False
                        arg = arg.strip()
                        if arg:
                            key += 1
                            filterDict[key] = (ident,arg,(start,idx))
                        arg = ''
                        continue
                    arg += line + '\n'
                elif line.startswith('/**avsp_filter'):
                    ident = line.strip()
                    ident = ident[:50] # max 50 chars
                    found = True
                    start = idx
                elif line.lower().startswith('__end__'):
                    break
        return filterDict

    def ComparePreviewFilterDict(self, filterDict=None):
        if filterDict is None:
            filterDict = {}
            self.ParseScriptPreviewFilters(filterDict)
        if len(filterDict) != len(self.previewFilterDict):
            return False
        """
        for key in self.previewFilterDict.keys():
            if not key in filterDict:
                return False
            if self.previewFilterDict[key][1] != filterDict[key][1]
                return False
        return True
        """
        # only for Python 2
        return cmp(filterDict, self.previewFilterDict) == 0

    def OnMenuSavePreviewFilters(self, event=None):
        filterDict = {}
        self.ParseScriptPreviewFilters(filterDict, cleanText=False)
        if not filterDict:
            dlg = wx.MessageDialog(self, _('No filters found, clear the current saved filters?'),
                                         _('Preview filters'), wx.YES_NO)
            ID = dlg.ShowModal()
            dlg.Destroy()
            if ID != wx.ID_YES:
                return
        self.optionsPreviewFilters['previewfilters'] = filterDict
        with open(self.optionsPreviewFiltersFilename, mode='wb') as f:
            cPickle.dump(self.optionsPreviewFilters, f, protocol=0)
        self.UpdatePreviewFilterMenu(filterDict, isRestoreMenu=True)

    def OnMenuRestoreAllPreviewFilters(self, event=None):
        f = ''
        filterDict = self.optionsPreviewFilters['previewfilters']
        for key in filterDict.keys():
            ident, arg, pos = filterDict[key]
            f += '\n' + ident +'\n' + arg + '\n**/\n'
        self.InsertTextAtScriptEnd(f, self.currentScript)

    def OnMenuRestorePreviewFilter(self, event):
        if not event:
            return
        lKey = -1
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('Preview filter'))).GetSubMenu()
            menu = menu.FindItemById(menu.FindItem(_('Write to script'))).GetSubMenu()
            menuItem = menu.FindItemById(event.GetId())
            if menuItem:
                label = menuItem.GetLabel()
                lKey = int(label[:1])
                break
        if lKey < 1:
            wx.Bell()
            return
        filterDict = {}
        filterDict.update(self.optionsPreviewFilters['previewfilters'])
        if len(filterDict) < 1:
            wx.Bell()
            return
        lKey = min(lKey, len(filterDict))
        ident, arg, pos = filterDict[lKey]
        f = '\n' + ident + '\n' + arg + '\n**/\n'
        #~self.InsertTextAtScriptEnd(f, self.currentScript)
        self.InsertText(f, None)

    #@AsyncCallWrapper
    def UpdatePreviewFilterMenu(self, filterDict, isRestoreMenu=False):
        maxIdx = len(filterDict)
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('Preview filter'))).GetSubMenu()
            if menu:
                r1 = 1 # first item is 'None'
                r2 = 6
                cr = 0
                if isRestoreMenu:
                    menu = menu.FindItemById(menu.FindItem(_('Write to script'))).GetSubMenu()
                    if not menu:
                        return
                    r1 = 0
                    r2 = 5
                    cr = 1
                for i in range(r1,r2):
                    menuItem = menu.FindItemByPosition(i)
                    txt = menuItem.GetItemLabel()
                    shortCut = txt.split('\t')
                    if len(shortCut) < 2:
                        shortCut = ''
                    else:
                        shortCut = '\t'+ shortCut[1]
                    if (maxIdx >= i) and (i+cr in filterDict):
                        label, arg, pos = filterDict[i+cr]
                        le = 3 if label.startswith('/**') else 2
                        if len(label) > 19:
                            label = str(i+cr) + ' ' + label[11+le:60]
                        else:
                            label = str(i+cr) + ' ' + label[le:50]
                    else:
                        label = str(i+cr)
                    menuItem.SetItemLabel(label+shortCut)

    def UpdatePreviewFilterRestoreMenu(self):
        filterDict = self.options['previewfilter']
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('Preview filter'))).GetSubMenu()
            if menu:
                menu = menu.FindItemById(menu.FindItem(_('Write to script'))).GetSubMenu()
                if menu:
                    for i in range(0,5):
                        menuItem = menu.FindItemByPosition(i)
                        txt = menuItem.GetItemLabel()
                        shortCut = txt.split('\t')
                        if len(shortCut) < 2:
                            shortCut = ''
                        else:
                            shortCut = '\t'+ shortCut[1]
    #@AsyncCallWrapper
    def UpdateUserSliders(self, forceUpdate=False):
        script = self.currentScript
        if not self.options['autoslideron'] or not self.previewOK(script):
            return

        scripttxt = script.GetText()
        isError = False
        needRefresh = False

        # get the slider infos
        self.UpdateScriptTagProperties(script, scripttxt)
        self.GetAutoSliderInfo(script, scripttxt)
        toggleTagNames = [a for a,b in script.toggleTags]
        oldToggleTagNames = [a for a,b in script.oldToggleTags]
        # force the update
        if forceUpdate:
            script.oldSliderTexts = oldToggleTagNames = script.oldAutoSliderInfo = None
        if toggleTagNames != oldToggleTagNames:
            self.createToggleTagCheckboxes(script)
            needRefresh = True
        if script.autoSliderInfo != script.oldAutoSliderInfo:
            self.createAutoUserSliders(script)
            needRefresh = True
        if script.sliderTexts != script.oldSliderTexts:
            if not self.createUserSliders(script):
                isError = True
            else: needRefresh = True
        if needRefresh:
            script.sliderWindow.Freeze()
            script.propertySizer.Layout()
            script.videoSidebarSizer.Layout()
            script.sliderWindow.FitInside()
            self.TryThaw(script.sliderWindow)
            # set the old values or ShowVideoFrame force update the sliders
            script.oldSliderTexts = script.sliderTexts
            script.oldAutoSliderInfo = script.autoSliderInfo
            script.oldToggleTags = script.toggleTags
            # set slider window and toggle button state (enabel or disable the button or hide the window)
            if self.propWindowParent > 0:
                boolSliders = True # GPo, test for display frame properties in the slider window
            else:
                boolSliders = bool(script.sliderTexts or script.sliderProperties or script.toggleTags or script.autoSliderInfo)
            if (boolSliders and not self.toggleSliderWindowButton.IsEnabled()) or \
                (not boolSliders and self.toggleSliderWindowButton.IsEnabled()):
                    if boolSliders:
                        self.toggleSliderWindowButton.Enable()
                        if script.sliderWindowShown:
                            script.sliderWindow.Show()
                            self.ShowSliderWindow(script)
                        else:
                            if not self.videoSplitter.IsSplit() and not self.options['keepsliderwindowhidden'] and not script.userHidSliders:
                                self.ToggleSliderWindow()
                            else:
                                self.HideSliderWindow(script)
                    else:
                        script.sliderWindowShown = True
                        self.ToggleSliderWindow()
                        self.toggleSliderWindowButton.Disable()
        # on error close the slider window
        if isError:
            self.HideSliderWindow(script)
            return
        return needRefresh

    def DisableResizeFilter(self, script=None, onlyFitFill=False):
        if script is None:
            rf = self.currentScript.resizeFilter
        else:
            rf = script.resizeFilter

        #~self.resizeFilter = (False, rf[1], rf[2], rf[3])
        self.resizeFilter = (False, rf[1], 1, rf[3]) # new, reset zoom to 1 (scroll)
        if not script:
            for i in xrange(self.scriptNotebook.GetPageCount()):
                _script = self.scriptNotebook.GetPage(i)
                if _script.resizeFilter[0]:
                    if onlyFitFill and _script.resizeFilter[2] != 1:
                        continue
                    _script.display_clip_refresh_needed = True
                _script.resizeFilter = self.resizeFilter
                if _script.AVI:
                    _script.AVI.SetResizeFilter(None)
        elif not onlyFitFill or script.resizeFilter[2] == 1:
            if rf[0]:
                script.display_clip_refresh_needed = True
            script.resizeFilter = self.resizeFilter
            if script.AVI:
                script.AVI.SetResizeFilter(None)

        if self.splitView:
            if self.splitView_next:
                _script, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() + 1)
            else:
                _script, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() - 1)
            if rf[0]:
                _script.display_clip_refresh_needed = True
                self.CheckPlayback()
                self.UpdateScriptAVI(_script)
                self.CheckPlayback()

    def ResizeFilterUpdateSplitView(self):
        if self.splitView:
            if self.splitView_next:
                script, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() + 1)
            else:
                script, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() - 1)
            script.display_clip_refresh_needed = True
            self.currentScript.display_clip_refresh_needed = True
            if self.UpdateScriptAVI(self.currentScript) is not None:
                return self.UpdateScriptAVI(script) is not None
            return None
        return True

    # the resample fixed zoom menus receiver
    def OnMenuVideoZoomResampleZoom(self, event, zoom=1):
        if self.cropDialog.IsShown() or self.options['showresamplemenu'] == 0:
            return
        strg = wx.GetKeyState(wx.WXK_CONTROL)
        if event:
            label = ''
            id = event.GetId()
            vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
            for vidmenu in vidmenus:
                menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Zoom'))).GetSubMenu()
                menuItem = menu.FindItemById(id)
                if menuItem:
                    label = menuItem.GetLabel()
                    break
            if label:
                zoom = label.split('%')
            if zoom[0].isdigit():
                zoom = float(zoom[0])/100
            else:
                zoom = 1
        # if control pressed only the current script is affected (the case on all resample menus)
        self.OnMenuVideoZoomResampleFit(zoom=zoom, single= not strg)

    def OnMenuVideoZoomResampleFill(self, event):
        strg = wx.GetKeyState(wx.WXK_CONTROL)
        self.OnMenuVideoZoomResampleFit(fitHeight=False, single=not strg)

    # this is the main function for setting the resize filter
    def OnMenuVideoZoomResampleFit(self, event=None, zoom=1, fitHeight=True, single=True, sameSize=None, doScroll=False):
        def calc_scroll(new_zoom, old_zoom):
            xrel, yrel = self.videoWindow.ScreenToClient(wx.GetMousePosition())
            xpos, ypos = self.videoWindow.CalcUnscrolledPosition(xrel, yrel)
            xpos = (xpos - self.xo) * new_zoom / old_zoom + self.xo
            ypos = (ypos - self.yo) * new_zoom / old_zoom + self.yo
            return xpos - xrel, ypos - yrel

        if self.cropDialog.IsShown() or self.options['showresamplemenu'] == 0:
            return

        self.CheckPlayback()
        cs = self.videoWindow.GetSize()
        need_update = cs[0] < 36 or cs[1] < 36 # video window size not initialized
        script = self.currentScript
        if event:
            single = not wx.GetKeyState(wx.WXK_CONTROL)
        rf = script.resizeFilter
        self.OnMenuVideoZoom(zoomfactor=1, show=False, resizeFilterOff=False) # set 100% zoom
        if script.AVI.IsErrorClip():
            return
        # abs(zoom): mouse weehl sendet zoom -1 ist zoom = 1, sonst wuerde der zoom nicht gesetzt sonder fill oder fit
        if rf[3] != fitHeight or rf[2] != zoom:
            resizeFilter = (zoom != -1, rf[1], abs(zoom), fitHeight)
        else:
            resizeFilter = (not rf[0], rf[1], abs(zoom), fitHeight)

        scroll = None
        if single:
            script.resizeFilter = resizeFilter
            if doScroll: # only if single and shift is down in mouse event OnMouseWheelVideoWindow
                scroll = calc_scroll(abs(zoom), rf[2])
        elif sameSize and self.previewOK():
            script.resizeFilter = resizeFilter
            vW, vH = script.AVI.Width, script.AVI.Height
            for i in xrange(self.scriptNotebook.GetPageCount()):
                _script = self.scriptNotebook.GetPage(i)
                if _script != script and _script.AVI is not None:
                    vw, vh = _script.AVI.Width, _script.AVI.Height
                    if (vw,vh) == (vW,vH):
                        _script.resizeFilter = resizeFilter
                        _script.display_clip_refresh_needed = True
        else:
            self.resizeFilter = resizeFilter
            for i in xrange(self.scriptNotebook.GetPageCount()):
                _script = self.scriptNotebook.GetPage(i)
                _script.resizeFilter = resizeFilter
                if _script != script:
                    _script.display_clip_refresh_needed = True

        if self.splitView:
            if self.splitView_next:
                _script, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() + 1)
            else:
                _script, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() - 1)
            _script.display_clip_refresh_needed = True
            _script.resizeFilter = script.resizeFilter # GPo new
            self.UpdateScriptAVI(_script)

        if script.previewFilterIdx > 0 and script.AVI:
            script.AVI.SetResizeFilter(self.GetResizeFilterInfo(script))
            self.OnMenuPreviewFilter(index=script.previewFilterIdx, updateUserSliders=False, scroll=scroll)
        else:
            script.display_clip_refresh_needed = True
            if self.ShowVideoFrame(scroll=scroll) and need_update:
                script.display_clip_refresh_needed = True
                self.ShowVideoFrame()

        if scroll:
            self.videoWindow.oldPoint = self.videoWindow.ScreenToClient(wx.GetMousePosition())
            self.videoWindow.oldOrigin = self.videoWindow.GetViewStart()

    # jump to next I frame
    #@AsyncCallWrapper
    def JumpToNext_I_Frame(self, reverse=False, maxLoop=350):
        self.StopPlayback()
        script = self.currentScript

        if script.AVI is None:
            if not self.ShowVideoFrame():
                return
            self.SaveCallYield()
        if not self.previewOK(script) or self.AviThread_Running(script) or wx.IsBusy():
            wx.Bell()
            return

        nr = start = self.currentframenum
        maxcount = nr if reverse else script.AVI.Framecount - nr
        found = False
        userBreake = False
        statusbar = self.GetStatusBar()
        """~ Variante 1
        readFrameProps = self.readFrameProps
        if not readFrameProps:
            self.SetReadFrameProps(True)
        if script.AVI.properties.find('_PictType') < 0:
            if not readFrameProps:
                self.SetReadFrameProps(False)
            wx.Bell()
            return
        """
        wx.BeginBusyCursor()
        disabler = wx.WindowDisabler()
        blocker = wx.EventBlocker(self)
        #blocker.Block(wx.wxEVT_KEY_DOWN)
        #blocker.Block(wx.wxEVT_KEY_UP)
        try:
            for x in xrange(maxcount):
                if wx.GetKeyState(wx.WXK_ESCAPE):
                    userBreake = True
                    break
                if reverse:
                    nr -= 1
                    if nr < 0:
                        break
                else:
                    nr += 1
                    if nr >= script.AVI.Framecount:
                        break
                # It's threaded if threads enabled
                t = time.time()                                                           # cancel if progress dialog was shown
                if not self.GetAviDisplayFrame(script, nr, showWarn=False, srcFrame=True) or (time.time()-t > self.progressDelayTime):
                    break
                err = script.AVI.clip.get_error()
                if err:
                    wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=nr),
                                  err)), _('Error'), style=wx.OK|wx.ICON_ERROR)
                    break
                """~ Variante 1 works, but we must set read properties True/False if read properties not enabled
                sp = script.AVI.properties.split('_PictType (')
                if len(sp) == 2:
                    s = sp[1][:1]
                    if s == 'I':
                        found = True
                        break
                    elif not s in ('P','B'):
                        break
                else:
                    break
                """
                # Variante 2 not threaded, but I think for get properties is a thread not needed
                # and we don't need to set read properties to true/false
                s = script.AVI.GetPictureType()
                if s == 'I':
                    found = True
                    break
                elif not s in ('B', 'P'):
                    break

                if reverse:
                    if nr + maxLoop < start:
                        break
                    statusbar.SetStatusText('Press Esc - Frames: %i/%i - Frame: %i, type %s' % (start-nr,maxLoop-(start-nr),nr,s))
                else:
                    if nr > start + maxLoop:
                        break
                    statusbar.SetStatusText('Press Esc - Frames: %i/%i - Frame: %i, type %s' % (nr-start,maxLoop-(nr-start),nr,s))
                self.SaveCallYield()
        finally:
            del disabler
            del blocker
            if wx.IsBusy():
                wx.EndBusyCursor()
            #~if not readFrameProps: #~ Variante 1
                #~self.SetReadFrameProps(False)
            if found:
                self.ShowVideoFrame(nr)
            else:
                self.ShowVideoFrame(start)
                if not userBreake:
                    wx.Bell()

    def OnMenuReloadAvisnth(self, event):
        self.OnMenuVideoReleaseMemory(None)
        if not pyavs.AvsReloadLibrary():
            self.ExitProgram(restart=True)

    # LocateFrame seems not be thread save
    """
    def OnMenuLocateFrame(self, event):
        def _locateframe(script, q):
            nr, diff, err =  script.AVI.LocateFrame(start=-500, stop=500)
            wx.MilliSleep(10)
            q.put((nr, diff, err))

        if self.previewOK():
            script = self.currentScript
            if script.FindText(0, script.GetTextLength(), 'find_clip') < 0:
                wx.MessageBox("Variable 'find_clip' not found\nPlease reade the Locate frame readme", 'LocateFrame Error')
                return

            if not self.propWindow.Active:
                self.propWindow.Toggle()
                self.propWindow.Update()
                propWasShown = False
            else: propWasShown = True

            wx.BeginBusyCursor()
            nr = -1
            err = None
            if self.UseAviThread:
                disabler = None
                blocker = None
                q = queue.Queue()
                th = threading.Thread(target=_locateframe, args=(script, q,))
                th.daemon = True
                th.name = 'frame'
                script.AviThread = th
                th.start()
                th.join(self.progressDelayTime)
                if th.isAlive():
                    self.TH_WaitForFrame(script, th, self.currentframenum)
                else: script.AviThread = None
                try:
                    nr, diff, err = q.get(True, 0.1)
                except:
                    pass
            else:
                disabler = wx.WindowDisabler()
                blocker = wx.EventBlocker(self)
                nr,diff,err = script.AVI.LocateFrame(start=-500, stop=500) # not threaded

            try:
                if nr > -1:
                    if self.splitView and self.splitView_nextScript is not None:
                        freeze = self.splitView_freeze
                        self.splitView_freeze = True
                        if script.group is None or script.group != self.splitView_nextScript.group:
                            self.OnGroupClearTabGroup(group='8')
                            self.splitView_nextScript.group = script.group = '8'
                        try:
                            script.group_frame = self.currentframenum
                            self.splitView_nextScript.group_frame = nr
                            self.splitView_nextScript.lastFramenum = nr
                            self.splitView_nextScript.AVI.current_frame = -1 # force getframe for drawing
                            self.ShowVideoFrame()
                        finally:
                            self.splitView_freeze = freeze
            finally:
                if disabler: del disabler
                if blocker: del blocker
                if wx.IsBusy(): wx.EndBusyCursor()
                if nr < 0:
                    wx.Bell()
                    if err:
                        wx.MessageBox(err, 'LocateFrame Error', style=wx.OK|wx.ICON_ERROR)
                        if not propWasShown:
                            self.propWindow.Toggle()
    """
    def OnMenuLocateFrame(self, event):
        """
        def FromClipboard():
            if not wx.TheClipboard.IsOpened():
                wx.TheClipboard.Open()
                text = wx.TextDataObject('')
                if wx.TheClipboard.GetData(text):
                    text = text.GetText()
                    pos = text.find('\n')
                    if len(text) > pos:
                        return
                    pos = text.find('(')
                    if pos > 2 and text.find(')') > pos+2:
                        return text.strip()
        """
        if self.previewOK():
            script = self.currentScript
            #if script.FindText(0, script.GetTextLength(), 'find_clip') < 0:
                #wx.MessageBox("Variable 'find_clip' not found\nPlease reade the Locate frame readme", 'LocateFrame Error')
                #return

            if not self.propWindow.Active:
                self.propWindow.Toggle()
                self.propWindow.Update()
                propWasShown = False
            else: propWasShown = True

            wx.BeginBusyCursor()
            disabler = wx.WindowDisabler()
            blocker = wx.EventBlocker(self)
            err = None
            nr = -1
            find_src = None
            findframe = None
            #findclip = None # test
            if self.splitView and self.splitView_nextScript is not None and self.previewOK(self.splitView_nextScript):
                findframe = self.splitView_nextScript.AVI.current_frame
                #findclip = self.splitView_nextScript.AVI.clip # test
                find_src = self.splitView_nextScript.GetSelectedText().split('\n')[0] or script.GetSelectedText().split('\n')[0]
                #if not find_src:
                    #find_src = FromClipboard()
                #if not find_src:
                    #find_src = script.GetSelectedText().split('\n')[0]
                if find_src.find('(') < 3 or find_src.find(')') < 5:
                    find_src = ''
            else:
                find_src = script.GetSelectedText().split('\n')[0]
                #if not find_src:
                    #find_src = FromClipboard()
                if find_src.find('(') < 3 or find_src.find(')') < 5:
                    find_src = ''
            if find_src: find_src = find_src.replace('#', '').strip()
            #print(find_src)
            try:
                nr,diff,err = script.AVI.LocateFrame(start=-500, stop=500, framenr=findframe, find_src=find_src) # not threaded
                if nr > -1:
                    if self.splitView and self.splitView_nextScript is not None:
                        freeze = self.splitView_freeze
                        self.splitView_freeze = True
                        if script.group is None or script.group != self.splitView_nextScript.group:
                            self.OnGroupClearTabGroup(group='8')
                            self.splitView_nextScript.group = script.group = '8'
                        try:
                            script.group_frame = self.currentframenum
                            self.splitView_nextScript.group_frame = nr
                            self.splitView_nextScript.lastFramenum = nr
                            self.splitView_nextScript.AVI.current_frame = -1 # force getframe for drawing
                            self.ShowVideoFrame()
                        finally:
                            self.splitView_freeze = freeze
            finally:
                del disabler
                del blocker
                if wx.IsBusy():
                    wx.EndBusyCursor()
                if nr < 0:
                    wx.Bell()
                    if err:
                        wx.MessageBox(err, 'LocateFrame Error', style=wx.OK|wx.ICON_ERROR)
                        if not propWasShown and nr > -2:
                            self.propWindow.Toggle()



    def OnMenuTest(self, event):
        pass
    """
    def OnMenuTest(self, event):
        import session_info
        session_info.ShowSessionInfo(self)
        return
        script = self.currentScript
        script.AnnotationSetText(5, 'Hallo')
        script.AnnotationSetVisible(True)
        return
        script = self.currentScript.GetText()
        arg1 = arg2 = filterarg = ''
        found = end = False

        t = time.time()
        f_args = script.split('/**avsp_split', 1)
        if len(f_args) == 2:
            f_args[1] = f_args[1].strip()
            if f_args[1].startswith('**/'):       # then /**avsp_fast_clip**/ without anny filter
                arg1 = f_args[0].strip()
                arg2 = f_args[1][3:].strip()
            else:
                s_args = f_args[1].split('**/', 1)
                if len(s_args) == 2:
                    arg1 = f_args[0].strip()
                    arg2 = s_args[1]
                    filterarg = s_args[0].strip()
                    s = ''
                    for line in filterarg.split('\n'):
                        if not line.lstrip().startswith('#'):
                            s += line + '\n'
                    filterarg = s.strip()
        print(str(time.time()-t))


        arg1 = arg2 = filterarg = ''
        found = end = False
        t = time.time()

        if script.find('/**avsp_split') > -1:
            for line in script.split('\n'):
                if not found:
                    if line.lstrip().startswith('/**avsp_split'):
                        found = True
                        if len(line) > 12 and line[13:].strip().startswith('**/'):
                            end = True
                        continue
                    arg1 += line + '\n'
                else:
                    if not end:
                        if line.lstrip().startswith('**/'):
                            end = True
                            continue
                        if line.startswith('#'):
                            filterarg += '\n'
                        else:
                            filterarg += line + '\n'
                    else:
                        arg2 += line + '\n'
            filterarg = filterarg.strip()
        print(str(time.time()-t))


        arg1 = arg2 = filterarg = ''
        found = end = False
        t = time.time()

        f_args = script.split('/**avsp_split', 1)
        pos = f_args[1].find('**/')
        if len(f_args) == 2 :
            for line in script.split('\n'):
                if not found:
                    if line.lstrip().startswith('/**avsp_split'):
                        found = True
                        if len(line) > 12 and line[13:].startswith('**/'):
                            end = True
                            break
                    arg1 += line + '\n'
                else:
                    if not end:
                        if line.lstrip().startswith('**/'):
                            end = True
                            break
                        if line.startswith('#'):
                            filterarg += '\n'
                        else:
                            filterarg += line + '\n'
            if end:
                pos = f_args[1].find('**/')
                if pos > -1:
                    arg2 = f_args[1][pos+3:]
            filterarg = filterarg.strip()
        print(str(time.time()-t))

        return
    """

    def ShowFreeMemory(self, returnStr=False):
        if not returnStr and self.options['showfreememory'] < 1:
            return
        mem = wx.GetFreeMemory()
        try:
            mem = int(mem/1024/1024)
        except:
            mem = 0
        if returnStr:
            return _('Available Memory: {} MB').format(mem)
        if mem < self.options['showfreememory']:
            wx.CallAfter(self.StatusbarTimer_Start, 3000, _('Available Memory: {} MB').format(mem) , 1)

    def OnMenuShowFreeMemory(self, event):
        self.StatusbarTimer_Start(3000, self.ShowFreeMemory(returnStr=True))

    def OnMenuAutoTakeSnapShot(self, event):
        self.options['autosnapshot'] = event.IsChecked()
        self.UpdateMenuItem(_('Snapshot'), event.IsChecked(), 'video', [_('Auto take snapshot 2')])
        self.UpdateUserSliders(forceUpdate=True) # Change the snapshot 2 label

    def TakeSnapShot(self, shotIdx):
        if not shotIdx in (0,1):
            return
        self.snapShotIdx = 0
        script = self.currentScript
        if not self.ShowVideoFrame(forceLayout=True):
            return
        if not script.AVI:
            return
        bmp = wx.EmptyBitmap(script.AVI.DisplayWidth, script.AVI.DisplayHeight)
        dc = wx.MemoryDC()
        dc.SelectObject(bmp)
        if not script.AVI.DrawFrame(self.currentframenum, dc):
            self.ErrorMessage_GetFrame(script, self.currentframenum)
            return
        txt = self.currentScript.GetText()
        shotKey = 'shot' + str(shotIdx+1)
        script.snapShots[shotKey][1] = None # free bmp
        script.snapShots[shotKey] = [self.currentframenum, bmp, txt, script.previewFilterIdx]
        return True

    def ShowSnapShot(self, index, showMsg=True):
        if not index in (0, 1):
            return
        script = self.currentScript
        shotKey = 'shot' + str(index+1)
        nr, bmp, txt, prevFilterIdx = script.snapShots[shotKey]
        if txt:
            if (self.currentframenum != nr) or not self.previewWindowVisible:
                self.ShowVideoFrame(nr, forceLayout=True, forceCursor=True)
            else:
                if bmp:
                    if index == 0:
                        self.snapShotIdx = 1 if self.snapShotIdx in [0,2] else 0
                    else:
                        self.snapShotIdx = 2 if self.snapShotIdx in [0,1] else 0
                    if self.zoom_antialias:
                        self.zoom_antialias = '' # disable draw 'Snapshot'
                    self.videoWindow.Refresh()
                    self.videoWindow.Update()
                    if self.zoom_antialias == '':
                        self.zoom_antialias = True
                        self.videoWindow.Refresh()
                        self.videoWindow.Update()
                    #self.ResetZoomAntialias(forceYield=False) # now draw 'Snapshot'
                else:
                    self.snapShotIdx = 0
                    if not showMsg:
                        wx.Bell()
                        return
                    dlg = wx.MessageDialog(self, _('No Bitmap available, but you can restore the script from snapshot.'+
                                                   ' New tab from snapshot?'), _('Snapshot %d') % (index+1), wx.YES_NO)
                    ID = dlg.ShowModal()
                    dlg.Destroy()
                    if ID != wx.ID_YES:
                        return
                    self.NewTabFromSnapShot(index)
        else:
            wx.Bell()

    def NewTabFromSnapShot(self, shotIdx):
        if not shotIdx in (0, 1):
            return
        shotKey = 'shot' + str(shotIdx+1)
        txt = self.currentScript.snapShots[shotKey][2] # [2] = script text
        if not txt:
            wx.MessageBox(_('Empty snapshot script'),_('Error snapshot %d') % (shotIdx+1))
            return
        self.HidePreviewWindow()
        idx = self.NewTab(copyselected=False,text=txt,insertnext=True)
        script, idx = self.getScriptAtIndex(idx)
        if script:
            if self.videoSlider.GetVirtualMax() >= self.currentframenum:
                script.lastFramenum = self.currentframenum
                self.videoSlider.SetValue(self.currentframenum)

    def RestoreSnapShotToCurrent(self, shotIdx):
        script = self.currentScript
        shot = 'shot1' if shotIdx == 0 else 'shot2'
        txt = script.snapShots[shot][2]
        idx = script.snapShots[shot][3]
        if not txt:
            wx.MessageBox(_('Empty snapshot script'),'Error snapshot')
            return
        if not script.snapShots[shot][1]: # no bitmap, also from session file
            dlg = wx.MessageDialog(self, _("Snapshot doesn't seem to be from this session.\nKeep going?"),_('Question'), wx.YES_NO|wx.ICON_INFORMATION)
            ID = dlg.ShowModal()
            dlg.Destroy()
            if ID != wx.ID_YES:
                return
        script.Freeze()
        script.ParseFunctions(txt)
        script.SetText(txt)
        self.TryThaw(script)
        script.Colourise(0, script.GetTextLength())
        self.snapShotIdx = 0
        if self.options['bookmarksfromscript']:
            self.OnMenuBookmarksFromScript(difWarn=False)
        self.UpdateUserSliders(forceUpdate=True)
        script.previewFilterIdx = idx
        if self.ScriptChanged(script):
            self.ShowVideoFrame(forceRefresh=True)
        else: # it's faster if script outside prFilter area not changed? # TODO test it
            self.OnMenuPreviewFilter(index=idx, updateUserSliders=False)

    def OnMenuClearTabSnapShot(self, event):
        self.snapShotIdx = 0
        script = self.currentScript
        for key in script.snapShots.keys():
            script.snapShots[key] = utils.emptySnapShot
        self.zoom_antialias = False
        self.videoWindow.Refresh()
        self.videoWindow.Update()
        self.ResetZoomAntialias(forceYield=False)

    def OnMenuClearAllSnapShots(self, event=None):
        self.snapShotIdx = 0
        for index in xrange(self.scriptNotebook.GetPageCount()):
            script = self.scriptNotebook.GetPage(index)
            for key in script.snapShots.keys():
                script.snapShots[key] = utils.emptySnapShot
        self.zoom_antialias = False
        self.videoWindow.Refresh()
        self.videoWindow.Update()
        self.ResetZoomAntialias(forceYield=False)

    def GetScriptSnapshotDict(self, script):
        shots = {}
        for key in script.snapShots.keys():
            shots[key] = [script.snapShots[key][0], None, script.snapShots[key][2], script.snapShots[key][3]]
        return shots

    def GetSnapShotFromSession(self, script, snapshots):
        for key in script.snapShots.keys():
            if key in snapshots.keys():
                try:
                    nr, temp, txt, prevFilterIdx = snapshots[key]
                except:
                    nr, temp, txt = snapshots[key]
                    prevFilterIdx = 0
                script.snapShots[key] = [nr, None, txt, prevFilterIdx]
            else:
                script.snapShots[key] = utils.emptySnapShot

    def SetDialogPositionNextToVideo(self, dlg):
        parent = dlg.GetParent()
        xp, yp = parent.GetPositionTuple()
        wp, hp = parent.GetSizeTuple()
        wd, hd = wx.ScreenDC().GetSizeTuple()
        ws, hs = dlg.GetSizeTuple()
        #~ dlg.SetPosition((min(xp+wp-20, wd-ws),-1))
        xSplitter = self.videoSplitter.GetSashPosition()
        wVideo = self.currentScript.AVI.DisplayWidth
        xpos = min(xp+wVideo+30, xp+xSplitter+20)
        dlg.SetPosition((min(xpos, wd-ws), yp+hp-hs-self.mainSplitter.GetMinimumPaneSize()-50))

    def OnMenuVideoTrimEditor(self, event=None):
        dlg = self.trimDialog
        if dlg.IsShown():
            return
        # Show the video preview
        if not self.ShowVideoFrame():
            return False
        self.SetDialogPositionNextToVideo(dlg)
        dlg.oldhighligthBookmarks = self.videoSlider.hilightBookmarks
        dlg.oldSliderShowNumbers = self.videoSlider.showNumbers
        for slider in self.GetVideoSliderList():
            slider.ToggleSelectionMode(1)
            slider.SetBookmarkHilighting(True)
            if self.options['timelinehidenumbers']:
                slider.showNumbers = False
            slider.SetValue(slider.GetValue())
        selections = self.currentScript.selections
        dlg.oldSelections.clear()
        if selections:
            dlg.oldSelections.update(selections)
        dlg.Show()
        self.ShowVideoFrame()

    def OnMenuVideoTrimEditorSetStartpoint(self, event):
        self.SetSelectionPoint(1)

    def OnMenuVideoTrimEditorSetEndpoint(self, event):
        self.SetSelectionPoint(2)

    def OnMenuVideoMoveSelectionsBeforeCurrentFrame(self, event):
        selections = self.GetSliderSelections(self.invertSelection)
        if selections:
            self.MoveFrameRanges(selections, paste_before=True)

    def OnMenuVideoMoveSelectionsAfterCurrentFrame(self, event):
        selections = self.GetSliderSelections(self.invertSelection)
        if selections:
            self.MoveFrameRanges(selections, paste_before=False)

    def OnSetBookmarkToTrims(self, event):
        self.options['bookmarktotrim'] = event.IsChecked()

    def OnMenuVideoZoom(self, event=None, menuItem=None, zoomfactor=None, show=True, scroll=None, resizeFilterOff=True, single=False, script=None):

        def _IsFullScreen():
            return self.mainSplitter.GetSashPosition() <=  self.mainSplitter.GetSashSize() or self.IsFullScreen()

        if show:
            resize = False
            if not self.KeyUpVideoWndow: # GPo, do not allow to fasted key events (key shortcuts fires onKeyPress ! not good for some functions)
                return
            self.KeyUpVideoWndow = False
            wx.CallLater(200, self.OnKeyUpVideoWindow, None) # reset after 200ms and unblock this function
        if zoomfactor is None:
            vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
            if menuItem is None:
                id = event.GetId()
                for vidmenu in vidmenus:
                    menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Zoom'))).GetSubMenu()
                    menuItem = menu.FindItemById(id)
                    if menuItem:
                        label = menuItem.GetLabel()
                        zoomvalue = self.zoomLabelDict[label]
                        menuItem.Check()
                    else:
                        updateMenu = menu

                id = updateMenu.FindItem(label)
                menuItem = updateMenu.FindItemById(id)
                if menuItem is None:
                    print>>sys.stderr, _('Error'), 'OnMenuVideoZoom(): cannot find menu item by id'
                    return
                menuItem.Check()

            else:
                menuItem.Check()
                label = menuItem.GetLabel()
                zoomvalue = self.zoomLabelDict[label]
                for vidmenu in vidmenus:
                    menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Zoom'))).GetSubMenu()
                    if menu != menuItem.GetMenu():
                        id = menu.FindItem(label)
                        menuItem = menu.FindItemById(id)
                        if menuItem is None:
                            print>>sys.stderr, _('Error'), 'OnMenuVideoZoom(): cannot find menu item by id'
                            return
                        menuItem.Check()

            if zoomvalue == 'fill':
                self.zoomwindow = True
                self.zoomwindowfit = False
                self.zoomwindowfill = True
                zoomfactor = 1
                if self.previewWindowVisible:
                    self.SaveLastSplitVideoPos() #GPo
            elif zoomvalue == 'fit':
                self.zoomwindow = True
                self.zoomwindowfit = True
                self.zoomwindowfill = False
                zoomfactor = 1
            else:
                try:
                    zoompercent = int(zoomvalue)
                except ValueError:
                    zoompercent = 100
                if (zoompercent >= 100) or (zoompercent in [25, 50]):    # GPo 2018
                    zoomfactor = zoompercent / 100.0
                else:
                    return
                self.zoomwindow = False
                self.zoomwindowfit = False
                self.zoomwindowfill = False
                if self.options['resizevideowindow'] and not _IsFullScreen(): # then full size
                    self.currentScript.lastSplitVideoPos = None
                    resize = True

        elif isinstance(zoomfactor, basestring): #zoomWindow:
            if zoomfactor == 'fill':
                self.zoomwindow = True
                self.zoomwindowfit = False
                self.zoomwindowfill = True
                self.UpdateMenuItem(_('&Zoom'), True, 'video', [_('Fill window')])
                if self.previewWindowVisible:
                    self.SaveLastSplitVideoPos() #GPo
            elif zoomfactor == 'fit':
                self.zoomwindow = True
                self.zoomwindowfit = True
                self.zoomwindowfill = False
                self.UpdateMenuItem(_('&Zoom'), True, 'video', [_('Fit inside window')])
            zoomfactor = 1
        else:
            self.zoomwindow = False
            self.zoomwindowfit = False
            self.zoomwindowfill = False
            if zoomfactor == 1:
                self.UpdateMenuItem(_('&Zoom'), True, 'video', [_('100% (normal)')])
            elif zoomfactor in [0.25, 0.50, 2, 3, 4]:
                self.UpdateMenuItem(_('&Zoom'), True, 'video', [_(str(zoomfactor*100)+'%')])
            if self.options['resizevideowindow'] and not _IsFullScreen(): # then full size
                self.currentScript.lastSplitVideoPos = None
                resize = True
        self.zoomfactor = zoomfactor

        if resizeFilterOff:
            # disable all scripts resizeFilter if not single or not saveViewPos
            if script is None:
                if single or self.saveViewPos > 0:
                    script = self.currentScript

            idx = self.currentScript.previewFilterIdx
            isResize = self.currentScript.resizeFilter[0]
            self.DisableResizeFilter(script)
            if idx > 0 and isResize and show:
                self.zoom_antialias = False
                self.OnMenuPreviewFilter(index=idx, updateUserSliders=False)
                self.ResetZoomAntialias()
                return
        if show:
            self.zoom_antialias = False
            self.ShowVideoFrame(scroll=scroll, forceLayout=True, resize=resize)
            self.ResetZoomAntialias()

    def OnMenuVideoZoomAntialias(self, event):
        self.options['zoom_antialias'] = not self.options['zoom_antialias']
        self.zoom_antialias = self.options['zoom_antialias']
        menus = self.FindMenuItem(2, 'Zoom', 'Antialiasing')
        if menus:
            for menu in menus:
                menu.Check(self.zoom_antialias)
        if self.zoomfactor != 1 or self.zoomwindow:
            self.videoWindow.Refresh()

    def ResetZoomAntialias(self, forceYield=True, enabledWnd=None):
        if self.options['zoom_antialias']:
            if self.zoomfactor != 1:
                if forceYield:
                    if self.separatevideowindow:
                        self.videoDialog.Update()
                    else:
                        self.Update()
                self.zoom_antialias = True
                if self.previewWindowVisible:
                    #self.videoWindow.RefreshRect(self.videoWindow.GetClientRect(), eraseBackground=False) # not faster
                    self.videoWindow.Refresh()
                    self.videoWindow.Update()
            else:
                #self.Refresh() # it's nicer on some functions... depending on wx version, shit wx
                if forceYield:
                    if self.separatevideowindow:
                        self.videoDialog.Update()
                    else:
                        self.Update()
                self.zoom_antialias = True
        else:
            self.zoom_antialias = False

    # display filter on/off (can also run a macro file or display filter macro text #>
    def OnMenuVideoDisplayFilter(self, event, enabled=False):
        if event:
            self.displayFilter = not self.displayFilter
        else:
            self.displayFilter = enabled
        #curIdx = self.currentScript.previewFilterIdx
        self.UpdateMenuItem(_('Display'), self.displayFilter, 'video', [_('Display filter')])
        for i in xrange(self.scriptNotebook.GetPageCount()):
            script = self.scriptNotebook.GetPage(i)
            #if script.AVI:
                #script.AVI.displayFilter = self.options['displayfilter'] if self.displayFilter else None
            script.display_clip_refresh_needed = True

        macroTxt = ''
        macrofilename = 'intern'
        txt = self.options['displayfilter']
        if txt and self.previewOK():
            for line in txt.split('\n'):
                line = line.lstrip()
                if line.startswith('#>'):
                    if line.startswith('#>macro>'): # run a macro from file
                        macrofilename = os.path.join(self.macrofolder, line[8:].strip())
                        if not os.path.isfile(macrofilename):
                            macrofilename = 'intern'
                            wx.Bell()
                        macroTxt = ''
                        break
                    else:
                        macroTxt += line[2:] + '\n'
            if macroTxt or macrofilename != 'intern':
                self.ExecuteMacro(macrofilename=macrofilename, macroTxt=macroTxt)

        if self.previewWindowVisible:
            self.zoom_antialias = False
            self.ShowVideoFrame()
            self.ResetZoomAntialias()

    def OnMenuSelectDisplayFilter(self, event):
        def _setDisplayFilter(event):
            obj = event.GetEventObject()
            key = obj.GetLabel(event.GetId())
            self.options['displayfilter'] = self.options['displayfilters'][key]
            self.OnMenuVideoDisplayFilter(None, self.displayFilter)
        menu = wx.Menu('Display Filters')
        for key in self.options['displayfilters']:
            id = wx.NewId()
            item = menu.Append(id, key, kind=wx.ITEM_CHECK)
            item.Check(self.options['displayfilter'] == self.options['displayfilters'][key])
            self.Bind(wx.EVT_MENU, _setDisplayFilter, id=id)
        self.PopupMenu(menu)
        menu.Destroy()

    def OnMenuConfigureDisplayFilter(self, event=None, txt=None):
        int5 = intPPI(5)
        if not txt:
            txt = self.options['displayfilter']
        dlg = wx.Dialog(self, wx.ID_ANY, _('Edit current display filter'), size=tuplePPI(450, 270), style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        SetFontPPI(dlg)
        textCtrl = wx.TextCtrl(dlg, style=wx.TE_MULTILINE|wx.TE_DONTWRAP, value=txt)
        # Standard buttons
        okay  = wx.Button(dlg, wx.ID_OK, _('OK'))
        cancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        # Size the elements
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add(textCtrl, 1, wx.EXPAND|wx.ALL, int5)
        #dlgSizer.Add(label, 0, wx.LEFT, 5)
        dlgSizer.Add(btns, 0, wx.EXPAND|wx.ALL, int5)
        dlg.SetSizer(dlgSizer)
        ID = dlg.ShowModal()
        dlg.Destroy()
        if ID == wx.ID_OK:
            self.options['displayfilter'] = textCtrl.GetValue().strip()
            self.OnMenuVideoDisplayFilter(None, self.displayFilter)

    # copy from script
    def OnMenuCopyAsDisplayFilter(self, event):
        txt = self.currentScript.GetSelectedText()
        macroTxt = ''
        if len(txt) > 5:
            for line in self.options['displayfilter'].split('\n'):
                line = line.lstrip()
                if line.startswith('#>'):
                    macroTxt += line + '\n'
            if macroTxt:
                txt = macroTxt + '\n' + txt
            self.OnMenuConfigureDisplayFilter(txt=txt)
        else:
            wx.Bell()

    # GPo, changed
    def OnMenuVideoFlip(self, event):
        if self.AviThread_Running(self.currentScript):
            if event:
                event.Veto()
            return
        menuitem = None
        id = event.GetId()
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Display'))).GetSubMenu()
            menu = menu.FindItemById(menu.FindItem(_('&Flip'))).GetSubMenu()
            menuItem = menu.FindItemById(id)
            if menuItem:
                label = menuItem.GetLabel()
                value = self.flipLabelDict[label]
                menuItem.Check(value not in self.flip)
            else:
                updateMenu = menu
        id = updateMenu.FindItem(label)
        menuItem = updateMenu.FindItemById(id)
        if menuItem is None:
            print>>sys.stderr, _('Error'), 'OnMenuVideoFlip(): cannot find menu item by id'
            return
        menuItem.Check(value not in self.flip)

        if value in self.flip:
            self.flip.remove(value)
        else:
            self.flip.append(value)
        self.bmpVideo = None
        self.videoWindow.Refresh()

    def OnMenuVideoYUV2RGB(self, event):
        script = self.currentScript
        if self.AviThread_Running(script):
            if event:
                event.Veto()
            return
        id = event.GetId()
        value = ''
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Display'))).GetSubMenu()
            menu = menu.FindItemById(menu.FindItem(_('&YUV -> RGB'))).GetSubMenu()
            menuItem = menu.FindItemById(id)
            if menuItem:
                label = menuItem.GetLabel()
                value = self.yuv2rgbDict[label]
                if menuItem.GetKind() == wx.ITEM_RADIO:
                    menuItem.Check()
                else:
                    menuItem.Check(not getattr(self, value))
            else:
                updateMenu = menu

        id = updateMenu.FindItem(label)
        menuItem = updateMenu.FindItemById(id)
        if not menuItem:
            print>>sys.stderr, _('Error'), 'OnMenuVideoYUV2RGB(): cannot find menu item by id'
            return
        if menuItem.GetKind() == wx.ITEM_RADIO:
            menuItem.Check()
        else:
            menuItem.Check(not getattr(self, value))

        refresh = False

        AVI = script.AVI
        if value == 'swapuv':
            self.swapuv = not self.swapuv
            if AVI:
                refresh = AVI.IsYUV and not AVI.IsY8
        elif value in ['Progressive', 'Interlaced']:
            self.interlaced = not self.interlaced
            if AVI:
                refresh = AVI.IsYV12
        else:
            if value in ('tv', 'pc'):
                script.matrix[1] = value
            elif value != '':
                script.matrix[0] = value
            if AVI:
                refresh = AVI.IsYUV
            # save the user selected matrix for reset ( real.finder for you )
            self.options['selectedmatrix'] = script.matrix[:]

        if refresh:
            script.display_clip_refresh_needed = True
            if self.previewWindowVisible and self.previewOK():
                self.ShowVideoFrame(forceRefresh=False, focus=self.options['focusonrefresh'])

    def OnMenuReadMatrix(self, event):
        script = self.currentScript
        self.options['readmatrix'] = not self.options['readmatrix']
        self.UpdateMenuItem(_('Display'), self.options['readmatrix'], 'video', [_('YUV -> RGB'), _('Read from source or script')])

    def OnMenuResetMatrix(self, event):
        script = self.currentScript
        self.options['resetmatrix'] = not self.options['resetmatrix']
        self.UpdateMenuItem(_('Display'), self.options['resetmatrix'], 'video',  [_('YUV -> RGB'), _('Reset matrix if not found')])

    def OnMenuResetDisplayProps(self, event):
        matrix = self.options['defaultmatrix'].split(',')
        def _update_MatrixMenu():
            if matrix[0] == 'auto':
                s1 = _('Resolution-based')
            else: s1 = _('BT.' + matrix[0])
            s2 = _(matrix[1].upper() + ' levels')
            self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), s1])
            self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), s2])
        for index in xrange(self.scriptNotebook.GetPageCount()):
            script = self.scriptNotebook.GetPage(index)
            if self.AviThread_Running(script):
                continue
            script.display_clip_refresh_needed = True
            script.matrix = matrix[:]

        self.swapuv = False
        self.interlaced = False
        self.options['readmatrix'] = True
        self.options['resetmatrix'] = False
        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), _('Read from source or script')])
        self.UpdateMenuItem(_('Display'), False, 'video', [_('YUV -> RGB'), _('Reset matrix if not found')])
        _update_MatrixMenu()
        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), _('Progressive')])
        self.UpdateMenuItem(_('Display'), False, 'video', [_('YUV -> RGB'), _('Swap UV')])
        if self.previewWindowVisible and self.previewOK():
            self.ShowVideoFrame(forceRefresh=False, focus=self.options['focusonrefresh'])

    def MatrixFromScript(self, script):
        pos = script.FindText(0, script.GetTextLength(), '#avsp_matrix:', stc.STC_FIND_WHOLEWORD)
        if pos > -1:
            s = script.GetTextRange(pos+13, pos+19).lower().strip()
            if s in ('tv601','tv709', 'pc601', 'pc709'):
                return [s[2:5], s[:2]]
        return None

    def OnMenuMatrixToScript(self, event):
        script = self.currentScript
        if script.matrix[0] == 'auto':
            if self.previewOK():
                s = '709' if (script.AVI.DisplayWidth > 1024 or script.AVI.DisplayHeight > 576) else '601'
            else: s = '709'
        else:
            s = script.matrix[0]
        pos = script.FindText(0, script.GetTextLength(), '#avsp_matrix:', stc.STC_FIND_WHOLEWORD)
        if pos > -1:
            sm = script.GetTextRange(pos+13, pos+19).strip()
            if sm.lower() in ('tv601','tv709', 'pc601', 'pc709'):
                script.SetTargetStart(pos+13)
                script.SetTargetEnd(pos+19)
                script.ReplaceTarget(' ' + script.matrix[1] + s)
            else:
                self.InsertText(' ' + script.matrix[1] + s, pos=pos+13)
        else:
            pos = script.FindText(0, script.GetTextLength(), '#Bookmarks:', stc.STC_FIND_WHOLEWORD)
            if pos > -1:
                pos = script.GetLineEndPosition(script.LineFromPosition(pos))
                self.InsertText('\n#avsp_matrix: ' + script.matrix[1] + s, pos=pos)
            else:
                pos = 0 #~None if script.GetLine(script.CurrentLine).strip() == '' else 0
                self.InsertText('#avsp_matrix: ' + script.matrix[1] + s + '\n', pos=pos)

    def OnMenuReadMatrixNow(self, event):
        def _getMatrix(script, q):
            matrix = script.AVI.GetMatrix()
            q.put(matrix)

        script = self.currentScript
        if not self.previewOK():
            wx.MessageBox(_('Cannot read the matrix. Clip not initialized'), style=wx.ICON_ERROR|wx.OK)
            return
        src_matrix = self.MatrixFromScript(script) # force the script matrix
        ss = 'from script'
        if not src_matrix: # then get from AVI
            if self.UseAviThread:
                src_matrix = None
                q = queue.Queue()
                th = threading.Thread(target=_getMatrix, args=(script, q,))
                th.daemon = True
                th.name = 'frame'
                script.AviThread = th
                th.start()
                th.join(self.progressDelayTime)
                if th.isAlive():
                    self.TH_WaitForFrame(script, th, self.currentframenum)
                else: script.AviThread = None
                try:
                    src_matrix = q.get(True, 0.1)
                except:
                    pass
            else:
                src_matrix = script.AVI.GetMatrix()
            ss = 'from source'

        if not src_matrix:
            s = 'Matrix not found'
            script.matrix = ['auto', 'tv']
            matrix = [_('Resolution-based'), _('TV levels')]
        else:
            script.matrix = src_matrix[:]
            matrix = [_('BT.' + src_matrix[0]),_(src_matrix[1].upper() + ' levels')]
            s = 'Matrix read {0}: {1}, {2}'.format(ss, matrix[0], matrix[1])

        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), matrix[0]])
        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), matrix[1]])
        script.display_clip_refresh_needed = True
        if self.ShowVideoFrame():
            self.StatusbarTimer_Start(4000, s)

    def OnMenuVideoBitDepth(self, event):
        if self.cropDialog.IsShown():
            wx.MessageBox(_('Cannot change bit depth while crop editor is open!'),
                          _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        id = event.GetId()
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Display'))).GetSubMenu()
            menu = menu.FindItemById(menu.FindItem(_('Bit &depth'))).GetSubMenu()
            menuItem = menu.FindItemById(id)
            if menuItem:
                menuItem.Check()
                label = menuItem.GetLabel()
                if label == _('Stacked yuv420p10 or yuv444p10'):
                    self.bit_depth = 's10'
                elif label == _('Stacked yuv420p16 or yuv444p16'):
                    self.bit_depth = 's16'
                elif label == _('Interleaved yuv420p10 or yuv444p10'):
                    self.bit_depth = 'i10'
                elif label == _('Interleaved yuv420p16 or yuv444p16'):
                    self.bit_depth = 'i16'
                elif label == _('Interleaved RGB48'): # not used!
                    self.bit_depth = 'rgb48'
                else:
                    self.bit_depth = None
                for index in xrange(self.scriptNotebook.GetPageCount()):
                    script = self.scriptNotebook.GetPage(index)
                    script.display_clip_refresh_needed = True
                if self.previewWindowVisible and self.previewOK():
                    self.ShowVideoFrame(forceRefresh=False, focus=self.options['focusonrefresh'])
            else:
                updateMenu = menu
        id = updateMenu.FindItem(label)
        menuItem = updateMenu.FindItemById(id)
        if not menuItem:
            print>>sys.stderr, _('Error'), 'OnMenuVideoBitDepth(): cannot find menu item by id'
            return
        menuItem.Check()

    def OnMenuVideoBackgroundColor(self, event=None, color=None, label=None):
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        if event is not None:
            id = event.GetId()
            label = None
        elif color is not None:
            label = self.backgroundColorDict.get(color, _('Custom'))
        elif label is None:
            print>>sys.stderr, _('Error'), 'OnMenuVideoBackgroundColor(): a color or menuItem label is needed'
        updateMenu = None
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('Background &color'))).GetSubMenu()
            if label:
                id = menu.FindItem(label)
            menuItem = menu.FindItemById(id)
            if menuItem:
                menuItem.Check()
                label = menuItem.GetLabel()
                if label == _('Default'):
                    self.options['use_customvideobackground'] = False
                else:
                    self.options['use_customvideobackground'] = True
                    self.options['videobackground'] = self.backgroundLabelDict.get(
                        label, self.options['customvideobackground'])
                self.OnEraseBackground()
            else:
                updateMenu = menu
        if updateMenu is None:
            return
        id = updateMenu.FindItem(label)
        menuItem = updateMenu.FindItemById(id)
        if not menuItem:
            print>>sys.stderr, _('Error'), 'OnMenuVideoBackgroundColor(): cannot find menu item by id'
            return
        menuItem.Check()

    def x_SetCustomColor(self, options_str=''): # GPo
        if options_str == '':
            return
        self.colour_data.SetColour(self.options[options_str])
        dialog = wx.ColourDialog(self, self.colour_data)
        if dialog.ShowModal() == wx.ID_OK:
            data = dialog.GetColourData()
            self.options[options_str] = data.GetColour()
            if options_str == 'customvideobackground':
                self.OnMenuVideoBackgroundColor(label=_('Custom'))
                for i in range(self.colour_data.NUM_CUSTOM):
                    self.colour_data.SetCustomColour(i, data.GetCustomColour(i))
                self.options['colourdata'] = self.colour_data.ToString()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
            for slider in self.GetVideoSliderList():
                if options_str == 'bookmarkshilightcolor':
                    slider.bookmarksHilightColor = wx.Brush(data.GetColour())
                    slider.SetBookmarkHilighting(slider.hilightBookmarks)
                    slider.Refresh()
                elif options_str == 'selectionshilightcolor':
                    slider.selectionsHilightColor = wx.Brush(data.GetColour())
                    slider.SetBookmarkHilighting(slider.hilightBookmarks)
                    slider.Refresh()
                elif options_str == 'timelinesplitclipcolor':
                    slider.brushSplitClip = wx.Brush(data.GetColour())
                    if slider.AVI_SplitClip:
                        slider.Refresh()
        dialog.Destroy()

    """
    def UpdateVideoMenuItem(self, menu, submenu1, submenu2, checked):
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            id = vidmenu.FindItem(menu)
            if id != wx.NOT_FOUND:
                if submenu1:
                    sm = vidmenu.FindItemById(id).GetSubMenu()
                    if sm:
                        id = sm.FindItem(submenu1)
                        if id != wx.NOT_FOUND:
                            if submenu2:
                                sm =  sm.FindItemById(id).GetSubMenu()
                                if sm:
                                    id = sm.FindItem(submenu2)
                                    if id == wx.NOT_FOUND:
                                        return
                            sm.Check(id, checked)
                else:
                    vidmenu.Check(id, checked)
    """
    def UpdateMenuItem(self, menu, checked, contextType='video', submenus=[]):
        if contextType == 'video':
            menus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        elif contextType == 'edit':
            menus = [self.currentScript.contextMenu, self.GetMenuBar().GetMenu(1)]
        else:
            idx = self.GetMenuBar().FindMenu(contextType)
            if idx == wx.NOT_FOUND:
                return
            menus = [self.GetMenuBar().GetMenu(idx)]

        for _menu in menus:
            id = _menu.FindItem(menu)
            if id != wx.NOT_FOUND:
                if submenus:
                    s_menu = _menu
                    for submenu in submenus:
                        sm = s_menu.FindItemById(id).GetSubMenu()
                        if sm:
                            id = sm.FindItem(submenu)
                            if id == wx.NOT_FOUND:
                                return
                            s_menu = sm
                        else:
                            return
                    sm.Check(id, checked)
                else:
                    _menu.Check(id, checked)

    def UpdateVideoSubMenuByPosition(self, menu, pos, checked):
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            id = vidmenu.FindItem(menu)
            if id != wx.NOT_FOUND:
                if pos > -1:
                    sm = vidmenu.FindItemById(id).GetSubMenu()
                    if sm:
                        menuitem = sm.FindItemByPosition(pos)
                        if menuitem:
                            menuitem.Check(checked)
                else:
                    vidmenu.Check(id, checked)

    def OnMenuVideoSetCustomBackgroundColor(self, event):
        self.x_SetCustomColor('customvideobackground')  # GPo

    def OnMenuVideoSetBookmarkHiligthColor(self, event):
        self.x_SetCustomColor('bookmarkshilightcolor')  # GPo

    def OnMenuVideoSetSelectionHiligthColor(self, event):
        self.x_SetCustomColor('selectionshilightcolor')  # GPo 2020

    def OnMenuVideoSetSplitClipHiligthColor(self, event):
        self.x_SetCustomColor('timelinesplitclipcolor')

    def OnMenuVideoRefresh(self, event):
        self.ShowVideoFrame(forceRefresh=True, forceLayout=True, forceCursor=True, disableFastClip=True,
            focus=self.options['focusonrefresh'], frameToFrametime=self.options['frametoframetime'])

    def OnMenuVideoHide(self, event):
        self.HidePreviewWindow()

    def AviThread_Running(self, script, prompt=True, checkFrameThread=True):
        if script.AviThread and script.AviThread.isAlive():
            script.AviThread.join(1)
            if script.AviThread and script.AviThread.isAlive():
                if prompt:
                    base,name = os.path.split(script.filename)
                    if not name:
                        name = base
                    wx.MessageBox(_(u'Avisynth not returned thread still running.\n{0}').format(name))
                return True
        if checkFrameThread:
            return self.FrameThread_Running(script, prompt)
        return False

    # for frame thread handle with events
    def FrameThread_Running(self, script, prompt=True):
        if script.FrameThread and script.FrameThread.IsRunning():
            if prompt:
                base,name = os.path.split(script.filename)
                if not name:
                    name = base
                wx.MessageBox(_(u'Avisynth not returned frame thread still running.\n{0}').format(name))
            return True
        return False

    def PlayThread_Running(self, script, prompt=True):
        if script.PlayThread and script.PlayThread.isAlive():
            if prompt:
                base,name = os.path.split(script.filename)
                if not name:
                    name = base
                wx.MessageBox(_(u'Avisynth not returned play thread still running.\n{0}').format(name))
            return True
        return False

    def OnMenuVideoReleaseMemory(self, event):
        self.HidePreviewWindow()
        if self.SplitClipCtrl.IsActive:
            self.SplitClipCtrl.Close()
        for index in xrange(self.scriptNotebook.GetPageCount()):
            script = self.scriptNotebook.GetPage(index)
            for key in script.snapShots.keys():
                script.snapShots[key][1] = None # Releas only the bitmap ?
            if self.AviThread_Running(script):
                continue
            self.AviFree(script)
            script.previewFilterIdx = 0
            script.lastpreviewFilterIdx = 0
        self.SetPreviewFilterMenus()
        self.UpdateScriptTabname(allTabs=True) # GPo
        if self.readFrameProps:
            self.AVICallBack('property','')

    def OnMenuScriptReleaseMemory(self, event=None, show=True): # GPo
        self.splitView = False
        self.snapShotIdx = 0
        script = self.currentScript
        if self.AviThread_Running(script):
            return
        shown = self.previewWindowVisible and show
        self.HidePreviewWindow()
        if self.SplitClipCtrl.IsActive:
            self.SplitClipCtrl.Close()
        if self.readFrameProps:
            self.AVICallBack('property','')
        for key in script.snapShots.keys():
            script.snapShots[key][1] = None # Releas only the bitmap ?
        script.lastpreviewFilterIdx = 0
        self.SetPreviewFilterMenus()
        if not self.AviFree(script, updateTabname=True):
            return
        try:
            self.SetVideoStatusText()
            if shown:
                # now pick the first script that is initialized
                for index in xrange(self.scriptNotebook.GetPageCount()):
                    script = self.scriptNotebook.GetPage(index)
                    if self.previewOK(script):
                        self.SelectTab(index)
                        self.ShowVideoFrame(script=script)
                        break
        finally:
            pass
        if event is None:
            return True

    def OnMenuOtherScriptReleaseMemory(self, event): # GPo
        self.splitView = False
        idx = self.scriptNotebook.GetSelection()
        for index in xrange(self.scriptNotebook.GetPageCount()):
            if idx != index:
                script = self.scriptNotebook.GetPage(index)
                for key in script.snapShots.keys():
                    script.snapShots[key][1] = None
                if self.AviThread_Running(script):
                    continue
                script.previewFilterIdx = 0
                script.lastpreviewFilterIdx = 0
                script.chkPreviewFilter.SetValue(False)
                self.AviFree(script, updateTabname=True)

    def OnMenuVideoToggle(self, event):
        if self.previewWindowVisible:
            self.HidePreviewWindow()
            self.SetStatusWidths([-1, 0])
        else:
            self.ShowVideoFrame_CheckPreview(resize=True)

    def OnMenuFrameToFrameTime(self, event):
        self.options['frametoframetime'] = event.IsChecked()
        self.UpdateMenuItem(_('Additional'), event.IsChecked(), 'video', [_('Use previous frame time')])

    def OnMenuUseSplitClip(self, event):
        self.options['usesplitclip'] = event.IsChecked()
        self.UpdateMenuItem(_('Additional'), event.IsChecked(), 'video', [_('Restore split clip if enabled')])

    def OnMenuSplitViewFreeze(self, event):
        self.splitView_freeze = not self.splitView_freeze
        if self.splitView:
            try:
                self.splitView_nextScript.lastFramenum = self.splitView_nextScript.AVI.current_frame
            except:
                pass
            if self.previewWindowVisible:
                self.videoWindow.Refresh()
            self.SetVideoStatusText()

    """# It works with shortcut, but... macro CopyPixelInfo also works
    def OnCopyColorValue(self, event, color='hex'):
        colors = ('xy', 'hex', 'rgb', 'rgba', 'yuv', 'yuva')
        try:
            idx = colors.index(color)
        except ValueError:
            return
        info = self.GetPixelInfo(None)
        s = info[idx] if info[idx] is not None else 'None'
        self.SetClipboardText(s)
        self.MacroWriteToScrap(s+'\n')
        wx.Bell()
    """

    def OnMenuVideoSwitchMode(self, event):
        if self.previewWindowVisible:
            if self.FindFocus() == self.videoWindow:
                self.currentScript.SetFocus()
                self.currentScript.EnsureCaretVisible()
            else:
                self.ShowVideoFrame()
        else:
            self.zoom_antialias = False
            self.ShowVideoFrame()
            self.ResetZoomAntialias()

    def OnMenuVideoTogglePlacement(self, event):
        self.TogglePreviewPlacement()

    def OnMenuVideoToggleSliderWindow(self, event):
        self.ToggleSliderWindow(vidrefresh=True)

    def OnMenuVideoRunAnalysisPass(self, event):
        self.StopPlayback()
        if self.readFrameProps:
            self.propWindow.Close()
        script = self.currentScript
        if script.AVI:
            if not self.OnMenuScriptReleaseMemory(event=None, show=False):
                wx.MessageBox('Cannot close the current script', 'Analysis pass error')
                return
            self.SaveCallYield()
        filename = workdir = script.filename
        if not filename:
            workdir = tempfile.gettempdir()

        progress = wx.ProgressDialog(message=_('Starting analysis pass...'), title=_('Run analysis pass'),
                                     style=wx.PD_CAN_ABORT|wx.PD_ELAPSED_TIME|wx.PD_REMAINING_TIME|wx.PD_APP_MODAL)
        AVI = pyavs.AvsSimpleClipBase(script.GetText(), filename=filename, workdir=workdir)
        if AVI is None:
            progress.Destroy()
            wx.MessageBox('Cannot create AvsSimpleClipBase', 'Analysis pass error')
            return
        if AVI.error_message is not None:
            progress.Destroy()
            AVI = None
            wx.MessageBox(AVI.error_message, 'Analysis pass error')
            return

        frame_count = AVI.Framecount
        previous_frame = -1
        initial_time = previous_time = time.time()
        for frame in range(frame_count):
            AVI.clip.get_frame(frame)
            error = AVI.clip.get_error()
            if error:
                progress.Destroy()
                AVI = None
                wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=frame),
                              error)), _('Error'), style=wx.OK|wx.ICON_ERROR)
                return
            now = time.time()
            delta = now - previous_time
            elapsed_time = now - initial_time
            if delta >= 0.1: # then elapsed_time > 0, so no check is needed (if elapsed_time else 'INF')
                fps = (frame - previous_frame) / delta
                previous_time = now
                previous_frame = frame
                if not progress.Update(frame * 100/ frame_count, _('Average %#.4g fps\nFrame %s/%s (%#.4g fps)') %   # GPo 2020
                                      ((frame+1)/ elapsed_time, frame, frame_count, fps))[0]:
                    progress.Destroy()
                    AVI = None
                    return
        elapsed_time = time.time() - initial_time
        AVI = None
        progress.Update(100, _('Finished (%s fps average)\n*** live and let live ***') % (
                        '%#.4g' % (frame_count / elapsed_time) if elapsed_time else 'INF'))
        progress.Destroy()
        return True

    def OnMenuVideoRunFPSAnalysis(self, event):
        self.StopPlayback()
        script = self.currentScript
        if self.AviThread_Running(script):
            return
        if self.readFrameProps:
            self.propWindow.Close()

        self.refreshAVI = True
        if self.UpdateScriptAVI() is None:
            wx.MessageBox(_('Error loading the script'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        if script.AVI.IsErrorClip():
            wx.MessageBox(script.AVI.error_message, _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        progress = wx.ProgressDialog(message=_('Starting FPS analysis...'), title=_('Run FPS analysis'),
                                     style=wx.PD_CAN_ABORT|wx.PD_ELAPSED_TIME|wx.PD_REMAINING_TIME|wx.PD_APP_MODAL)
        frame_count = script.AVI.Framecount
        previous_frame = -1
        frame_read = 0  # GPo 2020
        initial_time = previous_time = time.time()
        for frame in range(frame_count):
            script.AVI.clip.get_frame(frame)
            error = script.AVI.clip.get_error()
            if error:
                progress.Destroy()
                wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=frame),
                              error)), _('Error'), style=wx.OK|wx.ICON_ERROR)
                return False
            now = time.time()
            delta = now - previous_time
            elapsed_time = now - initial_time # GPo 2020
            frame_read += 1
            if delta >= 0.1: # then elapsed_time > 0, so no check is needed (if elapsed_time else 'INF')
                fps = (frame - previous_frame) / delta
                previous_time = now
                previous_frame = frame
                if not progress.Update(frame * 100/ frame_count, _('Average %#.4g fps\nFrame %s/%s (%#.4g fps)') %   # GPo 2020
                                      (frame_read/ elapsed_time, frame, frame_count, fps))[0]:
                    progress.Destroy()
                    return False
        elapsed_time = time.time() - initial_time
        progress.Update(100, _('Finished (%s fps average)\n*** live and let live ***') % (
                        '%#.4g' % (frame_count / elapsed_time) if elapsed_time else 'INF'))
        progress.Destroy()
        return True

    def OnMenuVideoPlay(self, event):
        self.PlayPauseVideo()
        self.videoWindow.SetFocus()  # GPo 2018, enable wheel scrolling

    def OnMenuVideoPlayDecrement(self, event):
        if self.play_speed_factor == 'max':
            self.play_speed_factor = 0.5
        else:
            self.play_speed_factor /= 2
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
            self.PlayPauseVideo()

    def OnMenuVideoPlayIncrement(self, event):
        if self.play_speed_factor == 'max':
            self.play_speed_factor = 2
        else:
            self.play_speed_factor *= 2
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
            self.PlayPauseVideo()

    def OnMenuVideoPlayNormal(self, event):
        self.play_speed_factor = 1.0
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
            self.PlayPauseVideo()

    def OnMenuVideoPlayMax(self, event):
        self.play_speed_factor = 'max'
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
            self.PlayPauseVideo()

    def OnMenuVideoPlayLoop(self, event):
        self.options['playloop'] = event.IsChecked()
        self.UpdateMenuItem(_('Play video'), event.IsChecked(), 'video', [_('Play loop')])

        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
            self.PlayPauseVideo()

    def OnMenuVideoSeparateThread(self, event):
        self.CheckPlayback()
        self.options['playbackthread'] = event.IsChecked()
        self.UpdateMenuItem(_('Play video'), event.IsChecked(), 'video', [_('Use separate thread')])
        self.CheckPlayback()

    def OnMenuVideoSaveViewPos(self, event):
        if self.saveViewPos == 1:
            self.saveViewPos = 0
        else: self.saveViewPos = 1

    def OnMenuVideoSaveZoom(self, event):
        if self.saveViewPos == 2:
            self.saveViewPos = 0
        else: self.saveViewPos = 2

    def OnMenuVideoResizeOnZoom(self, event):
        self.options['resizevideowindow'] = event.IsChecked()
        self.UpdateMenuItem(_('Additional'), event.IsChecked(), 'video', [_('Resize video window')])

    def OnMenuAutoHidePreview(self, event):
        self.options['tabautopreview'] = event.IsChecked()

    def OnMenuVideoExternalPlayer(self, event):
        self.RunExternalPlayer()

    def OnMenuExternalToolArg1(self, event):
        arg = self.options['externaltoolarg1']
        if arg:
            pos = arg.find('|')
            if pos > 1:
                arg = arg[pos+1:].strip()
        self.RunExternalTool(arg)

    def OnMenuExternalToolArg2(self, event):
        arg = self.options['externaltoolarg2']
        if arg:
            pos = arg.find('|')
            if pos > 1:
                arg = arg[pos+1:].strip()
        self.RunExternalTool(arg)

    def OnMenuVideoInfo(self, event=None):
        def countSelections(typ):
            selections = None
            fr = se = 0
            if typ == 'timeline':
                selections = self.videoSlider.GetSelections()
            if selections:
                se = len(selections)
                for start, stop in selections:
                    fr += stop - start
            return fr, se

        script = self.currentScript
        if script.AVI is None:
            wx.Bell()
            return
        dlg = wx.Dialog(self, wx.ID_ANY, _('Video information'))
        SetFontPPI(dlg)
        vi = self.GetVideoInfoDict(clean=True)
        t_selFrames, t_selCount = countSelections('timeline')

        labels = (
            (_('Video'),
                (
                (_('Frame size:'), '%ix%i (%s)' % (vi['width'], vi['height'], vi['aspectratio'])),
                (_('Length:'), '%i %s (%s)' % (vi['framecount'], _('frames'), vi['totaltime'])),
                (_('Frame rate:'), '%.03f %s (%i/%i)' % (vi['framerate'], _('fps'), vi['frameratenum'], vi['framerateden'])),
                (_('Colorspace:'), vi['colorspace']),
                (_('Bit depth:'), '%i' % (vi['bitdepth'])),
                (_('Field or frame based:'), vi['fieldframebased']),
                (_('Parity:'), vi['parity']),
                ),
            ),
            (_('Audio'),
                (
                (_('Channels:'), '%i' % (vi['audiochannels'])),
                (_('Sampling rate:'), '%i %s' % (vi['audiorate'], _('Hz'))),
                (_('Sample type:'), '%s %i %s' % (vi['audiotype'], vi['audiobits'], _('bits'))),
                (_('Length:'), '%i %s' % (vi['audiolength'], _('samples'))),
                ),
            ),
            (_('Misc'),
                (
                (_('Bookmarks:'), '%i timeline, %i backup, %i saved' % (len(self.GetBookmarkFrameList()), len(script.bookmarks), self.OnMenuBookmarksFromScript(getOnlyCount=True))),
                (_('Timeline selections:'), '%i frames (%.02f %%) in %i selections' % (t_selFrames, float(t_selFrames/(vi['framecount']/100.00)), t_selCount)),
                ),
            )
        )
        # Main items
        sizer = wx.FlexGridSizer(cols=2, hgap=intPPI(10), vgap=intPPI(3))
        for sectionLabel, items in labels:
            staticText = wx.StaticText(dlg, wx.ID_ANY, sectionLabel)
            font = staticText.GetFont()
            font.SetWeight(wx.FONTWEIGHT_BOLD)
            font.SetUnderlined(True)
            staticText.SetFont(font)
            sizer.Add(staticText, 0, wx.TOP, intPPI(5))
            sizer.Add((0,0), 0, 0)
            for label, value in items:
                sizer.Add(wx.StaticText(dlg, wx.ID_ANY, '  ' + label), 0, 0)
                sizer.Add(wx.StaticText(dlg, wx.ID_ANY, value), 0, 0)
        # Standard buttons
        okay  = wx.Button(dlg, wx.ID_OK, _('OK'))
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.Realize()
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add(sizer, 1, wx.EXPAND|wx.ALL, intPPI(5))
        dlgSizer.Add(btns, 0, wx.EXPAND|wx.ALL, intPPI(10))
        dlg.SetSizer(dlgSizer)
        dlg.Fit()
        ID = dlg.ShowModal()
        dlg.Destroy()

    def OnMenuMacroRunSelected(self, event):
        id = event.GetId()
        macrofilename = self.macrosImportNames[id]
        menuItem = self.GetMenuBar().GetMenu(self.macroMenuPos).FindItemById(id)
        if menuItem.IsCheckable():
            menu = menuItem.GetMenu()
            self.RenameMacro(menu)
        else:
            self.macrosStack.append(id)
            self.ExecuteMacro(macrofilename)
            self.macrosStack.pop()

    def OnMenuMacrosFolder(self, event):
        if os.path.isdir(self.macrofolder):
            startfile(self.macrofolder)
        else:
            wx.MessageBox(_('Could not find the macros folder!'), _('Error'), style=wx.OK|wx.ICON_ERROR)

    def OnMenuMacrosReadme(self, event):
        readme = os.path.join(self.macrofolder, 'macros_readme.txt')
        if not os.path.isfile(readme):
            GenerateMacroReadme(readme)
        startfile(readme)

    def OnMenuToolsRunSelected(self, event):
        try:
            name = self.toolsImportNames[event.GetId()]
            obj = __import__(name)
        except (ImportError, KeyError):
            wx.MessageBox(_('Failed to import the selected tool'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return
        avsp = self.ExecuteMacro(return_env=True)
        #~ avsp.GetWindow = lambda: self
        obj.__dict__['_'] = _
        obj.__dict__['avsp'] = avsp
        obj.__dict__['avsp'].Version = dict(
            AvsP=self.version,
            AviSynth_string=self.avisynthVersion[0],
            AviSynth_number=self.avisynthVersion[1],
            AviSynth_interface=self.avisynthVersion[2])
        obj.__dict__['last'] = self.macroVars['last']
        obj.__dict__['avsp'].Last = self.macroVars['last']
        self.macroVars['last'] = obj.avsp_run()

    def OnMenuOptionsAlwaysOnTop(self, event):
        id = event.GetId()
        if id != wx.NOT_FOUND:
            menuItem = self.GetMenuBar().FindItemById(id)
            if not self.options['alwaysontop']:
                self.options['alwaysontop'] = True
                menuItem.Check(True)
            else:
                self.options['alwaysontop'] = False
                menuItem.Check(False)
        self.ToggleWindowStyle(wx.STAY_ON_TOP)

    def OnMenuOptionsPreviewAlwaysOnTop(self, event):
        id = event.GetId()
        menuItem = self.GetMenuBar().FindItemById(id)
        if not self.options['previewalwaysontop']:
            self.options['previewalwaysontop'] = True
            menuItem.Check(True)
        else:
            self.options['previewalwaysontop'] = False
            menuItem.Check(False)
        if self.separatevideowindow:
            self.videoDialog.ToggleWindowStyle(wx.STAY_ON_TOP)

    def OnMenuOptionsFilters(self, event):
        self.ShowFunctionDefinitionDialog()

    def OnMenuOptionsFontsAndColorsWriteBackup(self, event):
        """
        # Save color and textstyle in extra file, you can move it to another AvsPmod folder
        # and change in the other AvsPmod only the color and textstyle options.
        # No other option is changed (snippets, extension list etc.)
        """
        fileName = os.path.join(self.programdir, 'backup_style.dat')
        exOptions = {}
        exOptions['version'] = self.version
        exOptions['textstyles'] = self.options['textstyles']
        exOptions['colourdata'] = self.options['colourdata']
        with open(fileName, mode='wb') as f:
            cPickle.dump(exOptions, f, protocol=0)

    def OnMenuOptionsFontsAndColorsReadBackup(self, event):
        self.OnMenuOptionsFontsAndColors(None, True)

    def OnMenuOptionsFontsAndColors(self, event, readExOptions=False):
        dlgInfo = (
            (_('Basic (1)'),
                (
                    ((_('Use monospaced font:'), 'usemonospacedfont', _('Override all fonts to use a specified monospace font (no effect on scrap window)')), 'monospaced'),
                    (_('Default:'), 'default'),
                    (_('Comment:'), 'comment'),
                    (_('Comment special extension #>:'), 'comment2'),
                    (_('Block Comment:'), 'blockcomment'),
                    (_('__END__ Comment:'), 'endcomment'),
                    (_('Number:'), 'number'),
                    (_('String:'), 'string'),
                    (_('Triple-quoted string:'), 'stringtriple'),
                    (_('Assignment:'), 'assignment'),
                    (_('Operator:'), 'operator'),
                ),
            ),
            (_('Basic (2)'),
                (
                    (_('Internal filter:'), 'internalfilter'),
                    (_('External filter:'), 'externalfilter'),
                    (_('Internal function:'), 'internalfunction'),
                    (_('User defined function:'), 'userdefined'),
                    (_('Unknown function:'), 'unknownfunction'),
                    (_('Clip property:'), 'clipproperty'),
                    (_('Parameter:'), 'parameter'),
                    (_('AviSynth data type:'), 'datatype'),
                    (_('AviSynth keyword:'), 'keyword'),
                    (_('AvsP user slider:'), 'userslider'),
                ),
            ),
            (_('Advanced'),
                (
                    ((_('Incomplete string:'), 'usestringeol', _('Syntax highlight strings which are not completed in a single line differently')), 'stringeol'),
                    (_('Brace highlight:'), 'bracelight'),
                    (_('Bad brace:'), 'badbrace'),
                    (_('Bad number:'), 'badnumber'),
                    (_('Margin line numbers:'), 'linenumber'),
                    (_('Miscellaneous word:'), 'miscword'),
                    (_('Calltip:'), 'calltip'),
                    (_('Calltip highlight:'), 'calltiphighlight'),
                    (_('Cursor:'), 'cursor'),
                    ((_('Selection highlight:'), 'highlight_fore', _('If checked, highlight also foreground')), 'highlight'),
                    ((_('Current line highlight:'), 'highlightline', _('Highlight the line that the caret is currently in')), 'highlightline'),
                    (_('Fold margin:'), 'foldmargin'),
                ),
            ),
            (_('Advanced 2'),
                (
                    (_('Scrap window:'), 'scrapwindow'),
                    (_('Properties window:'), 'propwindow'),
                    (_('Slider window:'), 'sliderwindow'),
                    (_('Slider window text field:'), 'sliderwindowtextctrl'),
                    (_('Slider window default value:'), 'sliderwindowdefvalue'),
                    ((_('Slider window sliders background:'), 'usesliderwindowbackslider', _('Use another color for the sliders background')), 'sliderwindowbackslider'),
                    ((_('Slider window preview filters:'), 'usesliderwindowprevfiltercolor', _('Use another color for the preview filters\nAlternating (fore, back)')), 'sliderwindowprevfilter'),
                    ((_('Slider window sidebar color:'), 'sliderwindowsidebarcolor', _('Colorize the slider window sidebar')), 'sliderwindowsidebar'),
                    (_('Slider window extras (Snapshot):'), 'sliderwindowextrabtn1'),
                ),
            )
        )

        exOptions = {}
        if readExOptions:
            optFile = os.path.join(self.programdir, 'backup_style.dat')
            if os.path.isfile(optFile):
                try:
                    with open(optFile, mode='rb') as f:
                        exOptions = cPickle.load(f)
                    if exOptions and exOptions.get('version').startswith('1.'):
                        raise
                    if not 'textstyles' in exOptions or not 'colourdata' in exOptions:
                        raise
                    self.colour_data.FromString(exOptions['colourdata'])
                except:
                    self.loaderror.append(os.path.basename(optFile))
                    shutil.copy2(optFile, os.path.splitext(optFile)[0] + '.BAD')
                    exOptions = {}
                    wx.MessageBox(_('Cannot load Backup file:\n' + optFile),
                                    _('Error'), style=wx.OK|wx.ICON_ERROR)
                    return
            else:
                wx.MessageBox(_('Backup file not found:\n' + optFile +
                                '\n\nYou must first make a backup'),
                                _('Information'), style=wx.OK|wx.ICON_INFORMATION)
                return

        extra = None # adds a single CheckBox, (label, options_dict_key, tooltip)

        # GPo only for clean up the options
        """
        for key in self.options['textstyles'].keys():
            if self.options['textstyles'][key] == 'usesliderwindowprevfiltercolor':
                wx.MessageBox('OK')
                del self.options['textstyles'][key]
        """
        #self.options['textstyles'] = {}

        if exOptions:
            wx.MessageBox(_('Settings have been read from backup file\n'),
                             _('Information'), style=wx.OK|wx.ICON_INFORMATION)
            dlg = AvsStyleDialog(self, dlgInfo, exOptions['textstyles'], self.defaulttextstylesDict, self.colour_data, extra)
        else:
            dlg = AvsStyleDialog(self, dlgInfo, self.options['textstyles'], self.defaulttextstylesDict, self.colour_data, extra)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            self.options['textstyles'] = dlg.GetDict()
            self.options.update(dlg.GetDict2())
            self.options['colourdata'] = self.colour_data.ToString()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
            for index in xrange(self.scriptNotebook.GetPageCount()):
                script = self.scriptNotebook.GetPage(index)
                script.SetUserOptions()
                if self.options['sliderwindowcustomtheme']:
                    script.sliderWindow.SetThemeColors()
            if self.options['sliderwindowsidebarcolor']:
                color = self.GetThemeColor('sliderwindowsidebar', 'back')
                if color:
                    self.videoPane.SetBackgroundColour(color)
            else:
                self.videoPane.SetBackgroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW))
            self.videoPane.Refresh()
            self.SetMinimumScriptPaneSize()
            self.scrapWindow.Style()
            self.propWindow.Style()
            if self.currentSliderWindow.customTheme:
                self.OnSliderUpdate(None) # Update only the current sliderWindow
            #if readExOptions:
                #self.OnMenuOptionsFontsAndColorsWriteBackup(None)
        else:
            if exOptions:
                self.colour_data.FromString(self.options['colourdata'])

        dlg.Destroy()

    def OnMenuOptionsTemplates(self, event):
        # Build and show the dialog
        def keyChecker(key):
            msg = None
            if '.' in key:
                msg = '%s\n%s' % (_('Insert aborted:'), _("File extension shouldn't contain dots!"))
            return msg
        self.StopPlayback()
        dlg = wxp.EditStringDictDialog(
            self,
            self.options['templates'],
            title=_('Edit extension-based templates'),
            keyTitle='  '+_('File extension'),
            valueTitle=_('Template'),
            editable=False,
            insertable=True,
            keyChecker=keyChecker,
            about='%s\n%s' % (
                _('This info is used for inserting sources based on file extensions.'),
                _('Any instances of *** in the template are replaced with the filename.')
            )+'\n'+_('(If you want relative paths instead of the full filename, use [***].)'
             +'\n' +_('Everything between >< replaces the file extension: >*Tc*.mp2< and searched for it.')),
        )
        ID = dlg.ShowModal()
        # Set the data
        if ID == wx.ID_OK:
            self.options['templates'] = dlg.GetDict()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
        dlg.Destroy()

    def OnMenuOptionsSnippets(self, event):
        # Build and show the dialog
        def keyChecker(key):
            if not re.match(r'^\w+$', key):
                return '%s\n%s' % (_('Insert aborted:'), _('Only alphanumeric and underscores allowed!'))
        self.StopPlayback()
        dlg = wxp.EditStringDictDialog(
            self,
            self.options['snippets'],
            title=_('Edit insertable text snippets'),
            keyTitle='  '+_('Tag'),
            valueTitle=_('Snippet'),
            editable=True,
            insertable=True,
            keyChecker=keyChecker
        )
        ID = dlg.ShowModal()
        # Set the data
        if ID == wx.ID_OK:
            self.options['snippets'] = dlg.GetDict()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
        dlg.Destroy()

    def OnMenuOptionsApplyFilter(self, event):
        def keyChecker(key):
            #if not re.match(r'^\w+$', key):
                #return '%s\n%s' % (_('Insert aborted:'), _('Only alphanumeric allowed!'))
            if len(dlg.GetDict()) > 29:
                return '%s\n%s' % (_('Insert aborted:'), _('A maximum of 30 entries are allowed!'))
        self.StopPlayback()
        dlg = wxp.EditStringDictDialog(
            self,
            self.options['applyfilters'],
            title=_('Edit insertable timeline selection filters'),
            keyTitle='  '+_('Tag'),
            valueTitle=_('Avisynth filter ( %start %stop is replaced by selection start stop )'),
            editable=True,
            insertable=True,
            keyChecker=keyChecker,
            size=tuplePPI(540, 380),
            about = '%s\n%s' % (_('%* insert the selected text, %join joins the filters from each selected line'),
                                _('%copy copies the selected text, %> copy this line to all timeline selections'))
        )
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            self.options['applyfilters'] = dlg.GetDict()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
        dlg.Destroy()

    # display filter templates
    def OnMenuOptionsDisplayFilter(self, event):
        def keyChecker(key):
            #if not re.match(r'^\w+$', key):
                #return '%s\n%s' % (_('Insert aborted:'), _('Only alphanumeric allowed!'))
            if len(dlg.GetDict()) > 29:
                return '%s\n%s' % (_('Insert aborted:'), _('A maximum of 30 entries are allowed!'))
        self.StopPlayback()
        dlg = wxp.EditStringDictDialog(
            self,
            self.options['displayfilters'],
            title=_('Edit display filter templates'),
            keyTitle='  '+_('Tag'),
            valueTitle=_('Avisynth filter (you can run short macro by adding #> at line start'),
            editable=True,
            insertable=True,
            keyChecker=keyChecker,
            about = '%s %s' % (_('Display filters only affects the display drawing.'),
                               _('It is applied as last filter to all tabs.'))
        )
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            self.options['displayfilters'] = dlg.GetDict()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
        dlg.Destroy()

    def OnMenuOptionsResizeFilter(self, event):
        dlg = wx.TextEntryDialog(self, _('Insert a valid avisynth resizer'), _('Resample filter'), self.resizeFilter[1])
        ID = dlg.ShowModal()
        label = str(dlg.GetValue().strip())
        dlg.Destroy()
        if ID == wx.ID_OK and label:
            rf = self.resizeFilter
            self.resizeFilter = (rf[0],label,rf[2],rf[3])
            self.options['resizefilter'] = label
            for i in xrange(self.scriptNotebook.GetPageCount()):
                script = self.scriptNotebook.GetPage(i)
                rf = script.resizeFilter
                script.resizeFilter = (rf[0],label,rf[2],rf[3])
                if rf[0]:
                    script.display_clip_refresh_needed = True
            if self.currentScript.display_clip_refresh_needed:
                self.ShowVideoFrame()
            #if rf[0]:
                #self.OnMenuVideoZoomResampleFit(zoom=rf[2], fitHeight=rf[3])

    def OnMenuOptionsDisablePreview(self, event):
        id = event.GetId()
        menuItem = self.GetMenuBar().FindItemById(id)
        if not self.options['disablepreview']:
            self.HidePreviewWindow()
            self.options['disablepreview'] = True
            #~ menuItem.SetText('%s%s' % (_('Video preview disabled'), acc))
            menuItem.Check(True)
            for ctrl in self.videoControlWidgets:
                ctrl.Disable()
                ctrl.Refresh()
        else:
            self.options['disablepreview'] = False
            #~ menuItem.SetText('%s%s' % (_('Disable the video preview'), acc))
            menuItem.Check(False)
            for ctrl in self.videoControlWidgets:
                ctrl.Enable()
                ctrl.Refresh()

    def OnMenuOptionsMultilineTabStyle(self, event=None):
        # do not use event.IsChecked(), if options multiline changed the check state is not changed
        # the check state only change on showing the menu entry (Menubar pops up)
        self.options['multilinetab'] = not self.options['multilinetab']
        style = wx.NO_BORDER
        if self.options['multilinetab']:
            style |= wx.NB_MULTILINE
        if self.options['fixedwidthtab']:
            style |= wx.NB_FIXEDWIDTH
        self.scriptNotebook.SetWindowStyleFlag(style)
        # a workaroud for multiline notebook issue
        w, h = self.scriptNotebook.GetSize()
        self.scriptNotebook.SetSize((w, h-1))
        self.scriptNotebook.SetSize((w, h))
        self.SetMinimumScriptPaneSize(self.mintextlines)
        if self.previewWindowVisible and self.previewOK():
            self.OnMainSplitterPosChanged()

    def OnMenuOptionsHideScrollbars(self, event):
        self.options['hidescrollbars'] = event.IsChecked()
        if self.options['hidescrollbars']:
            self.videoWindow.ShowScrollbars(wx.SHOW_SB_NEVER, wx.SHOW_SB_NEVER)
        else:
            self.videoWindow.ShowScrollbars(wx.SHOW_SB_DEFAULT, wx.SHOW_SB_DEFAULT)
        self.videoWindow.SetScrollRate(1,1)
        if not self.previewOK():
            return
        self.ShowVideoFrame_checkResizeFilter(self.currentScript)

    def OnMenuOptionsAviThread(self, event):
        self.CheckPlayback()
        self.options['avithread'] = event.IsChecked()
        self.UseAviThread = self.options['avithread']
        self.CheckPlayback()

    def OnMenuOptionsUseNewFrameThread(self, event):
        self.CheckPlayback()
        self.options['usenewframethread'] = event.IsChecked()
        self.UseNewFrameThread = event.IsChecked()
        if not self.UseNewFrameThread:
            for i in range(self.scriptNotebook.GetPageCount()):
                script = self.scriptNotebook.GetPage(i)
                if script.FrameThread and not script.FrameThread.IsRunning():
                    script.FrameThread.Exit()
                    script.FrameThread = None
        elif self.options['avithread']: # not important, is created on GetDisplayFrame
            for i in range(self.scriptNotebook.GetPageCount()):
                script = self.scriptNotebook.GetPage(i)
                if script.FrameThread is None:
                    script.FrameThread = self.FrameThread(script)
        self.CheckPlayback()

    def OnMenuOptionsAviThreadAssignLater(self, event):
        self.options['avithreadassignlater'] = event.IsChecked()

    def OnMenuOptionsFastClip(self, event):
        self.options['usefastclip'] = event.IsChecked()
    """
    def OnMenuOptionsAllowSplitClipFilter(self, event):
        self.options['fastclipallowfilter'] = event.IsChecked()
    """

    """
    def OnMenuOptionsRefreshPaintFrame(self, event):
        if not event.IsChecked() and self.options['hidethreadprogress']:
            re = wx.MessageBox(_('Hiding the thread progress dialog will be disabled.\nContinue?'), '', wx.YES_NO|wx.ICON_QUESTION)
            if re == wx.YES:
                self.options['hidethreadprogress'] = False
                self.options['cliprefreshpainter'] = False
            else:
                self.UpdateMenuItem(_('Draw frame during clip refresh'), True, _('&Options'))
                self.options['cliprefreshpainter'] = True
        else:
            self.options['cliprefreshpainter'] = True

    def OnSelectHideThreadProgress(self, event):
        if event.IsChecked():
            re = wx.YES
            if not self.options['cliprefreshpainter']:
                re = wx.MessageBox(_('Options -> "Draw frame during clip refresh" must be enabled to use this option.\n' +
                                     'Should it be activated?'), '', wx.YES_NO|wx.ICON_QUESTION)
                if re == wx.YES:
                    self.options['cliprefreshpainter'] = True
                    self.UpdateMenuItem(_('Draw frame during clip refresh'), True, _('&Options'))
                    return
            if not self.options['cliprefreshpainter']:
                event.GetEventObject().SetValue(False)
    """

    def OnMenuOptionsAssociate(self, event):
        if os.name == 'nt':
            s1 = _('Associating .avs files will write to the windows registry.')
            s2 = _('Do you wish to continue?')
            ret = wx.MessageBox('%s\n\n%s' % (s1, s2), _('Warning'), wx.YES_NO|wx.ICON_EXCLAMATION)
            if ret == wx.YES:
                try:
                    restore = 'avsp' in _winreg.QueryValue(_winreg.HKEY_CLASSES_ROOT, 'avsfile\\shell\\Open\\command').lower()
                except WindowsError:
                    restore = False
                ret = wx.MessageBox((_('Disassociate avs files for all users?') if restore else _('Associate avs files for all users?')) +
                                     _(' Admin rights are needed.'), '', wx.YES_NO|wx.CANCEL|wx.ICON_QUESTION)
                if ret != wx.CANCEL:
                    if hasattr(sys,'frozen'): # run in py2exe binary mode
                        value = u'"%s" "%%1"' % sys.executable
                    else: # run in source mode
                        script = os.path.join(self.programdir, 'run.py')
                        value = u'"%s" -O "%s" "%%1"' % (sys.executable, script)
                    f = tempfile.NamedTemporaryFile(delete=False)
                    if restore:
                        txt = textwrap.dedent(u'''\
                        HKCU\\Software\\Classes\\avsfile\\shell\\Open\\command
                        = notepad "%1"
                        HKCU\\Software\\Classes\\avs_auto_file\\shell\\Open\\command
                        = notepad "%1"''')
                        if ret == wx.YES:
                            txt += textwrap.dedent(u'''
                            HKLM\\Software\\Classes\\avsfile\\shell\\Open\\command
                            = notepad "%1"
                            HKLM\\Software\\Classes\\avs_auto_file\\shell\\Open\\command
                            = notepad "%1"''')
                    else:
                        txt = textwrap.dedent(u'''\
                        HKCU\\Software\\Classes\\avsfile\\shell\\Open\\command
                        = "{value}"
                        HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.avs
                        "Application" = DELETE
                        HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.avs\\UserChoice
                        HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.avs\\UserChoice [DELETE]
                        HKCU\\Software\\Classes\\avs_auto_file\\shell\\Open\\command
                        = "{value}"
                        HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.avsi
                        "Application" = DELETE
                        HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.avsi\\UserChoice
                        HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.avsi\\UserChoice [DELETE]
                        ''').format(value=value)
                        if ret == wx.YES:
                            txt += textwrap.dedent(u'''
                            HKLM\\Software\\Classes\\avsfile\\shell\\Open\\command
                            = "{value}"
                            HKLM\\Software\\Classes\\avs_auto_file\\shell\\Open\\command
                            = "{value}"''').format(value=value)
                    f.write(txt.encode('utf16'))
                    f.close()
                    if ret == wx.YES:
                        ctypes.windll.shell32.ShellExecuteW(None, u'runas', u'cmd', u'/k "regini "{f}" & del "{f}""'.format(f=f.name.decode(encoding)), None, 0)
                    else:
                        os.system('regini "{f}" & del "{f}"'.format(f=f.name))
        else:
            app_file = os.path.join(tempfile.gettempdir(), global_vars.name.lower() + '.desktop')
            with open(app_file, 'w') as f:
                txt = textwrap.dedent('''\
                [Desktop Entry]
                Version=1.0
                Name={name}
                GenericName=Video Editor
                Comment={comment}
                Type=Application
                Exec=python -O {dir}/run.py %F
                Terminal=false
                StartupNotify=true
                Icon={dir}/AvsP.ico
                Categories=AudioVideo;
                MimeType=text/x-avisynth;''').format(name=self.name,
                    comment=global_vars.description, dir=self.programdir)
                f.write(txt)
            if 'avsp' in subprocess.check_output(['xdg-mime', 'query', 'default', 'text/x-avisynth']):
                text_editor = subprocess.check_output(['xdg-mime', 'query', 'default', 'text/plain']).strip()
                os.system('xdg-desktop-menu uninstall {0} && '
                          'xdg-mime default {1} text/x-avisynth'.format(app_file, text_editor))
            else:
                mime_file = os.path.join(tempfile.gettempdir(), 'avisynth.xml')
                with open(mime_file, 'w') as f:
                    txt = textwrap.dedent('''\
                    <?xml version="1.0"?>
                    <mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
                      <mime-type type="text/x-avisynth">
                        <comment>AviSynth script</comment>
                        <glob pattern="*.avs"/>
                        <glob pattern="*.avsi"/>
                      </mime-type>
                    </mime-info>''')
                    f.write(txt)
                os.system('xdg-mime install --novendor {mime_file} && '
                          'xdg-desktop-menu install --novendor {app_file} && '
                          'xdg-mime default {app_file} text/x-avisynth'.format(mime_file=mime_file, app_file=app_file))
                os.remove(mime_file)
            os.remove(app_file)

    def OnMenuConfigureShortcuts(self, event):
        exceptionIds = (
            self.exceptionShortcuts,
            self.stcShortcuts,
            self.options['reservedshortcuts'],
            _('Above keys are built-in editing shortcuts. If item is checked,\n'
              'it will not be overrided by a menu shortcut in script window.')
        )
        dlg = wxp.ShortcutsDialog(self, self.options['shortcuts'], exceptionIds=exceptionIds,
                                  submessage=_('* This shortcut is active only when video window has focus.\n'
                                               '~ This shortcut is active only when script window has focus.'))
        ID = dlg.ShowModal()
        # Set the data
        if ID == wx.ID_OK:
            shortcutList, reservedShortcuts = dlg.GetShortcutList()
            for old, new in zip(self.options['shortcuts'], shortcutList):
                if old != new:
                    menuString, shortcut, id = new
                    menuItem = self.GetMenuBar().FindItemById(id)
                    label = menuItem.GetLabel()
                    if shortcut != '':
                        shortcut = u'\t%s\u00a0' % wxp.GetTranslatedShortcut(shortcut)
                        if os.name != 'nt' and wx.version() >= '2.9': # XXX
                            shortcut = shortcut[:-1]
                    newLabel = '%s%s' % (label, shortcut)
                    menuItem.SetItemLabel(newLabel)
            self.options['shortcuts'] = shortcutList
            self.options['reservedshortcuts'] = reservedShortcuts
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
            self.bindShortcutsToAllWindows()
        dlg.Destroy()

    def OnMenuOptionsSettings(self, event):
        self.ShowOptions(self.optionsLastPageIndex)

    def OnMenuHelpAvisynth(self, event):
        helpfile = self.ExpandVars(self.options['avisynthhelpfile'])
        # Check if the given doc path exists on the computer or is a url
        if os.path.isfile(helpfile) or helpfile.startswith('http://'):
            startfile(helpfile)
            return True
        # Give a message if not a file or a url
        wx.MessageBox('Could not find avisynth help file!', _('Error'), style=wx.OK|wx.ICON_ERROR)

    def OnMenuHelpAvisynthPlugins(self, event):
        plugindir = self.ExpandVars(self.options['pluginsdir'])
        if os.path.isdir(plugindir):
            startfile(plugindir)
        else:
            wx.MessageBox(_('Could not find the Avisynth plugins folder!'), _('Error'), style=wx.OK|wx.ICON_ERROR)

    def OnMenuHelpAnimatedTutorial(self, event):
        filename = os.path.join(self.helpdir, 'Demo.htm')
        if os.path.isfile(filename):
            startfile(filename)
        else:
            #startfile('http://avisynth.nl/users/qwerpoi/Demo.htm') # not available, killed?
            startfile('http://avisynth.nl/users/qwerpoi/index.html')

    def OnMenuHelpExampleVideos(self, event):
        startfile('https://drive.google.com/drive/folders/1-2MOIzJ6R3jQOlWh0Fq0x8fbscr_FEcn?usp=sharing')

    def OnMenuHelpTextFeatures(self, event):
        filename = os.path.join(self.helpdir, 'Text.html')
        if os.path.isfile(filename):
            startfile(filename)
        else:
            startfile('http://avisynth.nl/users/qwerpoi/Text.html')

    def OnMenuHelpVideoFeatures(self, event):
        filename = os.path.join(self.helpdir, 'Video.html')
        if os.path.isfile(filename):
            startfile(filename)
        else:
            startfile('http://avisynth.nl/users/qwerpoi/Video.html')

    def OnMenuHelpUserSliderFeatures(self, event):
        filename = os.path.join(self.helpdir, 'UserSliders.html')
        if os.path.isfile(filename):
            startfile(filename)
        else:
            startfile('http://avisynth.nl/users/qwerpoi/UserSliders.html')

    def OnMenuHelpMacroFeatures(self, event):
        filename = os.path.join(self.helpdir, 'Macros.html')
        if os.path.isfile(filename):
            startfile(filename)
        else:
            startfile('http://avisynth.nl/users/qwerpoi/Macros.html')

    def OnMenuHelpChangelog(self, event):
        changelog = os.path.join(self.programdir, 'changelog.txt')
        if os.path.isfile(changelog):
            startfile(changelog)
        else:
            wx.MessageBox(_('Could not find %(changelog)s!') % locals(), _('Error'), style=wx.OK|wx.ICON_ERROR)

    def OnHelpMenuExample(self, filename):
        example = os.path.join(self.programdir, filename)
        if os.path.isfile(example):
            startfile(example)
        else:
            wx.MessageBox(_('Could not find %(example)s!') % locals(), _('Error'), style=wx.OK|wx.ICON_ERROR)

    def OnMenuHelpReadme(self, event):
        self.OnHelpMenuExample('readme.txt')

    def OnMenuHelpPreviewFilters(self, event):
        example = os.path.join(self.programdir, 'previewFilterExample.avs')
        if os.path.isfile(example):
            self.HidePreviewWindow()
            self.OpenFile(example)
            return
        self.OnHelpMenuExample('previewFilterExample.txt')

    def OnMenuHelpAccessInThreads(self, event):
        self.OnHelpMenuExample('readme_Threads.txt')
    def OnMenuHelpApplyFilters(self, event):
        self.OnHelpMenuExample('readme_ApplyFilters.txt')
    def OnMenuHelpResampleFilter(self, event):
        self.OnHelpMenuExample('readme_ResampleFilter.txt')
    def OnMenuHelpSplitClip(self, event):
        self.OnHelpMenuExample('readme_SplitClip.txt')
    def OnMenuHelpNumberWheel(self, event):
        self.OnHelpMenuExample('readme_NumberWheel.txt')
    def OnMenuHelpFastClip(self, event):
        self.OnHelpMenuExample('readme_FastClip.txt')
    def OnMenuHelpLocateFrame(self, event):
        self.OnHelpMenuExample('readme_LocateFrame.txt')

    def OnMenuHelpAbout(self, event):
        int5 = intPPI(5)
        int10 = intPPI(10)
        prog_name = global_vars.name
        version = self.version
        arch = u'{0} {1}'.format(platform.system(), 'x86-64' if self.x86_64 else 'x86-32')
        dlg = wx.Dialog(self, wx.ID_ANY, _('About AvsPmod'), size=tuplePPI(220,180))
        SetFontPPI(dlg)
        bmp = AvsP_icon.getBitmap()
        logo = wx.StaticBitmap(dlg, wx.ID_ANY, bmp)
        title = wx.StaticText(dlg, wx.ID_ANY, _('{prog_name} v{version} ({arch})').format(**locals()))
        font = title.GetFont()
        font.SetPointSize(intPPI(12))
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        title.SetFont(font)
        description = wx.StaticText(dlg, wx.ID_ANY, _(global_vars.description))
        dpi.SetFontSize(factor=self.ppi_factor, font=description.GetFont(), size_adj=2)
        link = wx.StaticText(dlg, wx.ID_ANY, _('AvsP Website'))
        font = link.GetFont()
        font.SetUnderlined(True)
        link.SetFont(font)
        link.SetForegroundColour(wx.Colour(0,0,255))
        link.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        url = 'http://avisynth.nl/users/qwerpoi/'
        def OnClick(event):
            startfile(url)
        link.SetToolTip(wx.ToolTip(url))
        link.Bind(wx.EVT_LEFT_DOWN, OnClick)

        link0 = wx.StaticText(dlg, wx.ID_ANY, _("AvsPmod Website"))
        font = link0.GetFont()
        font.SetUnderlined(True)
        link0.SetFont(font)
        link0.SetForegroundColour(wx.Colour(0,0,255))
        link0.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        url0 = global_vars.url
        def OnClick0(event):
            startfile(url0)
        link0.SetToolTip(wx.ToolTip(url0))
        link0.Bind(wx.EVT_LEFT_DOWN, OnClick0)

        link1 = wx.StaticText(dlg, wx.ID_ANY, _("Active thread on Doom9's forum"))
        font = link1.GetFont()
        font.SetUnderlined(True)
        link1.SetFont(font)
        link1.SetForegroundColour(wx.Colour(0,0,255))
        link1.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        url1 = 'https://forum.doom9.org/showthread.php?t=175823'
        def OnClick1(event):
            startfile(url1)
        link1.SetToolTip(wx.ToolTip(url1))
        link1.Bind(wx.EVT_LEFT_DOWN, OnClick1)

        staticText = wx.StaticText(dlg, wx.ID_ANY, _('This program is freeware under the GPL license.'))
        url2 = 'http://www.gnu.org/copyleft/gpl.html'
        link2 = wx.StaticText(dlg, wx.ID_ANY, url2)
        font = link2.GetFont()
        font.SetUnderlined(True)
        link2.SetFont(font)
        link2.SetForegroundColour(wx.Colour(0,0,255))
        link2.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        def OnClick2(event):
            startfile(url2)
        link2.SetToolTip(wx.ToolTip(url2))
        link2.Bind(wx.EVT_LEFT_DOWN, OnClick2)

        button = wx.Button(dlg, wx.ID_OK, _('OK'))
        inner = wx.BoxSizer(wx.HORIZONTAL)
        inner.Add(logo, 0, wx.LEFT, int10)
        inner.Add(title, 0, wx.ALIGN_CENTER|wx.LEFT|wx.RIGHT, int10)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(inner, 0, wx.TOP, intPPI(20))
        sizer.Add(description, 0, wx.ALIGN_CENTER|wx.ALL, int10)
        sizer.Add(link0, 0, wx.ALIGN_CENTER|wx.ALL, int5)
        sizer.Add(link1, 0, wx.ALIGN_CENTER|wx.ALL, int5)
        sizer.Add(link, 0, wx.ALIGN_CENTER|wx.ALL, int5)
        sizer.Add((0,int5), 0, wx.EXPAND)
        sizer.Add(wx.StaticLine(dlg), 0, wx.EXPAND|wx.TOP, int10)
        sizer.Add(staticText, 0, wx.ALIGN_CENTER|wx.ALL, int5)
        sizer.Add(link2, 0, wx.ALIGN_CENTER|wx.ALL, int5)
        sizer.Add(button, 0, wx.ALIGN_CENTER|wx.ALL, int5)
        dlg.SetSizer(sizer)
        dlg.Layout()
        dlg.Fit()
        dlg.ShowModal()
        dlg.Destroy()

    def OnMenuDPIInfo(self, event):
        sTab = 0 if self.options['ppiscalingscripttabs'] == 0 else float(self.options['ppiscalingscripttabs']/10.0)
        sControls = 0 if self.options['ppiscalingvideocontrols'] == 0 else float(self.options['ppiscalingvideocontrols']/10.0)
        sStatus = 0 if self.options['ppiscalingstatusbar'] == 0 else float(self.options['ppiscalingstatusbar']/10.0)
        sSlider = 0 if self.options['ppiscalingsliderwindow'] == 0 else float(self.options['ppiscalingsliderwindow']/10.0)
        wx.MessageBox('Monitor DPI: ' + str(wx.GetDisplayPPI()) +
                      '\nScreen DPI: ' + str(wx.ScreenDC().GetPPI()) +
                      '\n\nDPI scaling overall: ' + str(self.ppi_factor*100) + ' %' +
                      '\nDPI scaling main tab: ' + str((max(self.ppi_factor+sTab, 1))*100) + ' %' +
                      '\nDPI scaling video controls: ' + str((max(self.ppi_factor+sControls,1))*100) + ' %' +
                      '\nDPI scaling slider window: ' + str((self.ppi_factor+sSlider)*100) + ' %' +
                      '\nDPI scaling statusbar: ' + str((self.ppi_factor+sStatus)*100) + ' %' +
                      '\n\nDPI Aware: ' + str(dpi.dpiAware) +
                      '\nDPI Awareness: ' + str(dpi.dpiAwareness))

    def OnButtonTextSetFocus(self, event):
        self.SetStatusText(_("Input a frame number or time (hr:min:sec) and hit Enter. Right-click to retrieve from history. " \
                             "Or input a text and set the bookmark title."))
        frameTextCtrl = event.GetEventObject()
        frameTextCtrl.SetForegroundColour(wx.BLACK)
        wx.CallAfter(frameTextCtrl.SetSelection, -1, -1)
        event.Skip()

    # GPo 2020, for macro uses
    def GetClipboardText(self):
        txt = ''
        if not wx.TheClipboard.IsOpened():
            wx.TheClipboard.Open()
            text = wx.TextDataObject('')
            if wx.TheClipboard.GetData(text):
                txt = text.GetText()
            wx.TheClipboard.Close()
        return txt

        # GPo 2020, for macro uses
    def SetClipboardText(self, text):
        if text and not wx.TheClipboard.IsOpened():
            if wx.TheClipboard.Open():
                wx.TheClipboard.SetData(wx.TextDataObject(text))
                wx.TheClipboard.Close()
                return True

    def OnButtonTextKillFocus(self, event):
        frameTextCtrl = event.GetEventObject()
        txt = frameTextCtrl.GetLineText(0)
        if txt and txt not in self.recentframes:
            if txt.isdigit() or len(txt.split(':')) > 1: # GPo 2020, ~ frame or time
                self.recentframes.append(txt)
        win = self.FindFocus()
        if win != frameTextCtrl:
            event.Skip()
            frame = self.videoSlider.GetValue()
            bms = self.GetBookmarkFrameList()
            if frame in bms:
                color = wx.RED
            else:
                color = wx.BLACK
            self.frameTextCtrl.SetForegroundColour(color)
            self.frameTextCtrl.Replace(0, -1, str(frame))
            return
        try:
            frame = int(txt)
        except ValueError:
            timetxt = txt.split(':')
            if len(timetxt) == 2:
                timetxt.insert(0, 0)
            try:
                if len(timetxt) != 3: raise
                hours = int(timetxt[0])
                if hours < 0: raise
                minutes = int(timetxt[1])
                if minutes < 0 or minutes >= 60: raise
                seconds = float(timetxt[2])
                if seconds < 0 or seconds >= 60: raise
                total = hours * 60 * 60 + minutes * 60 + seconds
                frame = int(round(self.currentScript.AVI.Framerate * total))
            except:
                frame = -2
        if frame == -1:
            frame = self.currentScript.AVI.Framecount - 1
        if frame < 0 or (self.currentScript.AVI and frame >= self.currentScript.AVI.Framecount):
            frame = None
            wx.Bell()
            #return   # GPo, do not return, show the current script.frame and kill frameTextCtrl focus (background color has changed)
        if not self.separatevideowindow:
            self.ShowVideoFrame(frame)
        else:
            if event is not None and event.GetEventObject() in self.videoControlWidgets and self.previewWindowVisible:
                self.ShowVideoFrame(frame, focus=False)
                self.currentScript.SetFocus()
            else:
                self.ShowVideoFrame(frame)

    def OnPlayButtonContextMenu(self, event): # GPo 2020
        def OnSelectDropFrames(event):
            self.CheckPlayback()
            item = dropMenu.FindItemById(event.GetId())
            nr = item.GetLabel()
            if nr == _('Auto'):
                self.play_drop = True
            elif nr.isdigit():
                self.play_drop = int(nr)
            else:
                self.play_drop = False
            self.CheckPlayback()
        def AddDropFrameItems(menu):
            nr = 2
            for i in range(5):
                id = wx.NewId()
                self.Bind(wx.EVT_MENU, OnSelectDropFrames, id=id)
                menu.Append(id, str(nr), kind=wx.ITEM_CHECK)
                menu.Check(id, self.play_drop==nr)
                if nr < 4: nr += 2
                else: nr += 4
        def OnVideoPlayHalfSpeed(event):
            self.CheckPlayback()
            self.play_speed_factor = 0.5
            self.CheckPlayback()
        popup = wx.Menu()
        dropMenu = wx.Menu()
        # Loop
        id = wx.NewId()
        popup.Append(id, _('Play loop'), kind=wx.ITEM_CHECK)
        popup.Check(id, self.options['playloop'])
        self.Bind(wx.EVT_MENU, self.OnMenuVideoPlayLoop, id=id)
        # Drop frames
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnSelectDropFrames, id=id)
        dropMenu.Append(id, _('None'), kind=wx.ITEM_CHECK)
        dropMenu.Check(id, self.play_drop==False)
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnSelectDropFrames, id=id)
        dropMenu.Append(id, _('Auto'), kind=wx.ITEM_CHECK)
        dropMenu.Check(id, self.play_drop==True)
        AddDropFrameItems(dropMenu)
        popup.AppendMenu(wx.ID_ANY, _('Drop frames'), dropMenu)
        popup.AppendSeparator()
        # Speed
        id = wx.NewId()
        popup.Append(id, _('Half speed'), kind=wx.ITEM_CHECK)
        popup.Check(id, self.play_speed_factor == 0.5)
        self.Bind(wx.EVT_MENU, OnVideoPlayHalfSpeed, id=id)
        id = wx.NewId()
        popup.Append(id, _('Normal speed'), kind=wx.ITEM_CHECK)
        popup.Check(id, self.play_speed_factor == 1.0)
        self.Bind(wx.EVT_MENU, self.OnMenuVideoPlayNormal, id=id)
        id = wx.NewId()
        popup.Append(id, _('Maximum speed'), kind=wx.ITEM_CHECK)
        popup.Check(id, self.play_speed_factor == 'max')
        self.Bind(wx.EVT_MENU, self.OnMenuVideoPlayMax, id=id)
        self.PopupMenu(popup)
        popup.Destroy()

    def OnButtonFrameStepContextMenu(self, event):
        def OnSetSelection(event):
            item = popup.FindItemById(event.GetId())
            label = item.GetLabel()
            idx = 0
            if label == _('"I" frame'): idx = 4
            elif label == _('Custom unit'): idx = 3
            elif label == _('1 Minute'): idx = 2
            elif label == _('1 Second'): idx = 1
            self.options['buttonjumpchoice'] = idx
        def AddItem(label, check):
            id = wx.NewId()
            popup.Append(id, _(label), kind=wx.ITEM_CHECK)
            popup.Check(id, check)
            self.Bind(wx.EVT_MENU, OnSetSelection, id=id)
        idx = self.options['buttonjumpchoice']
        popup = wx.Menu()
        AddItem(_('"I" frame'), idx==4)
        AddItem(_('Custom unit'), idx==3)
        AddItem(_('1 Minute'), idx==2)
        AddItem(_('1 Second'), idx==1)
        AddItem(_('1 Frame'), idx==0)
        self.PopupMenu(popup)
        popup.Destroy()

    def OnButtonTextContextMenu(self, event):
        textCtrl = event.GetEventObject()
        menu = wx.Menu()
        def OnContextMenuCopyTime(event):
            frame = self.GetFrameNumber()
            try:
                m, s = divmod(frame/self.MacroGetVideoFramerate(), 60)
            except:
                return
            h, m = divmod(m, 60)
            timecode = '%02i:%02i:%06.3f' % (h ,m, int(s*1000)/1000.0)
            if not wx.TheClipboard.IsOpened():
                wx.TheClipboard.Open()
                wx.TheClipboard.SetData(wx.TextDataObject(timecode))
                wx.TheClipboard.Close()

        def OnContextMenuCopy(event):
            text = textCtrl.GetStringSelection()
            if not text:
                text = textCtrl.GetLineText(0)
            if text and not wx.TheClipboard.IsOpened():
                wx.TheClipboard.Open()
                wx.TheClipboard.SetData(wx.TextDataObject(text))
                wx.TheClipboard.Close()

        def OnContextMenuPaste(event):
            if not wx.TheClipboard.IsOpened():
                wx.TheClipboard.Open()
                text = wx.TextDataObject('')
                if wx.TheClipboard.GetData(text):
                    text = text.GetText()
                    if text:
                        frm, to = textCtrl.GetSelection()
                        if textCtrl.FindFocus() != textCtrl:
                            frm, to = 0, -1
                        textCtrl.Replace(frm, to, text)
                        textCtrl.SetFocus()
                wx.TheClipboard.Close()

        def OnContextMenuClear(event):
            self.recentframes = []

        def OnContextMenuItem(event):
            item = menu.FindItemById(event.GetId())
            nr = item.GetItemLabelText()
            textCtrl.Replace(0, -1, nr)
            textCtrl.SetFocus()
            if nr.isdigit():         # GPo
                self.CheckPlayback()
                self.ShowVideoFrame(int(nr))
                if self.playing_video == '':
                    wx.CallAfter(self.PlayPauseVideo)

        def OnContextMenuHilight(event):  # GPo
            for slider in self.GetVideoSliderList():
                slider.SetBookmarkHilighting(not self.videoSlider.hilightBookmarks)
            if self.videoSlider.hilightBookmarks and self.bellAtBookmark:
                self.bellAtBookmark = False
            # if slider offset, the slider value must new read or highligth color is not set
            for slider in self.GetVideoSliderList():
                slider.SetValue(self.videoSlider.GetValue())
                slider.Refresh()

        def OnContextMenuBell(event):  # GPo
            self.bellAtBookmark = not self.bellAtBookmark
            if self.bellAtBookmark and self.videoSlider.hilightBookmarks:
                for slider in self.GetVideoSliderList():
                    slider.SetBookmarkHilighting(False)
                    slider.Refresh()

        def OnContextMenuBookmarkTitle(event):
            bookmarks = self.GetBookmarkDict()
            frame = self.currentframenum
            if frame  in bookmarks:
                s = textCtrl.GetLineText(0)
                if s:
                    self.titleDict[frame] = s
                elif frame in self.titleDict:
                    del self.titleDict[frame]
                self.currentScript.bookmarks = None
                self.currentScript.bookmarks = self.GetBookmarkDict()
                self.UpdateBookmarkMenu()
                self.frameTextCtrl.SetForegroundColour(wx.RED)
                if self.separatevideowindow:
                    self.frameTextCtrl2.SetForegroundColour(wx.RED)

            self.frameTextCtrl.Replace(0, -1, str(frame))
            if self.separatevideowindow:
                self.frameTextCtrl2.Replace(0, -1, str(frame))
            self.videoSlider.Refresh()

        for text in self.recentframes:
            id = wx.NewId()
            self.Bind(wx.EVT_MENU, OnContextMenuItem, id=id)
            menu.Append(id, text)
        # GPo
        if menu.GetMenuItemCount() > 0:
            menu.AppendSeparator()
        # color submenus
        colorMenu = wx.Menu()
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, self.OnMenuVideoSetBookmarkHiligthColor, id=id)
        colorMenu.Append(id, _('bookmark highlight color...'))
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, self.OnMenuVideoSetSelectionHiligthColor, id=id)
        colorMenu.Append(id, _('selection highlight color...'))
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, self.OnMenuVideoSetSplitClipHiligthColor, id=id)
        colorMenu.Append(id, _('split clip highlight color...'))
        menu.AppendMenu(wx.ID_ANY, _('set colors'), colorMenu)
        menu.AppendSeparator()
        #
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnContextMenuBell, id=id)
        menu.Append(id, _('bell at bookmarks'), kind=wx.ITEM_CHECK)
        menu.Check(id, self.bellAtBookmark)
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnContextMenuHilight, id=id)
        menu.Append(id, _('highlight bookmarks'), kind=wx.ITEM_CHECK)
        menu.Check(id, self.videoSlider.hilightBookmarks)
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnContextMenuBookmarkTitle, id=id)
        menu.Append(id, _('Set bookmark title'))
        menu.AppendSeparator()
        #
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnContextMenuCopyTime, id=id)
        menu.Append(id, _('copy as time'))
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnContextMenuCopy, id=id)
        menu.Append(id, _('copy'))
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnContextMenuPaste, id=id)
        menu.Append(id, _('paste'))
        id = wx.NewId()
        self.Bind(wx.EVT_MENU, OnContextMenuClear, id=id)
        menu.Append(id, _('clear history'))
        self.PopupMenu(menu)
        menu.Destroy()

    def OnSliderChanged(self, event):
        if self.playing_video:
            self.PlayPauseVideo()
            self.playing_video = ''
        videoSlider = event.GetEventObject()
        frame = videoSlider.GetValue()
        re = None # GPo new
        if self.options['dragupdate']:
            if not self.separatevideowindow:
                re = self.ShowVideoFrame(frame, adjust_handle=True)
            else:
                if event is not None and event.GetEventObject() in self.videoControlWidgets and self.previewWindowVisible:
                    re = self.ShowVideoFrame(frame, adjust_handle=True, focus=False)
                    self.currentScript.SetFocus()
                else:
                    re = self.ShowVideoFrame(frame, adjust_handle=True)

        if not re: # GPo new, ShowVideoFrame set this values so we not need do set it again
            bms = self.GetBookmarkFrameList()
            if frame in bms:
                color = wx.RED
            else:
                color = wx.BLACK
            self.frameTextCtrl.SetForegroundColour(color)
            self.frameTextCtrl.Replace(0, -1, str(frame))
            if self.separatevideowindow:
                self.frameTextCtrl2.SetForegroundColour(color)
                self.frameTextCtrl2.Replace(0, -1, str(frame))
            self.SetVideoStatusText()

    def OnSliderReleased(self, event):
        self.CheckPlayback()
        videoSlider = event.GetEventObject()
        frame = videoSlider.GetValue()
        if not self.separatevideowindow:
            self.ShowVideoFrame(frame, adjust_handle=videoSlider.adjust_handle)
        else:
            if event is not None and event.GetEventObject() in self.videoControlWidgets and self.previewWindowVisible:
                self.ShowVideoFrame(frame, adjust_handle=videoSlider.adjust_handle, focus=False)
                self.currentScript.SetFocus()
            else:
                self.ShowVideoFrame(frame, adjust_handle=videoSlider.adjust_handle)
        self.videoWindow.SetFocus()
        if self.playing_video == '':
            wx.CallAfter(self.PlayPauseVideo)

    def OnSliderRightUp(self, event):
        slider = event.GetEventObject()
        mousepos = event.GetPosition()
        if slider.HitTestHandle(mousepos):
            frame = slider.GetValue()
            self.AddFrameBookmark(frame)
            self.frameTextCtrl.Refresh()
            color = self.frameTextCtrl.GetForegroundColour()
            if self.separatevideowindow:
                self.frameTextCtrl2.Refresh()
            if color == wx.BLACK and frame in self.titleDict and (event.ControlDown() or event.AltDown() or event.ShiftDown()):
                del self.titleDict[frame]
        else:
            hitlist = slider.HitTestSelection(mousepos)
            previewOK = self.previewOK()
            #~selections = self.GetSliderSelections()
            if hitlist or previewOK:
                if hitlist:
                    start, stop = hitlist[0]
                def OnDummy(event):
                    if previewOK: self.OnMenuVideoInfo()
                    else: wx.MessageBox('AvsPmod %s %s\nGPo @2021 ***live and let live***\n'
                            % (self.version, 'x64' if self.x86_64 else 'x32'))
                def OnTrimEditor(event):
                    if self.trimDialog.IsShown():
                        self.OnTrimDialogCancel(None)
                        return
                    self.OnMenuVideoTrimEditor()
                def OnCreateTrim(event):
                    script = self.currentScript
                    pos = script.FindText(0, script.GetTextLength(), '#SelectedTrims:', stc.STC_FIND_WORDSTART)
                    script.SetSelection(-1, -1)
                    if pos > -1:
                        line = script.LineFromPosition(pos)
                        pos = script.GetLineEndPosition(line)
                        txt = script.GetLine(line)
                        if txt.find('Trim(') > -1:
                            trim = '++Trim(%i, %i)' % (start, stop)
                        else: trim = ' Trim(%i, %i)' % (start, stop)
                        self.InsertText(trim, pos)
                    else:
                        trim = ' Trim(%i, %i)' % (start, stop)
                        self.InsertTextAtScriptEnd('#SelectedTrims: ' + trim)
                    script.Colourise(pos, script.GetTextLength()-pos) # needed for ScriptChanged
                    script.EnsureCaretVisible()
                def OnSplitIntoTrims(event, toClips=False):
                    selections = self.GetSliderSelections()
                    maxStop = self.currentScript.AVI.Framecount-1 if previewOK else self.videoSlider.GetMax()
                    newSel = []
                    start, stop = selections[0]
                    trims = '#TimelineTrims: '
                    if start == 1:
                        newSel.append((0, -1, False))
                    elif start > 1: newSel.append((0, start-1, False))
                    for i in xrange(len(selections)):
                        start, stop = selections[i]
                        if stop > maxStop:
                            trims = '#TimelineTrims (cut selection!): '
                            break
                        newSel.append((start, stop, True))
                        if i < len(selections)-1:
                            nextStart, nextStop = selections[i+1]
                            if nextStart > stop+1:
                                newSel.append((stop+1, nextStart-1, False))
                    if stop < maxStop:
                        newSel.append((stop+1, 0, False))
                    if not newSel: return
                    if toClips:
                        z = sel = 0
                        trims = '/*\n' + trims + '\n'
                        for start, stop, val in newSel:
                            if val:
                                trims += 'c%i=Trim(%i, %i) #sel %i\n' % (z, start, stop, sel)
                                sel += 1
                            else:
                                trims += 'c%i=Trim(%i, %i)\n' % (z, start, stop)
                            z += 1
                        self.InsertTextAtScriptEnd(trims + '*/')
                    else:
                        for start, stop, val in newSel:
                            trims += 'Trim(%i, %i)++' % (start, stop)
                        self.InsertTextAtScriptEnd(trims[:-2])
                def OnSplitIntoClips(event):
                    OnSplitIntoTrims(event=None, toClips=True)
                def OnSelectionsToTrims(event):
                    trims = ''
                    for _start, _stop in self.GetSliderSelections():
                        trims += 'Trim(%i, %i)++' % (_start, _stop)
                    if trims: self.InsertTextAtScriptEnd(trims[:-2])
                def OnSelectionRemove(event):
                    self.DeleteFrameBookmark(start, 1, False, False)
                    self.DeleteFrameBookmark(stop, 2)
                    for slider in self.GetVideoSliderList():
                        slider._Refresh(True)
                def OnSelectionRemoveAll(event):
                    self.DeleteAllSelections()
                def OnSelectionRemoveAllOther(event):
                    for _start, _stop in self.GetSliderSelections():
                        if start == _start and stop == _stop:
                            continue
                        self.DeleteFrameBookmark(_start, 1, False, False)
                        self.DeleteFrameBookmark(_stop, 2, False, False)
                    for slider in self.GetVideoSliderList():
                        slider._Refresh(True)
                def OnSelectApplyFilter(event):
                    obj = event.GetEventObject()
                    key = obj.GetLabel(event.GetId())
                    value = self.options['applyfilters'][key]
                    if value:
                        sel = self.currentScript.GetSelectedText().strip().split('\n')
                        mFunc = ''
                        s = ''
                        copy = value.find('%copy') > -1
                        if copy:
                            value = value.replace('%copy', '')
                        multi = value.find('%>') > -1
                        if multi:
                            previewfilter = value.lstrip().startswith('/**avsp_filter')
                            txt = value.strip().split('\n')
                            for line in txt:
                                if line.startswith('%>'):
                                    mFunc += line[2:].strip() + '\n'
                                elif line.startswith('/**avsp_filter') or line.lstrip().startswith('**/'):
                                    continue
                                elif line.strip():
                                    s += line + '\n'
                            if sel and not s: # only one filter selected
                                if sel[0].startswith('#'):
                                    sel[0] = sel[0][1:]
                                pos = sel[0].find('#')
                                if pos > -1:
                                    sel[0] = sel[0][:pos]
                                mFunc = mFunc.replace('%*', sel[0].strip()).strip()
                            else:
                                mFunc = mFunc.strip()
                        else:
                            s = value.replace('%start', str(start)).replace('%stop', str(stop))
                        if sel:
                            sep = value.find('%join') > -1
                            if sep and sel[0].startswith('#'): # if join first filter should not be disabled
                                wx.MessageBox(_('On join filters, the first line must not begin with') + ' #',_('Error'))
                                return
                            if len(sel) == 1 and sel[0].strip().startswith('#'): # enable and remove comment if one filter selected
                                sel[0] = sel[0][1:].strip()
                            pos = sel[0].find('#')
                            if pos > 0: sel[0] = sel[0][:pos] # remove comment from line end
                            newSel = []
                            newSel.append(sel[0] + '\n')
                            if len(sel) > 1:
                                for i in xrange(1, len(sel)):
                                    if sel[i].strip() and not sel[i].lstrip().startswith('#'):
                                        pos = sel[i].find('#') # find comment at line end ( my way )
                                        if pos < 0: pos = len(sel[i]) # if not found set line len
                                        if sep and not sel[i].lstrip().startswith('\.'):
                                            newSel.append('\.' + sel[i][:pos].strip() + '\n')
                                        else: newSel.append(sel[i][:pos].strip() + '\n')
                            if s:
                                s = s.replace('%*', ''.join(newSel).strip()).replace('%join', '')
                        s = s.strip()
                        if multi:
                            if previewfilter:
                                s = '/**avsp_filter\n' + s
                            for _start, _stop in self.GetSliderSelections():
                                s += '\n' + mFunc.replace('%start', str(_start)).replace('%stop', str(_stop))
                            if previewfilter:
                                s += '\n**/'
                        if copy: self.InsertTextAtScriptEnd(s)
                        else: self.InsertText(s, None)
                        return
                    wx.Bell()
                menuInfo = []
                if hitlist:
                    def createFiltersMenu():
                        menu = wx.Menu()
                        for key in sorted(self.options['applyfilters'], key=lambda k: k.lower()):
                        #for key in sorted(self.options['applyfilters']):
                            id = wx.NewId()
                            self.Bind(wx.EVT_MENU, OnSelectApplyFilter, id=id)
                            menu.Append(id, key)
                        return menu
                    fmenu = createFiltersMenu()
                    menuInfo = [
                        (_('Frames: %i') % (stop-start), '', OnDummy, ''),
                        ('%i-%i' % (start, stop), '', OnDummy, ''),
                        (''),
                        (_('Apply filter'), fmenu, -1, ''),
                        (''),
                        (_('All as trim'), '', OnSelectionsToTrims, ''),
                        (_('Add as trim'), '', OnCreateTrim, ''),
                        (''),
                        (_('Timeline to trims'), '', OnSplitIntoTrims, ''),
                        (_('Timeline to clips'), '', OnSplitIntoClips, ''),
                        (''),
                        (_('Remove'), '', OnSelectionRemove, ''),
                        (_('Remove all'), '', OnSelectionRemoveAll, ''),
                        (_('Remove all other'), '', OnSelectionRemoveAllOther, ''),
                        ]
                if previewOK:
                    if hitlist:
                        menuInfo += [_(''),]
                    #~elif selections:
                        #~menuInfo = [(_('Remove all'), '', OnSelectionRemoveAll, ''),]
                    menuInfo += [
                        (_('Trim editor...'), '', OnTrimEditor, ''),
                    ]
                popup = self.createMenu(menuInfo)
                self.PopupMenu(popup)
                popup.Destroy()
        event.Skip()

    def OnSliderMiddleDown(self, event):
        slider = event.GetEventObject()
        mousepos = event.GetPosition()
        index = slider.HitTestBookmark(mousepos)
        if index is not None:
            if index in slider.selectionsDict:
                bmtype = slider.selectionsDict[index]
            elif index in slider.GetBookmarks():
                bmtype = 0
            else:
                return
            #~if isinstance(bmtype, basestring):
                #bmtype = 0
            self.DeleteFrameBookmark(index, bmtype)
            if (bmtype == 0) and index in self.titleDict:
                del self.titleDict[index]
            self.frameTextCtrl.SetForegroundColour(wx.BLACK)
            self.frameTextCtrl.Refresh()
            if self.separatevideowindow:
                self.frameTextCtrl2.SetForegroundColour(wx.BLACK)
                self.frameTextCtrl2.Refresh()

    def OnSliderLeftUp(self, event):
        slider = event.GetEventObject()
        mousepos = event.GetPosition()
        # If clicked on a selection button, create the selection bookmark
        bmtype = slider.HitTestSelectionButton(mousepos)
        if bmtype is not None:
            value = self.GetFrameNumber()
            self.AddFrameBookmark(value, bmtype)
        event.Skip()

    def OnPreviouslySelectedTab(self, event):
        idx = self.oldTabIndex
        count = self.scriptNotebook.GetPageCount()
        if isinstance(idx, int) and (idx < count) and (idx != self.scriptNotebook.GetSelection()):
            self.SelectTab(idx)
            return
        wx.Bell()

    def SaveZoom(self, script=None):
        if script is None:
            script = self.currentScript
        if not self.previewOK(script):
            return
        xy = self.videoWindow.GetViewStart()
        if xy is None:
            xy = wx.Point(0,0)
        script.lastZoom = (
            xy, self.zoomfactor,
            self.zoomwindow if not self.resizeFilter[0] else False,
            self.zoomwindowfill if not self.resizeFilter[0] else False,
            self.zoomwindowfit if not self.resizeFilter[0] else False
            )

    def OnNotebookPageChanged(self, event):

        def SetBookmarks():
            if self.tabChangeLoadBookmarks:
                c = self.OnMenuBookmarksFromScript()
                if c <= 0:
                    self.SetTabBookmarks(self.currentScript.bookmarks)
                self.SetSelectionsDict(self.currentScript.selections) # set selections
            return True

        def UpdateMenus(script):
            self.UpdateScriptTabname(script)
            matrix = script.matrix[0]
            level = _(script.matrix[1].upper() + ' levels')
            if matrix == 'auto':
                matrix = _('Resolution-based')
            else:
                matrix = _('BT.' + matrix)
            self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), matrix])
            self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), level])

        def Error():
            if self.previewWindowVisible:
                self.HidePreviewWindow()
            self.ClipRefreshPainter = False
            SetBookmarks()
            self.splitView = False
            self.playing_video = False
            UpdateMenus(script)
            if self.readFrameProps:
                self.AVICallBack(ident='property', value='Error',
                    framenr=script.lastFramenum if script.lastFramenum else -1)

        if self.scriptNotebook.LockPage:
            self.currentScript = self.scriptNotebook.GetPage(event.GetSelection())
            #SetBookmarks()
            return

        # Get the newly selected script
        currIndex = event.GetSelection()
        self.oldTabIndex = event.GetOldSelection()
        script = self.scriptNotebook.GetPage(currIndex)
        self.currentScript = script

        if self.propWindowParent > 0: # shown in slider window
            self.propWindow.textCtrl.Reparent(script.sliderWindow)
            script.sliderWindow.Freeze()
            script.propertySizer.Layout()
            #if self.propWindowParent == 1:
                #script.videoSidebarSizer.Layout()
            script.sliderWindow.FitInside()
            self.TryThaw(script.sliderWindow)

        self.refreshAVI = True
        self.currentScript.refreshAVI = True
        self.snapShotIdx = 0

        # Check split View
        if self.splitView:
            if self.oldTabIndex >= 0 and self.oldTabIndex != currIndex:
                if self.splitView_next:
                    if currIndex == self.oldTabIndex + 1:
                        self.splitView_next = False
                    else:
                        self.splitView = False
                else:
                    if currIndex == self.oldTabIndex - 1:
                        self.splitView_next = True
                    else:
                        self.splitView = False
            else:
                self.splitView = False

        # SplitClipCtrl
        if script.AVI:
            if self.SplitClipCtrl.IsActive and not script.AVI.IsSplitClip:
                self.SplitClipCtrl.Close()
            elif script.AVI.IsSplitClip and not self.SplitClipCtrl.IsActive:
                self.SplitClipCtrl.Activate()
        else:
            if self.SplitClipCtrl.IsActive:
                self.SplitClipCtrl.Close()

        self.SetPreviewFilterMenus(script.previewFilterIdx) # GPo, set the filter menu item index
        oldSliderWindow = self.currentSliderWindow
        newSliderWindow = script.sliderWindow
        oldSliderWindow.Hide()
        self.currentSliderWindow = newSliderWindow

        if self.AviThread_Running(script):
            Error()
            return False

        # Set some related key variables (affects other functions)
        bmSet = False # bookmarks not set, its nicer to set bookmarks after show frame
        boolNewAvi = False

        if self.options['tabautopreview']:
            if self.previewWindowVisible and script.AVI is None:
                self.HidePreviewWindow()

        if not self.options['resizevideowindow']:
            if self.oldLastSplitVideoPos is not None: # eg. IsErrorClip()
                script.lastSplitVideoPos = self.oldLastSplitVideoPos
        else: # check if full size, if so then set the splitter
            ps = self.mainSplitter.GetMinimumPaneSize()
            if ps < intPPI(30):
                self.mainSplitter.SetSashPosition(ps, redraw=False)
                self.SaveLastSplitVideoPos()
            else:
                script.lastSplitVideoPos = None

        resize_need_refresh = False
        if script.resizeFilter[0]:
            if script.resizeFilter[2] == 1 and script.AVI and script.AVI.resizeFilter and not self.splitView:
                try:
                    f, dw, dh, aw, ah = self.CalcResizeFilter(script, fitHeight=script.resizeFilter[3])
                except:
                    pass
                else:
                    if (script.AVI.DisplayWidth, script.AVI.DisplayHeight) != (dw,dh):
                        script.display_clip_refresh_needed = True
                        resize_need_refresh = True

        # Determine whether to hide the preview or not
        if self.previewWindowVisible:
            boolNewAvi = self.UpdateScriptAVI(script, forceRefresh=False, prompt=True)
            if boolNewAvi is None:
                Error()
                return False
            if not self.previewOK():
                self.OnMenuVideoZoom(zoomfactor=1,script=script)
                resize_need_refresh = False
            if ((script.AVI.DisplayWidth, script.AVI.DisplayHeight) == self.oldDisplayVideoSize):
                boolSliders = bool(script.sliderTexts or script.sliderProperties or script.toggleTags or script.autoSliderInfo)
                if boolSliders and self.oldBoolSliders:
                    if self.oldSliderWindowShown != script.sliderWindowShown:
                        script.sliderWindowShown = self.oldSliderWindowShown
                    if self.oldSliderWindowShown is True and script.sliderWindowShown is True:
                        script.lastSplitSliderPos = self.oldLastSplitSliderPos
                if not self.splitView:
                    if script.group == self.oldGroup is None and script.AVI.Framecount == self.videoSlider.GetMax()+1 and self.options['enableframepertab']:
                        script.lastFramenum = None

            if script.group is not None and script.group == self.oldGroup:
                script.lastSplitVideoPos = self.oldLastSplitVideoPos
                if self.options['applygroupoffsets'] or (self.splitView and self.splitView_freeze):
                    offset = script.group_frame - self.oldGroupFrame
                    script.lastFramenum = max(0, self.oldLastFramenum + offset)
                    # GPo new 'self.tabChangeLoadBookmarks' do not offset bookmarks if autoload bookmarks enabled
                    if self.options['offsetbookmarks'] and not self.tabChangeLoadBookmarks:
                        bmSet = SetBookmarks() # set bookmarks befor offset
                        self.OffsetBookmarks(offset)
                else:
                    script.lastFramenum = None
            elif not self.splitView:
                if script.group == self.oldGroup is None and self.options['enableframepertab'] and not self.options['enableframepertab_same']:
                    script.lastFramenum = None

            # GPo, reset video zoom and pos
            videoXY = None
            self.forceZoom = False
            if self.saveViewPos > 0 and script.lastZoom is not None:
                #~if script.lastFramenum is not None: # not in group (changed: group will also restore the last zoom and pos)
                self.forceZoom = True # ShowVideoFrame read and reset it

            if not bmSet:
                bmSet = SetBookmarks()
            self.zoom_antialias = False
            # do not disable the 'ClipRefreshPainter' after a new clip has been created
            # if no new clip is created the 'ClipRefreshPainter' is False
            # disableRefreshPainter must only be set if UpdateScriptAvi called bevor ShowVideoFrame is called
            self.ShowVideoFrame(script.lastFramenum, forceLayout=True, focus=False, scroll=videoXY, forceCursor=True,
                                forceThread=self.UseAviThread)
            if self.separatevideowindow:
                self.videoDialog.Refresh()
                self.videoDialog.Update()

            if not script.sliderWindowShown:
                self.HideSliderWindow(script, vidrefresh=False)
            else:
                newSliderWindow.Show()
                self.ShowSliderWindow(script, vidrefresh=False)

        else: # Update slider position and frame text control
            if self.saveViewPos > 0 and script.lastZoom and not self.splitView:
                self.forceZoom = True
            else:
                self.forceZoom = False

            bmSet = SetBookmarks()
            frame = script.lastFramenum
            if frame is not None:
                bms = self.GetBookmarkFrameList()
                if frame in bms:
                    color = wx.RED
                else:
                    color = wx.BLACK
                self.frameTextCtrl.SetForegroundColour(color)
                self.frameTextCtrl.Replace(0, -1, str(frame))
                if self.separatevideowindow:
                    self.frameTextCtrl2.SetForegroundColour(color)
                    self.frameTextCtrl2.Replace(0, -1, str(frame))

                if script.lastLength is not None:
                    # the new
                    if self.timelineAutoReset or not self.videoSlider.offsetSet or (script.lastLength < 50):
                        for slider in self.GetVideoSliderList():
                            slider.SetRange(0, script.lastLength - 1, refresh=False)
                            slider.SetOffset(0, 0)
                        self.timelineRange = 0
                        self.videoSlider.SetValue(frame)
                    else:
                        # set the new center for the slider range (if autoScroll) and update the slider position
                        if self.videoSlider.offsetSet and self.videoSlider.GetVirtualMax() < frame \
                            or self.videoSlider.startOffset > frame:
                            if self.timelineAutoScroll:
                                self.OnMenuSetTimeLineRange(frange=self.timelineRange, r_center=frame, r_maxrange=script.lastLength)
                            else:
                                # if not autoScroll set the min and max allowed frame nr
                                frame = min(frame, self.videoSlider.startOffset + script.lastLength)
                                frame = max(frame, self.videoSlider.startOffset)
                                self.videoSlider.SetValue(frame)
                        else:
                            self.videoSlider.SetValue(frame)
                elif frame == 0:
                    self.videoSlider.SetValue(0)

        # Misc
        self.SetVideoStatusText()
        self.ClipRefreshPainter = False
        if self.previewWindowVisible and self.boolVideoWindowFocused:
            self.videoWindow.SetFocus()
            # GPo
            if self.showVideoPixelInfo:
                if self.videoWindow.GetClientRect().Inside(self.videoWindow.ScreenToClient(wx.GetMousePosition())):
                    pixelInfo = self.GetPixelInfo(None, string_=True)
                    if pixelInfo[1] != None:
                        self.SetVideoStatusText(addon=pixelInfo)

        elif self.findDialog.IsShown():
            self.findDialog.SetFocus()
        elif self.replaceDialog.IsShown():
            self.replaceDialog.SetFocus()
        else:
            script.SetFocus()

        self.oldlinenum = None

        if script.resizeFilter[0]:
            if script.resizeFilter[2] == 1 and script.AVI and script.AVI.resizeFilter and not self.splitView:
                try:
                    f, dw, dh, aw, ah = self.CalcResizeFilter(script, fitHeight=script.resizeFilter[3])
                except:
                    pass
                else:
                    if (script.AVI.DisplayWidth, script.AVI.DisplayHeight) != (dw,dh):
                        dw = dh = 0
                        script.display_clip_refresh_needed = True
                        resize_need_refresh = True

        UpdateMenus(script)

        if self.previewWindowVisible:
            if resize_need_refresh and (script.AVI.DisplayWidth, script.AVI.DisplayHeight) != (dw,dh):
                script.display_clip_refresh_needed = True
                self.ShowVideoFrame()

            self.ResetZoomAntialias()
            if boolNewAvi:
                self.ShowFreeMemory()
        else:
            if self.readFrameProps:
                if self.previewOK():
                    self.AVICallBack(ident='property', value=script.AVI.properties, framenr=-1)
                else:
                    self.AVICallBack(ident='property', value='', framenr=self.GetFrameNumber())
            self.zoom_antialias = self.options['zoom_antialias']


    def OnNotebookPageChanging(self, event):
        def resetViewPos():
            self.currentScript.lastZoom = None

        if self.playing_video:
            self.StopPlayback()

        if self.cropDialog.IsShown():
            wx.MessageBox(_('Cannot switch tabs while crop editor is open!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            event.Veto()
            return
        if self.trimDialog.IsShown():
            wx.MessageBox(_('Cannot switch tabs while trim editor is open!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            event.Veto() # Not enough, we have to return or bookmarks and other things go wrong
            return

        if self.FindFocus() == self.videoWindow:
            self.boolVideoWindowFocused = True
        else:
            self.boolVideoWindowFocused = False

        oldSelectionIndex = event.GetOldSelection()
        if oldSelectionIndex >= 0:
            oldScript = self.scriptNotebook.GetPage(oldSelectionIndex)
            self.oldLastFramenum = oldScript.lastFramenum
            self.oldGroup = oldScript.group
            self.oldGroupFrame = oldScript.group_frame
            if self.tabChangeLoadBookmarks:
                oldScript.bookmarks = None
                oldScript.bookmarks = self.GetBookmarkDict()

        if self.tabChangeLoadBookmarks:
            self.DeleteAllFrameBookmarks(bmtype=0) # GPo new

        if self.previewWindowVisible:
            if oldSelectionIndex >= 0:
                if oldScript.lastSplitVideoPos is not None:
                    self.oldLastSplitVideoPos = oldScript.lastSplitVideoPos
                else:
                    self.oldLastSplitVideoPos = self.SaveLastSplitVideoPos() # GPo 2020
                oldScript.lastSplitVideoPosShown = self.oldLastSplitVideoPos

                self.oldLastSplitSliderPos = oldScript.lastSplitSliderPos
                self.oldSliderWindowShown = oldScript.sliderWindowShown
                self.oldBoolSliders = bool(oldScript.sliderTexts or oldScript.sliderProperties or oldScript.toggleTags or oldScript.autoSliderInfo)
                try:
                    self.oldDisplayVideoSize = (oldScript.AVI.DisplayWidth, oldScript.AVI.DisplayHeight)
                except:
                    self.oldDisplayVideoSize = (None, None)
                # save zoom
                self.SaveZoom(oldScript)
            else:
                self.oldLastSplitVideoPos = None
                self.oldSliderWindowShown = None
                self.oldLastSplitSliderPos = None
                self.oldBoolSliders = None
                self.oldDisplayVideoSize = (None, None)
                resetViewPos() # GPo new

        elif oldSelectionIndex >= 0:
            # test new 24.11
            if oldScript.lastSplitVideoPos is not None:
                self.oldLastSplitVideoPos = oldScript.lastSplitVideoPos
            else:
                self.oldLastSplitVideoPos = self.SaveLastSplitVideoPos() # GPo 2020
            ###
            if self.splitView or not oldScript.AVI:
                resetViewPos()
            """
            if oldScript.AVI and not self.splitView:
                if (self.oldWidth != int(oldScript.AVI.DisplayWidth * self.zoomfactor)) or \
                   (self.oldHeight != int(oldScript.AVI.DisplayHeight * self.zoomfactor)):
                    resetViewPos()
            else: resetViewPos()
            """
        else:
            resetViewPos()

    def OnMiddleDownNotebook(self, event):
        ipage = self.scriptNotebook.HitTest(event.GetPosition())[0]
        if ipage != wx.NOT_FOUND:
            self.CloseTab(ipage, prompt=True)
        else: # for wxGTK
            self.UndoCloseTab()

    def OnLeftDownNotebook(self, event):
        self.scriptNotebook.dragging = False
        self.scriptNotebook.oldpage = self.scriptNotebook.GetSelection()
        event.Skip()

    def OnLeftUpNotebook(self, event):
        if self.scriptNotebook.dragging or self.scriptNotebook.dragging is None:
            self.scriptNotebook.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
            if self.scriptNotebook.dragging is None:
                return
            if not self.scriptNotebook.dblClicked:
                index = self.scriptNotebook.GetSelection()
                ipage = self.scriptNotebook.HitTest(event.GetPosition())[0]
                if ipage != wx.NOT_FOUND and ipage != index and index == self.scriptNotebook.oldpage: # GPo, if multiline selection index changed!
                    self.RepositionTab(ipage)
            else:
                wx.CallLater(300, setattr, self.scriptNotebook, 'dblClicked' ,False)
        else:
            pos = event.GetPosition()
            ipage = self.scriptNotebook.HitTest(pos)[0]
            if ipage == self.scriptNotebook.oldpage:
                wx.CallLater(300, self.OnMenuFileRenameTab, ipage, pos)
        self.scriptNotebook.oldpage = None
        event.Skip()

    def OnLeftDClickNotebook(self, event):
        if self.titleEntry:
            return
        self.scriptNotebook.dblClicked = True
        ipage = self.scriptNotebook.HitTest(event.GetPosition())[0]
        if ipage != wx.NOT_FOUND:
            self.NewTab(copytab=True)
        else: # for wxGTK
            self.NewTab()

    def OnRightClickNotebook(self, event):
        win = event.GetEventObject()
        pos = event.GetPosition()
        ipage = self.scriptNotebook.HitTest(pos)[0]
        if ipage != wx.NOT_FOUND:
            script, index = self.getScriptAtIndex(ipage)
            if not self.previewOK(script) and self.previewWindowVisible: # GPo, new
                self.HidePreviewWindow()
            try:
                menu = win.contextMenu
                self.scriptNotebook.SetSelection(index)
                # group
                group_menu = menu.FindItemById(menu.FindItem(_('Group'))).GetSubMenu()
                group = script.group
                if group is None:
                    group = _('None')
                id = group_menu.FindItem(group)
                group_menu.Check(id, True)
                id = group_menu.FindItem(_('Apply offsets'))
                group_menu.Check(id, self.options['applygroupoffsets'])
                id = group_menu.FindItem(_('Offset also bookmarks'))
                group_menu.Check(id, self.options['offsetbookmarks'])
                id = group_menu.FindItem(_('Freeze Split View frame'))
                group_menu.Check(id, self.splitView_freeze)
                # reposition
                menuItem = menu.FindItemByPosition(menu.GetMenuItemCount()-1)
                menu2 = menuItem.GetSubMenu()
                for i in range(menu2.GetMenuItemCount()):
                    menu2.DestroyItem(menu2.FindItemByPosition(0))
                for i in range(self.scriptNotebook.GetPageCount()):
                    label = self.scriptNotebook.GetPageText(i)
                    menuItem = menu2.Insert(i, wx.ID_ANY, label)
                    if i != index:
                        self.Bind(wx.EVT_MENU, self.RepositionTab, menuItem)
                    else:
                        menuItem.Enable(False)
                # GPo
                item = menu.FindItemById(menu.FindItem(_('Save view pos on tab change')))
                if item:
                    item.Check(self.saveViewPos==1)
                item = menu.FindItemById(menu.FindItem(_('Save pos && zoom on tab change')))
                if item:
                    item.Check(self.saveViewPos==2)
                item = menu.FindItemById(menu.FindItem(_('Resize video window')))
                if item:
                    item.Check(self.options['resizevideowindow'])
                item = menu.FindItemById(menu.FindItem(_('Auto preview')))
                if item:
                    item.Check(self.options['tabautopreview'])
                item = menu.FindItemById(menu.FindItem(_('Tab change loads bookmarks')))
                if item:
                    item.Check(self.tabChangeLoadBookmarks)

                win.PopupMenu(win.contextMenu, pos)
            except AttributeError:
                pass

    def OnGroupApplyOffsets(self, event):
        self.options['applygroupoffsets'] = not self.options['applygroupoffsets']
        if self.splitView and self.previewWindowVisible:
            self.videoWindow.Refresh()

    def OnGroupOffsetBookmarks(self, event):
        self.options['offsetbookmarks'] = not self.options['offsetbookmarks']
        if self.options['offsetbookmarks'] and self.tabChangeLoadBookmarks:
            self.tabChangeLoadBookmarks = False
            wx.MessageBox(_("'Tab change load bookmarks' has been switched off, otherwise undefined assignments will occur"))

    def OnGroupClearTabGroup(self, event=None, group=None):
        if group is None:
            group = self.currentScript.group
            if group is None:
                return
        for index in xrange(self.scriptNotebook.GetPageCount()):
            script = self.scriptNotebook.GetPage(index)
            if script.group == group:
                self.AssignTabGroup(None, index)
        if self.splitView and self.previewWindowVisible:
            self.videoWindow.Refresh()

    def OnGroupClearAllTabGroups(self, event):
        for index in xrange(self.scriptNotebook.GetPageCount()):
            self.AssignTabGroup(None, index)
        if self.splitView and self.previewWindowVisible:
            self.videoWindow.Refresh()

    def OnGroupAssignTabGroup(self, event):
        id = event.GetId()
        context_menu = event.GetEventObject()
        group_menu = context_menu.FindItemById(context_menu.FindItem(_('Group'))).GetSubMenu()
        label = group_menu.FindItemById(id).GetLabel()
        self.AssignTabGroup(label)
        if self.splitView:
            self.options['applygroupoffsets'] = True
            index = self.scriptNotebook.GetSelection()
            index = index+1 if self.splitView_next else index-1
            if index >- 1 and index < self.scriptNotebook.GetPageCount():
                self.AssignTabGroup(label, index)
                if label != _('None'):
                    self.splitView_freeze = False # auto disable freeze state
                if self.previewWindowVisible and label == _('None'):
                    self.videoWindow.Refresh()

    def AssignTabGroup(self, group, index=None):
        if group == _('None'):
            group = None
        current_tab = self.scriptNotebook.GetSelection()
        if index is None:
            index = current_tab
        script = self.scriptNotebook.GetPage(index)
        script.group = group
        script.group_frame = script.lastFramenum
        self.UpdateScriptTabname(index=index)

    def OnMouseMotionNotebook(self, event):
        if event.Dragging() and event.LeftIsDown():
            if self.titleEntry:
                self.scriptNotebook.SetFocus()
            index = self.scriptNotebook.GetSelection()
            ipage = self.scriptNotebook.HitTest(event.GetPosition())[0]
            self.scriptNotebook.dragging = True if index != ipage else None
            if ipage != wx.NOT_FOUND:
                self.scriptNotebook.SetCursor(wx.CursorFromImage(dragdrop_cursor.GetImage()))
            else:
                self.scriptNotebook.SetCursor(wx.StockCursor(wx.CURSOR_NO_ENTRY))
        else:
            self.scriptNotebook.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))

    def OnMouseWheelNotebook(self, event):
        event.Skip()
        '''Rotate between tabs'''
        rotation = event.GetWheelRotation()
        if self.mouse_wheel_rotation * rotation < 0:
            self.mouse_wheel_rotation = rotation
        else:
            self.mouse_wheel_rotation += rotation
        if abs(self.mouse_wheel_rotation) >= event.GetWheelDelta():
            inc = 1 if self.mouse_wheel_rotation > 0 else -1
            if self.options['invertscrolling']: inc = -inc
            if self.options['tabautopreview']:
                new,idx = self.AutoPreviewGetNextPageIndex(inc < 0)
                if new:
                    self.SelectTab(idx)
            else:
                self.SelectTab(inc=inc)
            self.mouse_wheel_rotation = 0

    def OnNotebookContextMenu(self, event):
        event.Skip()

    # Multible procceses (bool/number/scroll) can it used with a key event by setting the rotation direction
    def OnMouseWheelScriptWindow(self, event=None, rotation=None, dec_first=False):

        def FindPreviewFilterByLineIdx(idx):
            for key in self.previewFilterDict.keys():
                pos = self.previewFilterDict[key][2]  # line start and line end position
                if pos[1] > idx and pos[0] < idx:
                    return key
        if event:
            ctrl = event.GetEventObject() # same as self.currentScript
            rotation = event.GetWheelRotation()
        else:
            ctrl = self.currentScript
            if rotation is None:
                return

        control = wx.GetKeyState(wx.WXK_CONTROL)
        shift = wx.GetKeyState(wx.WXK_SHIFT)

        # check is custom process
        if self.options['numberwheel'] and ctrl.GetSelectionEnd() > ctrl.GetSelectionStart():
            amount = 1 if control and not shift else 5 if shift and not control else 10 if control and shift else 1 if ctrl.IsDClicked else 0
        else:
            amount = 0
        if amount > 0:
            s = ''
            word = ctrl.GetSelectedText()
            if not word.strip() or len(word) > 40:
                return
            selstart = ctrl.GetSelectionStart()
            selend = ctrl.GetSelectionEnd()
            set_start = set_end = None

            # true/false
            if word.lower() == 'true':
                s = 'False' if word[0].isupper() else 'false'
            elif word.lower() == 'false':
                s = 'True' if word[0].isupper() else 'true'
            if s:
                set_start, set_end = selstart, selstart + len(s)
            # numbers
            else:
                # search for the first digit and move selstart
                if not word[0].isdigit():
                    i = 0
                    while not word[i].isdigit() and i < len(word)-1:
                        selstart += 1
                        i += 1
                        if (i > 20) or (selstart > selend - 1):
                            return

                # expand or cut selend
                i = len(word) - 1
                if not word[i].isdigit():
                    while (i > 0) and not word[i].isdigit():
                        selend -= 1
                        i -= 1
                else:
                    if unichr(ctrl.GetCharAt(selend)).isdigit():
                        while selend < ctrl.GetLength()-2 and unichr(ctrl.GetCharAt(selend)).isdigit():
                            selend += 1
                # expand selstart
                i = selend-1
                isDec = False
                while i > 0:
                    ch = unichr(ctrl.GetCharAt(i))
                    if not ch.isdigit() and not ch in ('.', ' '):
                        break
                    i -= 1
                    if ch == '.':
                        if isDec: # exit on double decimal point (user fault)
                            wx.Bell()
                            return
                        isDec = selstart > i
                        dec_len = selend - i - 2
                selstart = i
                # get now the range and remove all spaces
                word = ctrl.GetTextRange(selstart, selend).replace(' ', '')
                try:
                    # restore the start position of the first digit or negative notation
                    i = selstart + 1
                    while unichr(ctrl.GetCharAt(i)) == ' ':
                        i += 1
                        selstart += 1
                    # if negative notation not found inc selstart
                    if word[0] != '-':
                        selstart += 1
                        word = word[1:]
                except:
                    return
                # process only the decimal part if the selection the decimal part
                if isDec:
                    try:
                        f = float(word)
                        if dec_len < 1:
                            return
                    except:
                        return

                    if self.options['numberwheelfaster']:
                        amount = 2 if control else 5 if shift else 1
                        n = '.' + str(amount)
                    else:
                        n = '.'
                        if dec_first:
                            n = n + '0' + str(amount) if amount < 10 else n + '1'
                        else:
                            if amount < 10:
                                while len(n) < dec_len:
                                    n += '0'
                                n = n + str(amount)
                            else:
                                while len(n) < dec_len -1:
                                    n += '0'
                                n = n + '1'

                    if dec_len < 9:
                        dformat = '%.' + str(dec_len) + 'f'
                        s = dformat % (float(word) + float(n) if rotation > 0 else float(word) - float(n))
                    else:
                        s = str(float(word) + float(n) if rotation > 0 else float(word) - float(n))
                    pos = s.find('.')
                    if pos < 0:
                        return
                    set_start = selstart + pos + 1
                    set_end = set_start + len(s[pos+1:])
                else:
                    L = word.split('.')
                    word = L[0]
                    if not word.lstrip('-').isdigit():
                        return
                    #if self.options['numberwheelfaster']:
                        #amount = 10 if control else 20 if shift  else 5
                    s = str(int(word) + amount if rotation > 0 else int(word) -amount)
                    if len(L) > 1:
                        s += '.' + L[1]
                    set_start = selstart
                    set_end = selstart + len(s)

            if s and set_start:
                if ctrl.previewFilterIdx > 0:
                    prevFilteridx = FindPreviewFilterByLineIdx(ctrl.LineFromPosition(selstart))
                    if prevFilteridx == ctrl.previewFilterIdx:
                        func = (self.OnMenuPreviewFilter, tuple(), {'index': prevFilteridx, 'focus': False})
                        if not func in self.IdleCall:
                            ctrl.SetSelection(selstart, selend)
                            ctrl.ReplaceSelection(s)
                            ctrl.SetSelection(set_start, set_end)
                            ctrl.Update()
                            self.IdleCall.append(func)
                        return
                # if not preview filter
                ctrl.refreshAVI = True
                ctrl.SetSelection(selstart, selend)
                ctrl.ReplaceSelection(s)
                ctrl.SetSelection(set_start, set_end)
            return
        # if not number process, check for custom scroll
        lc = self.options['scriptwindowbindmousewheel']
        if lc > 0:
            if control:
                lc = lc*2
            if rotation > 0:
                ctrl.LineScroll(columns=0, lines=-lc)
            elif rotation < 0:
                ctrl.LineScroll(columns=0, lines=lc)
            return
        # else force default scroll
        if event:
            event.Skip()

    def OnLeftDClickWindow(self, event):
        script = self.currentScript
        x, y = event.GetPosition()
        if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
            new_tab = y < self.currentScript.GetPosition().y
            pos = y
        else:
            new_tab = y < script.GetPosition().y and \
                      x < script.GetSize().width
            pos = x
        if new_tab: # event not received on wxGTK
            self.NewTab()
        elif self.previewWindowVisible and not self.separatevideowindow:
            # self.mainSplitter is clicked
            if script.resizeFilter[0] and script.resizeFilter[2] == 1: # fit, fill
                return
            lo = self.mainSplitter.GetSashPosition()
            hi = lo + self.mainSplitter.GetSashSize()
            if lo <= pos <= hi and self.mainSplitter.IsSplit():
                self.SetMinimumScriptPaneSize()
                if not self.zoomwindow:
                    self.zoom_antialias = False
                    self.Freeze()
                    try:
                        self.LayoutVideoWindows(forcefit=True)
                    finally:
                        self.TryThaw(self)
                        self.ResetZoomAntialias(True)
                else:
                    self.LayoutVideoWindows(forcefit=True)
                    self.ShowVideoFrame()

    def OnMiddleDownWindow(self, event):
        x, y = event.GetPosition()
        if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
            if y < self.currentScript.GetPosition().y: # event not received on wxGTK
                self.UndoCloseTab()
        else:
            if y < self.currentScript.GetPosition().y and \
               x < self.currentScript.GetSize().width:
                self.UndoCloseTab()
        event.Skip()

    def OnLeftDClickVideoSplitter(self, event):
        pos = self.currentScript.videoSidebarSizer.CalcMin()[0] + 6
        self.videoSplitter.SetSashPosition(-pos)
        self.currentScript.lastSplitSliderPos = self.videoSplitter.GetSashPosition()

    def OnMiddleDownScriptWindow(self, event):
        script = self.currentScript
        if script.IsDClicked:
            sel = script.GetSelectedText()
            if sel.isdigit() or sel.lower() in ('true', 'false'):
                return
            script.IsDClicked = False
        if (self.options['middlemousefunc'] != 'show video frame') or (self.currentScript.GetTextLength() < 6):
            xypos = event.GetPosition()
            script.GotoPos(script.PositionFromPoint(xypos))
        self.middleDownScript = True # leave it! else OnMiddleUp failed (script window > video window)

    def OnMiddleUpScriptWindow(self, event):
        if self.currentScript.IsDClicked:
            self.options['numberwheelfaster'] = not self.options['numberwheelfaster']
            self.StatusbarTimer_Start(ms=500, txt='Number wheel faster: %s' % str(self.options['numberwheelfaster']))
            return
        if self.middleDownScript:
            self.middleDownScript = False
            if (self.options['middlemousefunc'] == 'show video frame') and (self.currentScript.GetTextLength() > 5):
                forceRefresh = self.ScriptChanged() or not self.previewOK()
                self.ShowVideoFrame_CheckPreview(forceRefresh=forceRefresh)
            else:
                self.InsertSource()

    def OnKeyDownVideoWindow(self, event):
        self.KeyUpVideoWndow = False
        key = event.GetKeyCode()
        if key in (wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER):
            if event.ShiftDown():
                if not self.AviThread_Running(self.currentScript, False):
                    self.ShowVideoFrame(self.GetFrameNumber(), forceCursor=True)
            elif self.cropDialog.IsShown():
                self.OnCropDialogApply(None)
            elif self.trimDialog.IsShown():
                self.OnTrimDialogApply(None)
            else:
                #~event.Skip()
                if not self.AviThread_Running(self.currentScript, False):
                    frame = self.currentframenum if event.ControlDown() else self.GetFrameNumber()
                    self.ShowVideoFrame(frame, forceCursor=True)
                else: event.Skip()
        elif key == wx.WXK_ESCAPE:
            if self.cropDialog.IsShown():
                self.OnCropDialogCancel(None)
            elif self.trimDialog.IsShown():
                self.OnTrimDialogCancel(None)
            else:
                event.Skip()
        elif key >= wx.WXK_NUMPAD0 and key <= wx.WXK_NUMPAD9:
            i = (key - wx.WXK_NUMPAD1 + 10) % 10
            self.SelectTab(index=i)
        elif key >= ord('0') and key <= ord('9'):
            i = (key - ord('1') + 10) % 10
            self.SelectTab(index=i)
        elif self.timelineRange > 0 and event.AltDown() and event.ControlDown():
            if key == wx.WXK_RIGHT:
                self.MoveTimelineRange(1, int(self.timelineRange/100.0*10), True, False, True)
            elif key == wx.WXK_LEFT:
                self.MoveTimelineRange(0, int(self.timelineRange/100.0*10), True, False, True)
            elif key == wx.WXK_UP:
                self.MoveTimelineRange(1, self.timelineRange, False, True, True)
            elif key == wx.WXK_DOWN:
                self.MoveTimelineRange(0, self.timelineRange, False, True, True)
            else: event.Skip()
        else:
            event.Skip()

    # GPo
    def OnKeyUpVideoWindow(self, event):
        self.KeyUpVideoWndow = True
        if event:
            event.Skip()

    # GPo 2018  reduce a bit the code size (moore then once used)
    def ZoomAndScroll(self, old_zoomfactor, new_zoomfactor):
        self.zoomfactor = self.fix_zoom(max(min(new_zoomfactor, 40.0), 0.1))
        xrel, yrel = self.videoWindow.ScreenToClient(wx.GetMousePosition())
        xpos, ypos = self.videoWindow.CalcUnscrolledPosition(xrel, yrel)
        xpos = (xpos - self.xo) * self.zoomfactor / old_zoomfactor + self.xo
        ypos = (ypos - self.yo) * self.zoomfactor / old_zoomfactor + self.yo
        scroll = xpos - xrel, ypos - yrel
        if self.zoomfactor == 1:
            self.UpdateMenuItem(_('&Zoom'), True, 'video', [_('100% (normal)')])
        elif self.zoomfactor in [0.25, 0.50, 2, 3, 4]:
            self.UpdateMenuItem(_('&Zoom'), True, 'video', [_(str(self.zoomfactor*100)+'%')])
        self.ShowVideoFrame(scroll=scroll)

    # GPo 2020, extern for multi use, and result for handling
    def ScrollSimilarTabsOrTabGroups(self, delta):
        group = self.currentScript.group
        tab_groups = self.options['enabletabscrolling_groups'] and group is not None
        similar_clips = self.options['enabletabscrolling']
        similar_clips_groups = self.options['enabletabscrolling'] and not tab_groups
        if not similar_clips and not tab_groups:
            return False
        # Create list of indices to loop through
        index = self.scriptNotebook.GetSelection()
        r = range(self.scriptNotebook.GetPageCount())
        if delta >= 1:
            for i in xrange(index+1):
                j = r.pop(0)
                r.append(j)
        else:
            r.reverse()
            for i in xrange(index):
                j = r.pop()
                r.insert(0,j)
        # Loop through r to find next suitable tab
        curframe = self.videoSlider.GetValue()
        oldInfo = (self.oldWidth, self.oldHeight, self.oldFramecount)
        for index in r:
            script = self.scriptNotebook.GetPage(index)
            if self.AviThread_Running(script):
                continue
            if (tab_groups and group == script.group) and (index != self.scriptNotebook.GetSelection()):
                if self.options['tabautopreview']:
                    if self.previewOK(script):
                        self.SelectTab(index)
                        return True
                else:
                    self.SelectTab(index)
                    return True
            if (not similar_clips or script.group != group or
                script.group is not None and not similar_clips_groups):
                    continue

            # GPo, if not initialized skip it, don't open all tabs
            """
            try:
                if not script.AVI.initialized and (self.options['mousewheelfunc'] != 'tab_change_or_scroll'): # simulate 2.5.1 open all tabs
                    continue
            except AttributeError:
                return False
            """
            if self.options['tabautopreview'] and not self.previewOK(script):
                continue
            self.refreshAVI = True
            if self.UpdateScriptAVI(script, prompt=True) is None:
                self.UpdateScriptTabname(script)
                try:
                    if not script.AVI.initialized:
                        continue
                except AttributeError:
                    return False
            newInfo = (
                int(script.AVI.DisplayWidth * self.zoomfactor),
                int(script.AVI.DisplayHeight * self.zoomfactor),
                script.AVI.Framecount
            )
            if (newInfo == oldInfo) and (index != self.scriptNotebook.GetSelection()):
                self.SelectTab(index)
                return True
        return False

    # Win10 hack
    def OnVideoControlsMouseWheel(self, event):
        if not self.previewWindowVisible or event.LeftIsDown():
            return
        self.OnMouseWheelVideoWindow(event)

    def OnMouseWheelVideoWindow(self, event):
        # Zoom preview
        leftdown = event.LeftIsDown()
        shiftdown = event.ShiftDown()
        if event.ControlDown() or leftdown or shiftdown:
            if event:
                xpos, ypos = event.GetPosition()
            else:
                xpos, ypos = self.videoWindow.ScreenToClient(wx.GetMousePosition())
            int50 = intPPI(50)
            cRect = self.videoWindow.GetClientRect()
            single = shiftdown or wx.Rect(cRect[2]-int50,0,int50,int50).ContainsXY(xpos,ypos)
            #force = False if single else wx.Rect(cRect[2]-int50,cRect[3]-int50,int50,int50).ContainsXY(xpos,ypos)
            #sameSize = False if single else wx.Rect(cRect[2]-int50,(cRect[3]/2)-intPPI(25),int50,int50).ContainsXY(xpos,ypos)
            if single and self.options['showresamplemenu'] != 0:
                script = self.currentScript
                # round to one decimales e.g 0.46765 to 0.5
                czoom = round(float(script.AVI.DisplayWidth) / script.AVI.Width, 1)
                rf = script.resizeFilter
                rotation = event.GetWheelRotation()
                if self.options['invertscrolling']: rotation = -rotation
                zoom = czoom + 0.1 if rotation > 0 else czoom - 0.1
                if zoom > 2.0 or zoom < 0.1:
                    return
                if zoom == 1:
                    zoom = -1 # disable resize filter
                self.OnMenuVideoZoomResampleFit(zoom=zoom, fitHeight=rf[3], single=single, doScroll=shiftdown)
                return
            # if not in client then return, speed up
            if not self.videoWindow.GetClientRect().Inside((xpos, ypos)):
                return
            if self.zoomwindow:
                return
            # New zoom factor
            rotation = event.GetWheelRotation()
            if self.options['invertscrolling']: rotation = -rotation
            factor = 1 + 0.25 * abs(rotation) / event.GetWheelDelta()
            old_zoomfactor = self.zoomfactor
            if rotation > 0:
                self.zoomfactor = round(self.zoomfactor * factor, 2)
            else:
                self.zoomfactor = round(self.zoomfactor / factor, 2)
            if self.zoomfactor > 0.88 and self.zoomfactor < 1.12:
                self.zoomfactor = 1
            self.videoWindow.Freeze()
            if not leftdown: # the antialiasing not disabled
                self.zoom_antialias = False
            try:
                self.ZoomAndScroll(old_zoomfactor, self.zoomfactor)
            finally:
                self.TryThaw(self.videoWindow)
            if leftdown:
                self.videoWindow.oldPoint = event.GetPosition()
                self.videoWindow.oldOrigin = self.videoWindow.GetViewStart()
            else:
                self.ResetZoomAntialias()

            return
        elif self.options['mousewheelfunc'] == 'frame_step':
            # GPo 2018  frame skip with mouse wheel
            rotation = event.GetWheelRotation()
            if self.options['invertframescrolling']: rotation = -rotation
            self.StopPlayback()
            if rotation > 0: self.ShowVideoFrame(self.videoSlider.GetValue() + 1)
            else: self.ShowVideoFrame(self.videoSlider.GetValue() - 1, wrap=False)
            return

        # GPo, we keep the function (tab change) so first calculate the delta.
        rotation = event.GetWheelRotation()
        if self.mouse_wheel_rotation * rotation < 0:
            self.mouse_wheel_rotation = rotation
        else:
            self.mouse_wheel_rotation += rotation
        if not abs(self.mouse_wheel_rotation) >= event.GetWheelDelta():
            return
        self.mouse_wheel_rotation = 0
        if self.options['invertscrolling']: rotation = -rotation
        if rotation > 0:
            delta = 1
        else:
            delta = -1

        # Scroll similar tabs or tab groups
        # GPo 2020, if no similar tabs or tab groups found, keep the function and change the tab
        if not self.ScrollSimilarTabsOrTabGroups(delta):
            if self.options['mousewheelfunc'] == 'tab_change': # GPo tab change new func
                if self.options['tabautopreview']:
                    new,idx = self.AutoPreviewGetNextPageIndex(delta < 0)
                    if new:
                        self.SelectTab(idx)
                else: self.SelectTab(None, delta)
            else:
                # Scroll video preview, tab change original func 2.5.1
                x0, y0 = self.videoWindow.GetViewStart()
                scrolls_by_pixel = self.zoomfactor / float(10) * event.GetWheelRotation() / event.GetWheelDelta()
                horizontal = event.ShiftDown()
                if horizontal:
                    scrolls = int(round(self.currentScript.AVI.DisplayWidth * scrolls_by_pixel))
                    self.videoWindow.Scroll(x0 + scrolls, -1)
                else:
                    scrolls = int(round(self.currentScript.AVI.DisplayHeight * scrolls_by_pixel))
                    self.videoWindow.Scroll(-1, y0 - scrolls)

    def ShowVideoFrame_checkResizeFilter(self, script, scroll=None, forceLayout=True):
        self.CheckPlayback()
        resize = script.resizeFilter[0] and script.resizeFilter[2] == 1
        if resize:
            if self.splitView:
                self.ResizeFilterUpdateSplitView()
            else:
                script.display_clip_refresh_needed = True
        if resize and script.previewFilterIdx > 0 and script.AVI:
            script.AVI.SetResizeFilter(self.GetResizeFilterInfo(script))
            self.OnMenuPreviewFilter(index=script.previewFilterIdx, updateUserSliders=False, scroll=scroll)
        else:
            self.ShowVideoFrame(forceLayout=forceLayout, scroll=scroll)

    def OnLeftDClickVideoWindow(self, event=None, toggleFullscreen=False):
        script = self.currentScript
        if event:
            int50 = intPPI(50)
            cRect = self.videoWindow.GetClientRect()
            single = wx.Rect(cRect[2]-int50,0,int50,int50).Inside(event.GetPosition())
            force = False if single else wx.Rect(cRect[2]-int50,cRect[3]-int50,int50,int50).Inside(event.GetPosition())
            #sameSize = False if single or force else wx.Rect(cRect[2]-int50,(cRect[3]/2)-intPPI(25),int50,int50).Inside(event.GetPosition())
            if single or force and self.options['showresamplemenu'] != 0:
                self.OnMenuVideoZoomResampleFit(zoom=1, fitHeight=script.resizeFilter[3], single=single, sameSize=False)
                event.Skip()
                return

        ctrlKey = wx.GetKeyState(wx.WXK_CONTROL)
        if self.separatevideowindow:
            if not self.previewWindowVisible:
                return
            playing_video = self.playing_video
            if playing_video:
                self.StopPlayback()
            try:
                if self.videoDialog.IsFullScreen():
                    if ctrlKey:
                        self.videoDialog.Maximize(True)
                        self.videoDialog.ShowFullScreen(show=False)
                        self.videoDialog.Maximize(True)
                    else:
                        self.videoDialog.ShowFullScreen(show=False)
                else:
                    if ctrlKey or toggleFullscreen:
                        self.videoDialog.ShowFullScreen(show=not self.videoDialog.IsFullScreen())
                    else:
                        self.videoDialog.Maximize(not self.videoDialog.IsMaximized())
            finally:
                self.videoWindow.Update()
                self.videoDialog.Update()
                wx.GetApp().ProcessIdle() # two, for ShowVideoFrame and ResetAntialias
                wx.GetApp().ProcessIdle()
                if playing_video:
                    self.PlayPauseVideo()
                if event:
                    event.Skip()
                return

        if script.AVI:
            self.zoom_antialias = False
        setminpanesize = False
        if not self.mainSplitter.IsFrozen():
            self.mainSplitter.Freeze()
            IsFrozen = True
        else:
            IsFrozen = False

        playing_video = self.playing_video
        if playing_video:
            self.StopPlayback()
        self.blockEventSize = True  # disable event OnSize
        try:
            if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
                if ctrlKey or (toggleFullscreen and not self.IsFullScreen()):   # set full size, set tabs 1 pixel visible
                    if self.mintextlines > 0:
                        self.oldLastSplitVideoPos = script.lastSplitVideoPos
                    self.mainSplitter.SetMinimumPaneSize(1)
                    self.mintextlines = 0
                    sash_pos = 1
                elif script.GetSize().height  > 5:
                    if self.mintextlines > 0:
                        self.oldLastSplitVideoPos = script.lastSplitVideoPos
                    self.SetMinimumScriptPaneSize(0)
                    sash_pos = 1
                else:
                    setminpanesize = True
                    if self.options['resizevideowindow']:
                        script.lastSplitVideoPos = None
                        sash_pos = self.GetMainSplitterNegativePosition(pos=None, forcefit=True)
                    else:
                        if self.oldLastSplitVideoPos is not None:
                            sash_pos = self.oldLastSplitVideoPos
                        else:
                            sash_pos = self.GetMainSplitterNegativePosition(pos=None, forcefit=True)
                    self.mintextlines = self.options['mintextlines']
            else:
                if ctrlKey or (toggleFullscreen and not self.IsFullScreen()):   # set full size, set tabs 1 pixel visible
                    if self.mintextlines > 0:
                        self.oldLastSplitVideoPos = script.lastSplitVideoPos
                    self.mainSplitter.SetMinimumPaneSize(1)
                    self.mintextlines = 0
                    sash_pos = 1
                elif script.GetSize().width > 5:
                    if self.mintextlines > 0:
                        self.oldLastSplitVideoPos = script.lastSplitVideoPos
                    self.SetMinimumScriptPaneSize(0)
                    sash_pos = 1
                else:
                    setminpanesize = True
                    if self.options['resizevideowindow']:
                        script.lastSplitVideoPos = None
                        sash_pos = self.GetMainSplitterNegativePosition(pos=None, forcefit=True)
                    else:
                        if self.oldLastSplitVideoPos is not None:
                            sash_pos = self.oldLastSplitVideoPos
                        else:
                            sash_pos = self.GetMainSplitterNegativePosition(pos=None, forcefit=True)
                    self.mintextlines = self.options['mintextlines']

            if ctrlKey or toggleFullscreen:
                self.ShowFullScreen(show=not self.IsFullScreen(), style=wx.FULLSCREEN_NOCAPTION|wx.FULLSCREEN_NOMENUBAR|wx.FULLSCREEN_NOBORDER)
            elif self.IsFullScreen():
                self.ShowFullScreen(show=False)

            if setminpanesize: # must be set after Fullsize mode change (if multiline style)
                self.SetMinimumScriptPaneSize()
            self.mainSplitter.SetSashPosition(sash_pos)
            self.SaveLastSplitVideoPos()

        finally:
            if IsFrozen:
                self.TryThaw(self.mainSplitter)
            if script.AVI:
                if self.previewWindowVisible:
                    self.ShowVideoFrame_checkResizeFilter(script, scroll=None, forceLayout=True)
                    self.ResetZoomAntialias()
                    if playing_video and not self.playing_video:
                        wx.GetApp().ProcessIdle()
                        self.PlayPauseVideo()
                else:
                    self.DisableResizeFilter(onlyFitFill=True) # we must reset all resizeFilter if not preview visible when changing the fullsize mode
            if event:
                event.Skip()

    # GPo 2018
    def OnRightUpVideoWindow(self, event):
        if event.LeftIsDown():
            if self.options['showresamplemenu'] > 0: # then resample enabled
                shiftdown = event.ShiftDown()
                int50 = intPPI(50)
                cRect = self.videoWindow.GetClientRect()
                single = wx.Rect(cRect[2]-int50,0,int50,int50).Inside(event.GetPosition()) or shiftdown
                if single:
                    rf = self.currentScript.resizeFilter
                    if self.currentScript.AVI:
                        zoom = -1 if self.currentScript.AVI.Width != self.currentScript.AVI.DisplayWidth else 2
                        self.OnMenuVideoZoomResampleFit(zoom=zoom, fitHeight=rf[3], doScroll=shiftdown)
                    return
                    #~self.OnMenuVideoZoomResampleFit(zoom=2 if rf[2] != 2 else -1, fitHeight=rf[3], doScroll=shiftdown)
                    #~self.OnMenuVideoZoomResampleFit(zoom = -1 if rf[2] != 1 else 2, fitHeight=rf[3], doScroll=shiftdown)
                    #return

            if self.zoomwindow:
                self.zoomwindow = False
                self.zoomwindowfill = False
                self.zoomwindowfit = False
                self.zoomfactor = 1
                old_zoomfactor = 1
            else:
                old_zoomfactor = self.zoomfactor
                if self.zoomfactor != 1: self.zoomfactor = 1
                else: self.zoomfactor = 2

            if self.videoWindow.HasCapture():
                try:
                    self.videoWindow.ReleaseMouse()  # GPo 2020, must release otherwise videoWindow moves
                except:
                    pass
                self.videoWindow.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
            self.videoWindow.Freeze()
            try:
                self.ZoomAndScroll(old_zoomfactor, self.zoomfactor)
                if event.LeftIsDown() and not self.currentScript.AVI.IsErrorClip():
                    videoWindow = self.videoWindow
                    videoWindow.CaptureMouse()
                    videoWindow.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
                    videoWindow.oldPoint = event.GetPosition()
                    videoWindow.oldOrigin = videoWindow.GetViewStart()
                    if self.getPixelInfo:
                        if self.getPixelInfo == 'string':
                            self.pixelInfo = self.GetPixelInfo(event, string_=True)
                        else:
                            self.pixelInfo = self.GetPixelInfo(event)
                        self.getPixelInfo = False
                """
                # GPo new test
                if self.options['resizevideowindow'] and not self.separatevideowindow: #and not self.IsFullScreen():
                    #if self.mainSplitter.GetMinimumPaneSize() > 1:
                    self.currentScript.lastSplitVideoPos = None
                    sash_pos = self.GetMainSplitterNegativePosition(pos=None, forcefit=True)
                    self.mainSplitter.SetSashPosition(sash_pos)
                """
            finally:
                self.TryThaw(self.videoWindow)
        else:
            event.Skip() # show context menu

    def OnMiddleDownVideoWindow(self, event):
        self.HidePreviewWindow()

    def OnLeftDownVideoWindow(self, event):
        script = self.currentScript
        if self.cropDialog.IsShown():
            # Set focus on video window if necessary
            # Set trim values if clicked within video frame
            w = script.AVI.Width
            h = script.AVI.Height
            left = self.cropValues['left']
            top = self.cropValues['top']
            mright = self.cropValues['-right']
            mbottom = self.cropValues['-bottom']
            xPos, yPos = self.videoWindow.CalcUnscrolledPosition(event.GetX(), event.GetY())
            xPos -= self.xo
            yPos -= self.yo
            xPos = int(round(xPos / float(self.zoomfactor)))
            yPos = int(round(yPos / float(self.zoomfactor)))
            if 'fliphorizontal' in self.flip:
                xPos = w - xPos
            if 'flipvertical' in self.flip:
                yPos = h - yPos
            xcenter = (w - left - mright) / float(2) + left
            ycenter = (h - top - mbottom) / float(2) + top
            xPos0 = xPos - xcenter
            yPos0 = - (yPos - ycenter)
            if xPos0 == 0:
                choice = 'top' if yPos0 > 0 else '-bottom'
            else:
                m = float(h - top - mbottom) / (w - left - mright)
                mo = yPos0 / xPos0
                if -m < mo < m:
                    choice = '-right' if xPos0 > 0 else 'left'
                else:
                    choice = 'top' if yPos0 > 0 else '-bottom'
            if choice == 'top':
                new_value = min(yPos, h - mbottom - self.options['cropminy'])
            elif choice == '-bottom':
                new_value = min(h - yPos, h - top - self.options['cropminy'])
            elif choice == 'left':
                new_value = min(xPos, w - mright - self.options['cropminx'])
            elif choice == '-right':
                new_value = min(w - xPos, w - left - self.options['cropminx'])
            self.cropDialog.ctrls[choice].SetValue(new_value)
            self.lastcrop = choice
            self.SetVideoStatusText()
            if wx.VERSION > (2, 9):
                self.OnCropDialogSpinTextChange()
        else:
            self.splitViewEx_snapped = False
            # GPo, on double clicked (zoom full size), self.refreshAVI is after first mouse down False
            if (self.refreshAVI or script.refreshAVI): # or (script.previewFilterIdx < 1 and self.ScriptChanged(script)): #previewFilter!
                if self.options['refreshpreview']:
                    self.ShowVideoFrame_CheckPreview()
                else:
                    if (script.previewFilterIdx > 0) and not self.ComparePreviewFilterDict(): # then update the slider
                        self.IdleCallDict['UpdateUserSliders'] = self.UpdateUserSliders()
                    self.refreshAVI = script.refreshAVI = False

            # must be checked again, the event is no longer current after ShowVideoFrame a MouseUp may already be triggered.
            if wx.GetMouseState().LeftIsDown():
                videoWindow = self.videoWindow
                videoWindow.CaptureMouse()
                videoWindow.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
                videoWindow.oldPoint = event.GetPosition()
                videoWindow.oldOrigin = videoWindow.GetViewStart()
                if self.getPixelInfo:
                    if self.getPixelInfo == 'string':
                        self.pixelInfo = self.GetPixelInfo(event, string_=True)
                    else:
                        self.pixelInfo = self.GetPixelInfo(event)
                    self.getPixelInfo = False

                if self.splitViewEx and self.splitView:
                    if wx.GetKeyState(wx.WXK_CONTROL) or \
                            (self.splitViewEx_posx >= videoWindow.oldPoint[0]-intPPI(25) and self.splitViewEx_posx <= videoWindow.oldPoint[0]+intPPI(16)):
                        self.splitViewEx_snapped = True
                        self.splitViewEx_posx = videoWindow.oldPoint[0] - self.xo
                        dc = wx.ClientDC(videoWindow)
                        self.PaintAVIFrame(dc, self.currentScript, self.currentframenum, shift=True)
        event.Skip()

    def AutoPreviewGetNextPageIndex(self, reverse):
        curr = self.scriptNotebook.GetSelection()
        if reverse:
            for i in reversed(xrange(0, curr)):
                if i != curr and self.previewOK(self.scriptNotebook.GetPage(i)):
                    return True, i
            for i in reversed(xrange(curr, self.scriptNotebook.GetPageCount())):
                if i != curr and self.previewOK(self.scriptNotebook.GetPage(i)):
                    return True, i
        else:
            for i in xrange(curr, self.scriptNotebook.GetPageCount()):
                if i != curr and self.previewOK(self.scriptNotebook.GetPage(i)):
                    return True, i
            for i in xrange(0, curr):
                if self.previewOK(self.scriptNotebook.GetPage(i)):
                    return True, i
        return False, curr

    # mouse browse backward button, bind with script and video window
    def OnMouseAux1Down(self, event, isAux2=False):
        def x_GotoBookmark(reverse):
            if SHIFT:
                self.GotoNextBookmark(reverse=reverse, forceCursor=True, bmtype=[1,2])
            elif ALT:
                self.GotoNextBookmark(reverse=reverse, forceCursor=True, bmtype=[3])
            else:
                self.GotoNextBookmark(reverse=reverse, forceCursor=True)

        CTRL = wx.GetKeyState(wx.WXK_CONTROL)
        SHIFT = wx.GetKeyState(wx.WXK_SHIFT)
        ALT = wx.GetKeyState(wx.WXK_ALT)
        val = 1 if isAux2 else -1

        if self.options['mouseauxdown'] == 'tab change':
            if (self.scriptNotebook.GetPageCount() > 1) and not event.LeftIsDown() and not CTRL and not SHIFT and not ALT:
                if not self.previewWindowVisible or not self.ScrollSimilarTabsOrTabGroups(val):
                    if self.options['tabautopreview']:
                        new,idx = self.AutoPreviewGetNextPageIndex(not isAux2)
                        if new:
                            self.SelectTab(idx)
                        else:
                            x_GotoBookmark(not isAux2)
                    else:
                        self.SelectTab(None, val)
            else:
                x_GotoBookmark(not isAux2)

        elif self.options['mouseauxdown'] == 'custom jump':
            self.OnMenuVideoPrevCustomUnit(None)
        elif self.options['mouseauxdown'] == 'frame step':
            self.ShowVideoFrame(self.videoSlider.GetValue() + val, wrap=False)
        elif self.options['mouseauxdown'] == 'bookmark jump':
            x_GotoBookmark(not isAux2)
        else:
            event.Veto()

    # mouse browse forward button, bind with script and video window
    def OnMouseAux2Down(self, event):
        self.OnMouseAux1Down(event, isAux2=True)

    @AsyncCallWrapper
    def OnMouseMotionVideoWindow(self, event=None):
        if self.cropDialog.IsShown() and event and event.LeftIsDown():
            script = self.currentScript
            w = script.AVI.Width
            h = script.AVI.Height
            left = self.cropValues['left']
            top = self.cropValues['top']
            mright = self.cropValues['-right']
            mbottom = self.cropValues['-bottom']
            xPos, yPos = self.videoWindow.CalcUnscrolledPosition(event.GetX(), event.GetY())
            xPos -= self.xo
            yPos -= self.yo
            xPos = int(round(xPos / float(self.zoomfactor)))
            yPos = int(round(yPos / float(self.zoomfactor)))
            if 'fliphorizontal' in self.flip:
                xPos = w - xPos
            if 'flipvertical' in self.flip:
                yPos = h - yPos
            if self.lastcrop == 'top':
                top = yPos
                if top < 0:
                    top = 0
                if (h - mbottom) - top < self.options['cropminy']:
                    top = (h - mbottom) - self.options['cropminy']
                self.cropDialog.ctrls['top'].SetValue(top)
            elif self.lastcrop == '-bottom':
                mbottom = h - yPos
                if mbottom < 0:
                    mbottom = 0
                if (h - mbottom) - top < self.options['cropminy']:
                    mbottom = h - top - self.options['cropminy']
                self.cropDialog.ctrls['-bottom'].SetValue(mbottom)
            elif self.lastcrop == 'left':
                left = xPos
                if left < 0:
                    left = 0
                if (w - mright) - left < self.options['cropminx']:
                    left = (w - mright)  - self.options['cropminx']
                self.cropDialog.ctrls['left'].SetValue(left)
            elif self.lastcrop == '-right':
                mright = w - xPos
                if mright < 0:
                    mright = 0
                if (w - mright) - left < self.options['cropminx']:
                    mright = w - left  - self.options['cropminx']
                self.cropDialog.ctrls['-right'].SetValue(mright)
            self.SetVideoStatusText()
            if wx.VERSION > (2, 9):
                self.OnCropDialogSpinTextChange()
        else:
            #if event and event.Dragging() and event.LeftIsDown() and self.videoWindow.HasCapture():
            if event and event.LeftIsDown() and self.videoWindow.HasCapture():
                videoWindow = self.videoWindow

                newPoint = videoWindow.ScreenToClient(wx.GetMousePosition())
                #newPoint = event.GetPosition()
                if videoWindow.GetRect().Inside(newPoint):
                    if self.splitViewEx and self.splitView:
                        if self.splitViewEx_snapped or wx.GetKeyState(wx.WXK_CONTROL):
                            self.splitViewEx_posx = newPoint[0] - self.xo # set the new posx and if not control pressed then only repaint the splitView
                            self.zoom_antialias = False
                            #self.videoWindow.Refresh()
                            dc = wx.ClientDC(self.videoWindow)
                            self.PaintAVIFrame(dc, self.currentScript, self.currentframenum, isPaintEvent=True)
                            return

                    newOriginX = videoWindow.oldOrigin[0] - (newPoint[0] - videoWindow.oldPoint[0])
                    newOriginY = videoWindow.oldOrigin[1] - (newPoint[1] - videoWindow.oldPoint[1])
                    if newOriginX < 0:
                        videoWindow.oldPoint[0] = newPoint[0] - videoWindow.oldOrigin[0]
                        newOriginX = 0
                    if newOriginY < 0:
                        videoWindow.oldPoint[1] = newPoint[1] - videoWindow.oldOrigin[1]
                        newOriginY = 0
                    xwin, ywin = videoWindow.GetClientSize()
                    xvwin, yvwin = videoWindow.GetVirtualSize()
                    xmax = xvwin - xwin
                    ymax = yvwin - ywin
                    if xmax > 0 and newOriginX > xmax:
                        videoWindow.oldPoint[0] = xmax + newPoint[0] - videoWindow.oldOrigin[0]
                        newOriginX = xmax
                    if ymax > 0 and newOriginY > ymax:
                        videoWindow.oldPoint[1] = ymax + newPoint[1] - videoWindow.oldOrigin[1]
                        newOriginY = ymax
                    self.zoom_antialias = False
                    videoWindow.Scroll(newOriginX, newOriginY)
                else:
                    self.zoom_antialias = self.options['zoom_antialias']
                    try:
                        videoWindow.ReleaseMouse()
                    except:
                        pass
                    videoWindow.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
            elif not self.playing_video and not self.videoSlider.HasCapture() and self.showVideoPixelInfo: # GPo 2020, not playing_video
                if True:#self.FindFocus() == videoWindow:
                    pixelInfo = self.GetPixelInfo(event, string_=True)
                    if pixelInfo[1] is None:
                        self.SetVideoStatusText()
                    else:
                        self.SetVideoStatusText(addon=pixelInfo)


    # GPo, use it for IdleCall e.g OnScrollVideoWindow
    def OnAfterScrollVideoWindow(self):
        self.zoom_antialias = self.options['zoom_antialias'] #True
        self.videoWindow.Refresh()

    # GPo, all scroll bar scroll events, but no videoWindow.Scroll event
    def OnScrollVideoWindow(self, event):
        if self.zoom_antialias and (self.zoomfactor != 1 or self.zoomwindowfill):
            self.zoom_antialias = False
            self.IdleCall.append((self.OnAfterScrollVideoWindow, tuple(), {}))
        event.Skip()

    """ # zoom_antialias is the block on the leg
    def OnSizeVideoWindow(self, event=None):
        if self.previewWindowVisible and self.zoomwindow and not self.splitView and self.currentScript.AVI:
            self.zoom_antialias = False
            self.CalculateZoomFitFill()
            if self.zoomwindowfit:
                self.videoWindow.SetVirtualSize((0,0))
            else:
                zfa = 3 if self.zoomfactor <= 2 else 4
                w = int(self.currentScript.AVI.DisplayWidth * self.zoomfactor)
                h = int(self.currentScript.AVI.DisplayHeight * self.zoomfactor)
                self.videoWindow.SetVirtualSize((w + self.xo + zfa, 0))
            self.videoWindow.Refresh()
            #wx.CallAfter(self.OnAfterScrollVideoWindow)
            self.IdleCallDict['OnAfterScrollVideoWindow'] = self.OnAfterScrollVideoWindow()
        if event:
            event.Skip()
    """
    def OnMouseLeaveVideoWindow(self, event):
        if self.FindFocus() == self.currentScript:
            self.SetScriptStatusText()
        if self.videoWindow.HasCapture():
            try:
                self.videoWindow.ReleaseMouse()
            except:
                pass
            self.videoWindow.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
        if event.LeftIsDown() and not self.cropDialog.IsShown() and \
            (self.zoomfactor != 1) and self.options['zoom_antialias']:
                self.zoom_antialias = True
                self.videoWindow.Refresh()
                self.videoWindow.Update()
                #wx.YieldIfNeeded()
        event.Skip()

    def OnLeftUpVideoWindow(self, event):
        if self.videoWindow.HasCapture():
            try:
                self.videoWindow.ReleaseMouse()
            except:
                pass
            self.videoWindow.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
        """
        if self.refreshAVI or self.currentScript.refreshAVI and not self.cropDialog.IsShown():
            if self.options['refreshpreview']:
                self.ShowVideoFrame_CheckPreview()
            else:
                if (self.currentScript.previewFilterIdx > 0) and not self.ComparePreviewFilterDict(): # then update the slider
                    self.IdleCallDict['UpdateUserSliders'] = self.UpdateUserSliders()
        """

        if not self.cropDialog.IsShown():
            self.zoom_antialias = self.options['zoom_antialias']
            if (self.zoomfactor != 1) and self.zoom_antialias:
                #self.IdleCallDict['videoWindowRefresh'] = self.videoWindow.Refresh
                self.videoWindow.Refresh()
        event.Skip()

    def OnCropDialogSpinTextChange(self, event=None):
        script = self.currentScript
        # Display actual spin control value (integer only)
        if not event: # SpinCtrl.SetValue() doesn't generate EVT_TEXT in wx2.9
            if self.lastcrop:
                spinCtrl = self.cropDialog.ctrls[self.lastcrop]
            else:
                spinCtrl = None
        else:
            spinCtrl = event.GetEventObject()
            spinCtrl.SetValue(spinCtrl.GetValue())
        # Update the spin control ranges
        w = script.AVI.Width
        h = script.AVI.Height
        for key in self.cropValues.keys():
            self.cropValues[key] = self.cropDialog.ctrls[key].GetValue()
        self.cropDialog.ctrls['left'].SetRange(0, w-self.options['cropminx']-self.cropValues['-right'])
        self.cropDialog.ctrls['-right'].SetRange(0, w-self.options['cropminx']-self.cropValues['left'])
        self.cropDialog.ctrls['top'].SetRange(0, h-self.options['cropminy']-self.cropValues['-bottom'])
        self.cropDialog.ctrls['-bottom'].SetRange(0, h-self.options['cropminy']-self.cropValues['top'])
        # Paint the crop rectangles

        # GPo 2020, that's enough
        dc = wx.ClientDC(self.videoWindow)
        self.PaintAVIFrame(dc, script, self.currentframenum, shift=True)
        self.PaintCropWarnings(spinCtrl)
        self.SetVideoStatusText()

    def OnCropAutocrop(self, event):
        button = event.GetEventObject()
        button.running = not button.running
        if button.running:
            ctrl = self.cropDialog.ctrls['choiceMod']
            mod = ctrl.GetString(ctrl.GetCurrentSelection()).replace('mod ', '').strip()
            wx.CallAfter(self.Autocrop, button, int(mod))

    def OnCropAutocropSamples(self, event):
        new_sample_size = event.GetEventObject().GetValue()
        if new_sample_size != self.options['autocrop_samples']:
            self.options['autocrop_samples'] = new_sample_size
            self.currentScript.autocrop_values = None

    def Autocrop(self, button, mod=1):
        '''Run crop editor's auto-crop option'''
        script = self.currentScript
        if script.autocrop_values is None:
            # Get crop values for a number of frames
            samples = self.options['autocrop_samples']
            tol = 70
            clip = script.AVI
            frames = clip.Framecount
            samples = min(samples, frames)
            if samples <= 2:
                frames = range(samples)
            else:
                def float_range(start=0, end=10, step=1):
                    '''Range with float step'''
                    while start < end:
                        yield int(round(start))
                        start += step
                frames = float_range(frames/10, 9*frames/10 - 1, 8.0*frames/(10*samples))
            crop_values = []
            for i, frame in enumerate(frames):
                button.SetLabel(_('Cancel') + ' ({0}/{1})'.format(i+1, samples))
                crop_values_frame = clip.AutocropFrame(frame, tol)
                if not crop_values_frame:
                    button.SetLabel(_('Auto-crop'))
                    return
                crop_values.append(crop_values_frame)
                self.SaveCallYield()
                if not button.running:
                    button.SetLabel(_('Auto-crop'))
                    return

            # Get and apply final crop values
            script.autocrop_values = []
            for seq in zip(*crop_values):
                script.autocrop_values.append(self.GetAutocropValue(seq))

            if mod > 1:
                for i in xrange(len(script.autocrop_values)):
                    if script.autocrop_values[i] > 0:
                        script.autocrop_values[i] = script.autocrop_values[i]/mod*mod

        self.cropDialog.ctrls['left'].SetValue(script.autocrop_values[0])
        self.cropDialog.ctrls['top'].SetValue(script.autocrop_values[1])
        self.cropDialog.ctrls['-right'].SetValue(script.autocrop_values[2])
        self.cropDialog.ctrls['-bottom'].SetValue(script.autocrop_values[3])
        self.lastcrop = None
        self.SetVideoStatusText()
        self.OnCropDialogSpinTextChange()
        button.SetLabel(_('Auto-crop'))
        button.running = False

    @staticmethod
    def GetAutocropValue(seq):
        """Get the most repeated value on a sequence if it repeats more than 50%,
        the minimum value otherwise"""
        d = collections.defaultdict(int)
        for i in seq:
            d[i] += 1
        max = sorted(d.keys(), key=lambda x:-d[x])[0]
        if d[max] > len(seq) / 2:
            return max
        else:
            ret_val = max
            for value in seq:
                if value < ret_val:
                    ret_val = value
            return ret_val

    def OnCropDialogApply(self, event):
        if self.cropDialog.boolInvalidCrop:
            dlg = wx.MessageDialog(self, _('Invalid crop values detected.  Continue?'),
                _('Warning'), wx.YES_NO|wx.CANCEL)
            ID = dlg.ShowModal()
            dlg.Destroy()
            if ID != wx.ID_YES:
                return
        script = self.currentScript
        # Update the script with the crop text
        croptxt = 'Crop(%(left)i, %(top)i, -%(-right)i, -%(-bottom)i)' % self.cropValues
        # Insert the crop based on the selected radio box option
        choice = self.cropDialog.ctrls['choiceInsert'].GetCurrentSelection()
        if choice == 0:
            # Case 1: Insert at end of script
            self.InsertTextAtScriptEnd(croptxt, script)
        elif choice == 1:
            # Case 2: Insert at script cursor
            script.ReplaceSelection(croptxt)
        if choice == 2:
            # Case 3: Copy Crop() to the clipboard
            text_data = wx.TextDataObject(croptxt)
            if wx.TheClipboard.Open():
                wx.TheClipboard.SetData(text_data)
                wx.TheClipboard.Close()
        # Hide the crop dialog
        self.cropDialog.Hide()
        for key in self.cropValues.keys():
            self.cropValues[key] = 0
        # Show the updated video frame
        self.refreshAVI = True
        self.zoom_antialias = self.options['zoom_antialias']
        self.ShowVideoFrame()

    def OnCropDialogCancel(self, event):
        script = self.currentScript
        for key in self.cropValues.keys():
            self.cropValues[key] = 0
        dc = wx.ClientDC(self.videoWindow)
        self.PaintAVIFrame(dc, script, self.currentframenum)
        self.cropDialog.Hide()
        self.zoom_antialias = self.options['zoom_antialias']
        if self.zoom_antialias and self.zoomfactor != 1:
            self.videoWindow.Refresh()

    def OnTrimDialogSpinTextChange(self, event):
        spinCtrl = event.GetEventObject()
        spinCtrl.SetValue(spinCtrl.GetValue())

    def OnTrimDialogApply(self, event):
        insertMode = self.trimDialog.ctrls['choiceInsert'].GetCurrentSelection()
        useDissolve = self.trimDialog.ctrls['useDissolve'].GetValue()
        singleClips =  self.trimDialog.ctrls['singleClips'].GetValue()
        clipPrefix = self.trimDialog.ctrls['clipPrefix'].GetValue()
        if useDissolve:
            useDissolve += self.trimDialog.ctrls['dissolveOverlap'].GetValue()
        if not self.InsertSelectionTrims(cutSelected=self.invertSelection,
                                         insertMode=insertMode,
                                         useDissolve=useDissolve,
                                         singleClips=singleClips,  # GPo singleClip, prefix
                                         clipPrefix=clipPrefix):
            self.OnTrimDialogCancel(event)
            return
        for slider in self.GetVideoSliderList():
            slider.ToggleSelectionMode(0)
            slider.SetBookmarkHilighting(self.trimDialog.oldhighligthBookmarks)
            slider.showNumbers = self.trimDialog.oldSliderShowNumbers
            slider.SetValue(slider.GetValue())
        self.trimDialog.Hide()
        if insertMode == 2:
            self.ShowVideoFrame()

    def OnTrimDialogCancel(self, event=None):
        script = self.currentScript
        selections = None
        if self.trimDialog.oldSelections:
            selections = dict(self.trimDialog.oldSelections)
        self.trimDialog.Hide()
        self.OnTrimDialogClear(event)
        if selections:
            script.selections.clear()
            script.selections.update(selections)
            self.SetSelectionsDict(script.selections)
        for slider in self.GetVideoSliderList():
            slider.SetBookmarkHilighting(self.trimDialog.oldhighligthBookmarks)
            slider.showNumbers = self.trimDialog.oldSliderShowNumbers
            slider.SetValue(slider.GetValue())
        if self.previewWindowVisible:
            self.ShowVideoFrame()

    def OnTrimDialogClear(self, event):
        self.DeleteAllSelections()
        self.trimDialog.oldSelections.clear()
        for slider in self.GetVideoSliderList():
            if self.trimDialog.IsShown():
                mode = 1
                slider.selmode = 1
            else:
                mode = 0
                slider.selmode = 0
            slider.ToggleSelectionMode(mode, True)

    def OnClearSelectionsGlobally(self, event):
        self.trimDialog.Hide()
        for slider in self.GetVideoSliderList():
            slider.SetBookmarkHilighting(False)
            mode = 0
            slider.selmode = 0
            slider.ToggleSelectionMode(mode, True)

        for index in xrange(self.scriptNotebook.GetPageCount()):
            script = self.scriptNotebook.GetPage(index)
            script.selections.clear()
        self.SetSelectionsDict(self.currentScript.selections)
        self.videoWindow.Refresh()

    # the following 2 func called from wxp.OptionsDialog, not MainFrame
    def x_OnCustomizeAutoCompList(self, event):
        choices = []
        for keywords in self.avsazdict.values():
            choices += keywords
        choices.sort(key=lambda k: k.lower())
        dlg = wx.Dialog(self, wx.ID_ANY, _('Select autocomplete keywords'), style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        SetFontPPI(dlg)
        listbox = wx.CheckListBox(dlg, wx.ID_ANY, choices=choices)
        for i in range(len(choices)):
            if choices[i] not in self.options['autocompleteexclusions']:
                listbox.Check(i)
        idAll = wx.NewId()
        idNone = wx.NewId()
        idExclude = wx.NewId()
        def OnContextMenuItem(event):
            id = event.GetId()
            value = True if id == idAll else False
            if id in [idAll, idNone]:
                for i in range(len(choices)):
                    listbox.Check(i, value)
            else:
                for i in range(len(choices)):
                    if '_' not in choices[i]:
                        continue
                    filtername = choices[i].lower()
                    if filtername in self.optionsFilters\
                    and self.optionsFilters[filtername][2] == 2:
                        listbox.Check(i, False)
                    if filtername in self.options['filteroverrides']\
                    and self.options['filteroverrides'][filtername][2] == 2:
                        listbox.Check(i, False)
        def OnContextMenu(event):
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idAll)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idNone)
            listbox.Bind(wx.EVT_MENU, OnContextMenuItem, id=idExclude)
            menu = wx.Menu()
            menu.Append(idAll, _('select all'))
            menu.Append(idNone, _('select none'))
            menu.Append(idExclude, _('exclude long names'))
            listbox.PopupMenu(menu)
            menu.Destroy()
        listbox.Bind(wx.EVT_CONTEXT_MENU, OnContextMenu)
        okay  = wx.Button(dlg, wx.ID_OK, _('OK'))
        cancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(listbox, 1, wx.EXPAND|wx.ALL,5)
        sizer.Add(btns, 0, wx.EXPAND|wx.ALL,5)
        dlg.SetSizerAndFit(sizer)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            for i, keyword in enumerate(choices):
                if listbox.IsChecked(i):
                    try:
                        self.options['autocompleteexclusions'].discard(keyword)
                    except KeyError:
                        pass
                else:
                    self.options['autocompleteexclusions'].add(keyword)
        dlg.Destroy()

    def OnConfigureVideoStatusBarMessage(self, event):
        dlg = wx.Dialog(self, wx.ID_ANY, _('Customize the video status bar message'))
        SetFontPPI(dlg)
        label = wx.StaticText(dlg, wx.ID_ANY, _('Video status bar message:'))
        textCtrl = wx.TextCtrl(dlg, wx.ID_ANY, self.videoStatusBarInfo.replace('\t','\\t'), size=(intPPI(500),-1))
        textCtrl.SetSelection(0,0)
        box = wx.StaticBox(dlg, wx.ID_ANY, _('Legend'))
        staticBoxSizer = wx.StaticBoxSizer(box, wx.HORIZONTAL)
        keyList = [
            (
            ('%F', _('Current frame')),
            ('%FC', _('Framecount')),
            ('%T', _('Current time')),
            ('%TT', _('Total time')),
            ('%W', _('Width')),
            ('%H', _('Height')),
            ('%AR', _('Aspect ratio')),
            ('%FR', _('Framerate')),
            ('%FRN', _('Framerate numerator')),
            ('%FRD', _('Framerate denominator')),
            ('%CS', _('Colorspace')),
            ('%BIT', _('Bits per component')),
            ('%FB', _('Field or frame based')),
            ('%P', _('Parity')),
            ('%PS', _('Parity short (BFF or TFF)')),
            ),
            (
            ('%AUR', _('Audio rate')),
            ('%AUL', _('Audio length')),
            ('%AUC', _('Audio channels')),
            ('%AUB', _('Audio bits')),
            ('%AUT', _('Audio type (Integer or Float)')),
            ('%POS', _('Pixel position (cursor based)')),
            ('%HEX', _('Pixel hex color (cursor based)')),
            ('%RGB', _('Pixel rgb color (cursor based)')),
            ('%YUV', _('Pixel yuv color (cursor based)')),
            ('%CLR', _('Pixel color (auto-detect colorspace)')),
            ('%DYR', _('Display YUV -> RGB conversion')),
            ('%Z', _('Program zoom')),
            ('%TR', _('Timeline range')),
            ('%BM', _('Bookmark title')),
            ),
        ]
        for eachList in keyList:
            gridSizer = wx.FlexGridSizer(cols=2, hgap=0, vgap=intPPI(3))
            for key, value in eachList:
                gridSizer.Add(wx.StaticText(dlg, wx.ID_ANY, key), 0, 0)
                gridSizer.Add(wx.StaticText(dlg, wx.ID_ANY, '  -  '+value), 0, 0)
            staticBoxSizer.Add(gridSizer, 0, wx.LEFT|wx.RIGHT, intPPI(20))
        noteText = wx.StaticText(dlg, wx.ID_ANY, _('Note: The "\\t\\t" or "\\T\\T" is used to separate the left and right portions of the status bar\n         message.'))
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(label, 0, wx.BOTTOM, intPPI(5))
        sizer.Add(textCtrl, 0, wx.EXPAND|wx.BOTTOM, intPPI(5))
        sizer.Add(staticBoxSizer, 0, wx.EXPAND|wx.ALL, intPPI(5))
        sizer.Add(noteText, 0, wx.ALL, intPPI(5))
        # Standard buttons
        okay  = wx.Button(dlg, wx.ID_OK, _('OK'))
        okay.SetDefault()
        okay.SetFocus()
        cancel = wx.Button(dlg, wx.ID_CANCEL, _('Cancel'))
        btns = wx.StdDialogButtonSizer()
        btns.AddButton(okay)
        btns.AddButton(cancel)
        btns.Realize()
        dlgSizer = wx.BoxSizer(wx.VERTICAL)
        dlgSizer.Add(sizer, 0, wx.ALL, intPPI(5))
        dlgSizer.Add(btns, 0, wx.EXPAND|wx.ALL, intPPI(5))
        dlg.SetSizer(dlgSizer)
        dlg.Fit()
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            text = textCtrl.GetValue().replace('\\t', '\t')
            self.options['videostatusbarinfo'] = text
            self.videoStatusBarInfo = text
            self.videoStatusBarInfoParsed, self.showVideoPixelInfo = self.ParseVideoStatusBarInfo(self.videoStatusBarInfo)
        dlg.Destroy()

    # GPo  avisynth error font
    def OnConfigureErrorFont(self, event):
        fn,fs,fc =  self.options['errormessagefont'][:3]
        if fc == '':
            fc = 'FF0000'   # red
        fc = fc.strip('$')
        fontData = wx.FontData()
        font = wx.Font(pointSize=fs, family=wx.FONTFAMILY_DEFAULT, style=wx.NORMAL, weight=wx.FONTWEIGHT_NORMAL, face=fn)
        fontData.SetInitialFont(font)
        RGB = tuple(int(fc[i:i+2], 16) for i in (0, 2 ,4))
        fontData.SetColour(RGB)
        parent = wx.FindWindowAtPoint(wx.GetMousePosition())
        if not parent:
            parent = wx.GetApp().GetTopWindow()
        dlg = wx.FontDialog(parent, fontData)
        if dlg.ShowModal() == wx.ID_OK:
            data = dlg.GetFontData()
            font = data.GetChosenFont()
            color = data.GetColour()
            colorHexStr = "$%02x%02x%02x" % color.Get()
            self.options['errormessagefont'] = (font.GetFaceName(), font.GetPointSize(), colorHexStr , '', (0, 0, 0))
        dlg.Destroy()

    def OnContextMenu(self, event):
        # GPo, rare error mouse.capture, fixed with bind(wx.MOUSE_LOST) but leave it
        if self.videoWindow.HasCapture():
            try:
                self.videoWindow.ReleaseMouse()
            except:
                pass
            self.videoWindow.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
        win = event.GetEventObject()

        if isinstance(win, wx.ListCtrl): # autocomplete list
            return

        # GPo, on script enable/disable avisynth lines or change boolean word
        scriptContextMenu = isinstance(win, AvsStyledTextCtrl)
        if scriptContextMenu:
            self.currentScript.refreshAVI = True
            if wx.GetMouseState().LeftIsDown():
                return # moved to right up

        if not hasattr(win,'contextMenu'): # GPo new, script tooltip
            return
        self.lastContextMenuWin = win
        pos = win.ScreenToClient(event.GetPosition())

        if not scriptContextMenu:
            # update 'video -> add tab to group' submenu
            group_menu_id = win.contextMenu.FindItem(_('Add tab to group'))
            if group_menu_id != wx.NOT_FOUND:
                group_menu = win.contextMenu.FindItemById(group_menu_id).GetSubMenu()
                group = self.currentScript.group
                if group is None:
                    group = _('None')
                id = group_menu.FindItem(group)
                group_menu.Check(id, True)
                id = group_menu.FindItem(_('Apply offsets'))
                group_menu.Check(id, self.options['applygroupoffsets'])
                id = group_menu.FindItem(_('Offset also bookmarks'))
                group_menu.Check(id, self.options['offsetbookmarks'])
                id = group_menu.FindItem(_('Freeze Split View frame'))
                group_menu.Check(id, self.splitView_freeze)

            x_id = win.contextMenu.FindItem(_('Save view pos on tab change')) # GPo 2020
            if x_id != wx.NOT_FOUND:
                menu = win.contextMenu.FindItemById(x_id)
                menu.Check(self.saveViewPos==1)
            x_id = win.contextMenu.FindItem(_('Save pos && zoom on tab change')) # GPo 2020
            if x_id != wx.NOT_FOUND:
                menu = win.contextMenu.FindItemById(x_id)
                menu.Check(self.saveViewPos==2)
            x_id = win.contextMenu.FindItem(_('Split View on/off')) # GPo 2020
            if x_id != wx.NOT_FOUND:
                menu = win.contextMenu.FindItemById(x_id)
                menu.Check(self.splitView)
            x_id = win.contextMenu.FindItem(_('Split View alternate')) # GPo 2020
            if x_id != wx.NOT_FOUND:
                menu = win.contextMenu.FindItemById(x_id)
                menu.Check(self.splitViewEx)
            d = {} # do not use self.previewFilterDict or SplitClip cannot find changes
            self.UpdatePreviewFilterMenu(self.ParseScriptPreviewFilters(d))
        try:
            win.PopupMenu(win.contextMenu, pos)
        except AttributeError:
            pass
            #~ print>>sys.stderr, _('Error: no contextMenu variable defined for window')

    # GPo 2020, sliders, etc...
    def OnSlidersContextMenu(self, event):
        win = event.GetEventObject()
        self.lastContextMenuWin = win
        id = win.contextMenu.FindItem(_('Slider update immediately'))
        if id != wx.NOT_FOUND:
            item = win.contextMenu.FindItemById(id)
            if item:
                item.Check(self.options['autosliderupdatedirectly'])
        pos = win.ScreenToClient(event.GetPosition())
        try:
            win.PopupMenu(win.contextMenu, pos)
        except AttributeError:
            pass

    def OnScriptTextChange(self, event):
        if event.GetEventObject() == self.FindFocus():
            self.SetScriptStatusText()
        event.Skip()

    def OnScriptKeyUp(self, event):
        try:
            if self.playing_video:  # GPo 2018
                self.PlayPauseVideo()
                self.currentScript.SetFocus()
        except:
            pass
        self.AutoUpdateVideo()
        event.Skip()

    def OnFocusScriptWindow(self, event):
        self.SetStatusWidths([-1, 0])
        self.SetScriptStatusText()
        self.refreshAVI = True
        self.UpdateTabImages()
        event.Skip()

    def OnFocusVideoWindow(self, event):
        self.SetVideoStatusText()
        self.UpdateTabImages()
        if self.zoomwindow or self.currentScript.lastSplitVideoPos is None: # GPo wx.2.9
            self.SaveLastSplitVideoPos()
        event.Skip()

    def OnPaintVideoWindow(self, event):
        dc = wx.PaintDC(self.videoWindow) # should always be created
        if self.previewWindowVisible:
            # if threaded then paint the video window snapshot ( GetVideoWindowBitmap )
            if self.ClipRefreshPainter and self.bmpVideo:
                mdc = wx.MemoryDC()
                mdc.SelectObject(self.bmpVideo)
                w = self.bmpVideo.GetWidth()
                h = self.bmpVideo.GetHeight()
                self.videoWindow.DoPrepareDC(dc)
                dc.SetUserScale(1, 1)
                x, y = self.videoWindow.GetViewStart()
                dc.Blit(x, y, w, h, mdc, 0, 0)
                return

            if self.splitView or self.snapShotIdx > 0:
                dcc = wx.ClientDC(self.videoWindow)
                self.PaintAVIFrame(dcc, self.currentScript, self.currentframenum, isPaintEvent=True)
            else:
                self.PaintAVIFrame(dc, self.currentScript, self.currentframenum, isPaintEvent=True)

    def OnEraseBackground(self, event=None):
        if event is not None:
            dc = event.GetDC()
        else:
            dc = wx.ClientDC(self.videoWindow)
        if dc is not None:
            script = self.currentScript
            if script.AVI is not None:
                if self.options['use_customvideobackground']:
                    background_color = self.options['videobackground']
                else: # using a custom handler for EVT_ERASE_BACKGROUND causes
                      # the background to lose the theme's color on Windows
                    background_color = self.videoWindow.GetBackgroundColour()
                dc.SetBackground(wx.Brush(background_color))
                w_dc, h_dc = dc.GetSize()
                w_scrolled, h_scrolled = self.videoWindow.GetVirtualSize()
                x0, y0 = self.videoWindow.GetViewStart()
                zfa = intPPI(3 if self.zoomfactor <= 2 else 4) # GPo, must also change ShowVideoFrame()
                if y0 < self.yo:
                    dc.SetClippingRegion(0, 0, w_dc, self.yo - y0)
                    dc.Clear()
                    dc.DestroyClippingRegion()
                if x0 < self.xo:
                    dc.SetClippingRegion(0, 0, self.xo - x0, h_dc)
                    dc.Clear()
                    dc.DestroyClippingRegion()
                if h_dc == h_scrolled:
                    bottom = h_dc - round(script.AVI.DisplayHeight * self.zoomfactor) - self.yo
                else:
                    if self.splitView:
                        bottom = h_dc - (h_scrolled - y0) + self.yo
                    else:
                        bottom = h_dc - (h_scrolled - y0) + zfa
                if bottom > 0:
                    dc.SetClippingRegion(0, h_dc - bottom, w_dc, bottom)
                    dc.Clear()
                    dc.DestroyClippingRegion()
                if w_dc == w_scrolled:
                    if self.splitView:
                        right = w_dc - round(self.extended_width * self.zoomfactor) - self.xo
                    else:
                        right = w_dc - int(script.AVI.DisplayWidth * self.zoomfactor) - self.xo
                else:
                    if self.splitView:
                        wd = w_scrolled - int(self.extended_width * self.zoomfactor) - self.xo
                    elif self.extended_move:
                        wd = max((w_scrolled - int(script.AVI.DisplayWidth * self.zoomfactor)-self.xo), zfa)
                    else:
                        wd = zfa
                    right = w_dc - (w_scrolled - x0) + wd
                if right > 0:
                    dc.SetClippingRegion(w_dc - right, 0, right, h_dc)
                    dc.Clear()
                    dc.DestroyClippingRegion()
                return
        if event is not None:
            event.Skip()

    # GPo, changed (sync with zoomfactor)
    def OnZoomInOut(self, event):
        id = event.GetId()
        vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
        for vidmenu in vidmenus:
            menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Zoom'))).GetSubMenu()
            menuItem = menu.FindItemById(id)
            if menuItem:
                label = menuItem.GetLabel()
                break

        zoom = int(round(self.zoomfactor*100))
        if label == _('Zoom in'):
            for i in range(6):
                menuItem = menu.FindItemByPosition(i)
                if menuItem:
                    label = menuItem.GetLabel()
                    z = label[:label.find('%')]
                    if int(z) > zoom or i == 5:
                        self.OnMenuVideoZoom(None, menu.FindItemByPosition(i))
                        break
        else:
            for i in reversed(range(5)):
                menuItem = menu.FindItemByPosition(i)
                if menuItem:
                    label = menuItem.GetLabel()
                    z = label[:label.find('%')]
                    if int(z) < zoom or i == 0:
                        self.OnMenuVideoZoom(None, menu.FindItemByPosition(i))
                        break

    def OnCharHook(self, event):
        if event.GetKeyCode() != wx.WXK_ESCAPE:
            event.Skip()
            return
        if self.separatevideowindow:
             if self.videoDialog.IsFullScreen():
                self.OnLeftDClickVideoWindow(None)
                return
        elif self.IsFullScreen():
            self.OnLeftDClickVideoWindow(None)
            return
        if not self.useEscape:
            event.Skip()
            return

        shortcut = 'Escape'
        if event.ShiftDown():
            shortcut = 'Shift+' + shortcut
        if event.AltDown():
            shortcut = 'Alt+' + shortcut
        if event.ControlDown():
            shortcut = 'Ctrl+' + shortcut
        IsReserved = shortcut in self.options['reservedshortcuts']
        if IsReserved and self.FindFocus() == self.currentScript\
        and (self.currentScript.AutoCompActive() or self.currentScript.CallTipActive()):
            self.currentScript.CmdKeyExecute(wx.stc.STC_CMD_CANCEL)
        elif IsReserved and self.cropDialog.IsShown():
            self.OnCropDialogCancel(None)
        elif IsReserved and self.trimDialog.IsShown():
            self.OnTrimDialogCancel(None)
        else:
            self.MacroExecuteMenuCommand(shortcut)

# Utility functions
    def ExitProgram(self, restart=False):
        # Don't exit if saving an avi
        try:
            if self.dlgAvs2avi.IsShown():
                return
        except AttributeError:
            pass

        if self.readFrameProps:
            self.propWindow.Close()
        self.StopPlayback()

        # Check if macros are still running
        macroShown = clipShown = False
        for thread in threading.enumerate():
            if thread.name == 'MacroThread' and not macroShown:
                macroShown = True
                dlg = wx.MessageDialog(self, _('A macro is still running. Close anyway?'),
                                       _('Warning'), wx.OK|wx.CANCEL|wx.ICON_EXCLAMATION)
                ID = dlg.ShowModal()
                dlg.Destroy()
                if ID == wx.ID_CANCEL:
                    return
            elif thread.name == 'clip' and not clipShown:
                clipShown = True
                dlg = wx.MessageDialog(self, _('A clip thread is still running. Close anyway?'),
                                       _('Warning'), wx.OK|wx.CANCEL|wx.ICON_EXCLAMATION)
                ID = dlg.ShowModal()
                dlg.Destroy()
                if ID == wx.ID_CANCEL:
                    return

        # Must be before self.options['promptexitsave'] loop
        self.HidePreviewWindow()
        previewvisible = False  # Hide always the preview on startup
        self.splitView = False
        self.DisableResizeFilter()

        frame = self.GetFrameNumber()
        if self.separatevideowindow:
            if self.videoDialog.IsIconized():
                self.videoDialog.Iconize(False)
            if self.videoDialog.IsFullScreen():
                self.videoDialog.ShowFullScreen(show=False)
            if self.videoDialog.IsMaximized():
                self.options['maximized2'] = True
                self.videoDialog.Maximize(False) # Is useless, the size is not restored if the dialog not visible
            else:
                self.options['maximized2'] = False
                # wx.python: if dialog not visible the size is not restored, so always the maximazed rect is returned
                # workaround: the dimensions2 is always saved on OnResize event
                self.options['dimensions2'] = (self.videoDialog.GetRect())

        if self.IsIconized():
            self.Iconize(False)
        if self.cropDialog.IsShown():
            self.OnCropDialogCancel(None)
        if self.trimDialog.IsShown():
            self.OnTrimDialogCancel(None)
        if self.IsFullScreen():
            self.ShowFullScreen(show=False)
        # for save session (goto last current index)
        currIndex = self.scriptNotebook.GetSelection()
        # save the current timeline bookmarks
        #self.currentScript.bookmarks = self.GetBookmarkDict()

         # Save scripts if necessary
        if self.options['promptexitsave']:
            ctrl = None
            for index in xrange(self.scriptNotebook.GetPageCount()):
                script = self.scriptNotebook.GetPage(index)
                tabTitle = self.scriptNotebook.GetPageText(index)
                # GPo 2018
                if script.GetModify() and (not self.options['promptexitsaveonlyexisting'] or script.filename):
                    self.scriptNotebook.SetSelection(index) # for the bookmarks needed (tab must load the script bookmarks)
                    if not ctrl:
                        dlg = wx.MessageDialog(self, _('Save changes before closing?  Press Ctrl to apply to all'), tabTitle, wx.YES_NO|wx.CANCEL)
                        ID = dlg.ShowModal()
                        dlg.Destroy()
                        ctrl = wx.GetKeyState(wx.WXK_CONTROL)
                    if (ID == wx.ID_YES and not self.SaveScript(script.filename, index) or ID == wx.ID_CANCEL):
                        return

        # Save the session
        if self.backupTimer.IsRunning():
            self.backupTimer.Stop()
        if self.options['startupsession'] or restart:
            self.scriptNotebook.SetSelection(currIndex)
            self.SaveSession(self.lastSessionFilename, saverecentdir=False,
                frame=frame, previewvisible=previewvisible)
        self.options['last_preview_placement'] = self.mainSplitter.GetSplitMode()
        # Save the text in the scrap window
        scrapCtrl = self.scrapWindow.textCtrl
        self.options['scraptext'] = (scrapCtrl.GetText(), scrapCtrl.GetAnchor(), scrapCtrl.GetCurrentPos())

        # Save the zoom factor
        vidmenu = self.videoWindow.contextMenu
        menu = vidmenu.FindItemById(vidmenu.FindItem(_('&Zoom'))).GetSubMenu()
        for i, menuItem in enumerate(menu.GetMenuItems()):
            if menuItem.IsChecked():
                if self.options['startupwithlastzoom'] or i in [6, 7]:   # GPo 2018 save only 100% and fit or fill or all if option
                    self.options['zoomindex'] = i
                else:
                    self.options['zoomindex'] = 2  # 100%
                break

        # Save the program position
        if self.IsMaximized():
            self.options['maximized'] = True
            self.Maximize(False)
        else:
            self.options['maximized'] = False
        #self.Refresh()
        self.Update()

        x, y, w, h = self.GetRect()
        self.options['dimensions'] = (max(x,-5), max(y,-5), w, h)
        x, y, w, h = self.propWindow.GetRect()
        self.options['propwindowrect'] = (max(-5,x), max(-5,y), w, h)
        # Save the crop choice
        self.options['cropchoice'] = self.cropDialog.ctrls['choiceInsert'].GetCurrentSelection()
        # Save the trim options
        self.options['triminsertchoice'] = self.trimDialog.ctrls['choiceInsert'].GetCurrentSelection()
        self.options['trimmarkframes'] = self.markFrameInOut
        if self.invertSelection:
            self.options['trimreversechoice'] = 1
        else:
            self.options['trimreversechoice'] = 0
        # reset property wnd parent height (dbl click changed the size, so we need restore the default height)
        if self.propWindowParent > 0:
            self.options['propwindowparentsize'] = self.propWindow.parentDefHeight
        # Save the persistent options
        self.options['exitstatus'] = 0 if not restart else 2
        f = open(self.optionsfilename, mode='wb')
        cPickle.dump(self.options, f, protocol=0)
        f.close()
        if os.path.isdir(os.path.dirname(self.macrosfilename)):
            f = open(self.macrosfilename, mode='wb')
            cPickle.dump(self.optionsMacros, f, protocol=0)
            f.close()
        # Clean up
        wx.TheClipboard.Flush()
        self.AppClosing = True # GPo do not use threads for releasing clips
        pyavs.ExitRoutines()
        try:
            if self.boolSingleInstance:
                self.argsPosterThread.Stop()
        except:
            sys.exit()

        for item in self.Thread_List:
            th, q = item
            if th.isAlive():
                sys.exit()  # we must force termination or program doesn't close
                #os._exit(0)
        self.Destroy()
        if restart:
            if os.name == 'nt':
                os.execl(sys.executable, '"{}"'.format(sys.executable), *sys.argv[0])
                #os.execv(sys.executable, ['python'] + sys.argv[0])

    def NewTabFromTemplate(self, event):
        txt = self.options['templates'].get('*')
        if not txt:
            txt = ''
            wx.MessageBox(_('In order to be able to use this function you have to enter a file extension '+
                            'with the character * under the file extension-based templates'))
        self.NewTab(copyselected=False, copytab=False, text=txt, select=True, insertnext=False)

    @AsyncCallWrapper
    def NewTab(self, copyselected=True, copytab=False, text='', select=True, insertnext=False, framenum=None,  selections=None, bookmarks=None):
        r'''NewTab(copyselected=True)

        Creates a new tab (automatically named "New File (x)", where x is an appropriate
        integer).  If any text was selected in the most recent tab and 'copyselected' is
        True, it is automatically copied over to the new tab's text.

        '''
        if self.cropDialog.IsShown():
            wx.MessageBox(_('Cannot create a new tab while crop editor is open!'),
                          _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        if self.trimDialog.IsShown():
            wx.MessageBox(_('Cannot create a new tab while trim editor is open!'),
                          _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False

        self.StopPlayback()

        if self.currentScript.GetClientSize()[self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL] < 6:
            self.SetMinimumScriptPaneSize()

        # Determine the name of the tab (New File (x))
        index = self.scriptNotebook.GetPageCount()
        if self.options['multilinetab']:
            rows = self.scriptNotebook.GetRowCount()
        iMax = 0
        curIndex = -1
        isCopy = False
        # Python 3 has no ur'...' raw unicode string syntax. Use r'...' instead:
        # To create 2.7/3.x-Python compatible code, use conditional code that'll decode the byte string
        # produced by r'...' to a unicode object only on Python 2. Use module six to help with that:
        from six import u
        re_newfile = re.compile(u(r'\*?\s*{0}\s*\((\d+)\)\s*(?:\.avsi?)?$').format(self.NewFileName), re.I)
        # old Python2-only method: re_newfile = re.compile(ur'\*?\s*{0}\s*\((\d+)\)\s*(?:\.avsi?)?$'.format(self.NewFileName), re.I)
        for i in range(index):
            title = self.scriptNotebook.GetPageText(i)
            match = re_newfile.match(title)
            if match:
                iNewFile = int(match.group(1))
                if iNewFile > iMax:
                    iMax = iNewFile
            if insertnext and self.currentScript == self.scriptNotebook.GetPage(i):
                curIndex = i
        # Create a new script window instance
        scriptWindow = self.createScriptWindow()

        # Get text and set some script variables
        if text:
            copytab = False
        else:
            if copytab:
                text = self.currentScript.GetText()
            elif copyselected:
                text = self.currentScript.GetSelectedText()
                copytab = bool(text.strip())
        # Add the tab to the notebook, pasting the text (unless it only contains whitespace)
        if text.strip():
            if copytab:
                isCopy = True
                scriptWindow.workdir = self.currentScript.workdir
                scriptWindow.encoding = self.currentScript.encoding
                scriptWindow.eol = self.currentScript.eol
                scriptWindow.group = self.currentScript.group # must be before scriptWindow.SetText (or just call UpdateScriptTabname here)
                scriptWindow.group_frame = self.currentScript.group_frame
                scriptWindow.lastFramenum = self.currentScript.lastFramenum
                scriptWindow.lastLength = self.currentScript.lastLength
                scriptWindow.bookmarks = self.GetBookmarkDict()
                scriptWindow.matrix = list(self.currentScript.matrix)
                scriptWindow.selections.update(self.currentScript.selections)
                scriptWindow.resizeFilter = self.currentScript.resizeFilter
                if select:
                    scriptWindow.lastSplitVideoPos = self.currentScript.lastSplitVideoPos  # GPo 2020, if copy keep the splitters
                    if self.currentScript.lastSplitSliderPos is not None:
                        scriptWindow.lastSplitSliderPos = self.currentScript.lastSplitSliderPos # GPo 2020
            else:
                scriptWindow.lastFramenum = framenum if framenum  else 0
                if bookmarks:
                    scriptWindow.bookmarks.update(bookmarks)
                if selections:
                    scriptWindow.selections.update(selections)

            scriptWindow.ParseFunctions(text)
            if curIndex > -1:
                curIndex += 1
                self.scriptNotebook.InsertPage(curIndex, scriptWindow,'%s (%s)' % (self.NewFileName, iMax+1), select=False)
                curIndex = min(curIndex, self.scriptNotebook.GetPageCount()-1)
            else:
                self.scriptNotebook.AddPage(scriptWindow,'%s (%s)' % (self.NewFileName, iMax+1), select=False)
                curIndex = self.scriptNotebook.GetPageCount()-1

            scriptWindow.SetText(text)
            if select:
                if self.options['tabautopreview']:
                    self.HidePreviewWindow()
                else:
                    self.refreshAVI = True
                    #self.ClipRefreshPainter = self.GetVideoWindowBitmap()
                self.scriptNotebook.SetSelection(curIndex)
        else:
            if select:
                self.HidePreviewWindow()
            if curIndex > -1:
                curIndex += 1
                self.scriptNotebook.InsertPage(curIndex, scriptWindow,'%s (%s)' % (self.NewFileName, iMax+1), select=select)
            else:
                self.scriptNotebook.AddPage(scriptWindow,'%s (%s)' % (self.NewFileName, iMax+1), select=select)
                curIndex = self.scriptNotebook.GetPageCount()-1

        if not isCopy: # set the resizeFilter if not script copied
            scriptWindow.resizeFilter = self.resizeFilter

        if select:
            self.currentScript = scriptWindow
            self.SetSelectionsDict(scriptWindow.selections)
            scriptWindow.SetFocus()
            scriptWindow.EnsureCaretVisible()

        self.UpdateTabImages()

        # a workaroud for multiline notebook issue
        if self.options['multilinetab']:
            if rows != self.scriptNotebook.GetRowCount():
                w, h = self.scriptNotebook.GetSize()
                self.scriptNotebook.SetSize((w, h-1))
                self.scriptNotebook.SetSize((w, h))

        self.SetMinimumScriptPaneSize()

        return curIndex

    # GPo
    def FindTabByName(self, fname, select=True):
        for index in xrange(self.scriptNotebook.GetPageCount()):
            title = self.scriptNotebook.GetPageText(index)
            if title.lower().startswith(fname.lower()) and (len(title)+4 >= len(fname)):
                if select:
                    self.StopPlayback()
                    self.SelectTab(index)
                return index
        return -1

    def StopPlayback(self):
        if self.playing_video:
            self.PlayPauseVideo()

    def CheckPlayback(self):
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
            self.playing_video = ''
        elif self.playing_video == '':
            self.PlayPauseVideo()

    @AsyncCallWrapper
    def OpenFile(self, filename='', default='', f_encoding=None, eol=-1, workdir=None,
                 scripttext=None, setSavePoint=True, splits=None, framenum=None,
                 last_length=None, group=-1, group_frame=None, bookmarks=None, snapshots=None,
                 selections=None, matrix=None,
                 hidePreview=False, loadBookmarks=True):
        r'''OpenFile(filename='', default='')

        If the string 'filename' is a path to an Avisynth script, this function opens
        the script into a new tab.  If 'filename' is a path to a non-script file, the
        filename is inserted as a source (see the GetSourceString function for details).

        If 'filename' is not supplied, the user is prompted with an Open File dialog
        box with 'default' as the default filename; it can be just a directory or
        basename.

        On loading a session file loadBookmarks is False and hidePreview is True
        bookmarks loading is then handled on LoadSession
        Loading avisynth in thread:
            loading more than one file at a time is not possible with visible video window
            and leads to errors, then the preview must be hidden.
        '''
        self.StopPlayback()
        # Get filename via dialog box if not specified
        if not filename:
            default_dir, default_base = (default, '') if os.path.isdir(default) else os.path.split(default)
            initial_dir = default_dir if os.path.isdir(default_dir) else self.GetProposedPath(only='dir')
            #~ filefilter = _('AviSynth script (*.avs, *.avsi)|*.avs;*.avsi|All files (*.*)|*.*')
            extlist = self.options['templates'].keys()
            extlist.sort()
            extlist2 = [s for s in extlist if not s.startswith('avs')]
            extlist1 = ', '.join(extlist2)
            extlist2 = ';*.'.join(extlist2)
            filefilter = (_('AviSynth script') + ' (avs, avsi)|*.avs;*.avsi|' +
                          _('Source files') + ' (%(extlist1)s)|*.%(extlist2)s|' +
                          _('All files') + ' (*.*)|*.*') %  locals()
            dlg = wx.FileDialog(self,_('Open a script or source'), initial_dir, default_base,
                                filefilter, wx.OPEN|wx.FILE_MUST_EXIST|wx.MULTIPLE)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filenames = dlg.GetPaths()
                dlg.Destroy()
                if len(filenames) == 1:
                    filename = filenames[0]
                else:
                    for filename in filenames:
                        if filename:
                            self.OpenFile(filename, hidePreview=True)
                    return
            else:
                dlg.Destroy()

        # Open script if filename exists (user could cancel dialog box...)
        if filename:
            # Process the filename
            dirname, basename = os.path.split(filename)
            root, ext = os.path.splitext(basename)
            if ext.lower() == '.ses': # Treat the file as a session file
                if not self.LoadSession(filename):
                    wx.MessageBox(_('Damaged session file'), _('Error'), wx.OK|wx.ICON_ERROR)
                return
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname
            if ext.lower() not in ('.avs', '.avsi', '.vpy'): # Treat the file as a source
                # Make a new tab if current one is not empty
                indexCur = self.scriptNotebook.GetSelection()
                txt = self.scriptNotebook.GetPage(indexCur).GetText()
                title = self.scriptNotebook.GetPageText(indexCur)
                if txt or not title.startswith(self.NewFileName):
                    self.NewTab(copyselected=False)
                self.InsertSource(filename)
                if not hidePreview and self.previewWindowVisible:
                    self.ShowVideoFrame()
                elif self.previewWindowVisible:
                    self.HidePreviewWindow()
            else: # Treat the file as an avisynth script
                if scripttext is None:
                    scripttext, f_encoding, eol = self.GetMarkedScriptFromFile(filename)
                indexCur = self.scriptNotebook.GetSelection()
                if loadBookmarks: # no Session
                    script = self.scriptNotebook.GetPage(indexCur)
                    script.bookmarks = self.GetBookmarkDict()

                forceSetBookmarks = False
                # If script already exists in a tab, select it
                for idx in xrange(self.scriptNotebook.GetPageCount()):
                    script = self.scriptNotebook.GetPage(idx)
                    if filename == script.filename:
                        index = idx
                        # handle script bookmarks
                        forceSetBookmarks = idx != indexCur
                        if forceSetBookmarks:
                            newScript = self.scriptNotebook.GetPage(idx)
                            last_bookmarks = dict(newScript.bookmarks)
                            newScript.bookmarks = {} # disable difWarn
                            self.SelectTab(idx)
                            if len(newScript.bookmarks) < 1: # no bookmarks from script, set last bookmarks
                                newScript.bookmarks = last_bookmarks
                                if self.tabChangeLoadBookmarks:
                                    self.SetTabBookmarks(newScript.bookmarks)
                                forceSetBookmarks = False

                        if scripttext != script.GetText():
                            dlg = wx.MessageDialog(self, _('Reload the file and lose the current changes?'),
                                                   os.path.basename(filename), wx.YES_NO)
                            ID = dlg.ShowModal()
                            dlg.Destroy()
                            if ID != wx.ID_YES:
                                return
                            forceSetBookmarks = True # clear and load bookmarks from script
                            script.ParseFunctions(scripttext)
                            pos = script.GetCurrentPos()
                            script.SetText(scripttext)
                            script.GotoPos(pos)
                        break
                else:
                    # Make a new tab if current one is not empty
                    txt = self.scriptNotebook.GetPage(indexCur).GetText()
                    title = self.scriptNotebook.GetPageText(indexCur)
                    if txt == "" and title.startswith(self.NewFileName):
                        index = indexCur
                    else:
                        self.NewTab(select=False, framenum=framenum, bookmarks=bookmarks, selections=selections)
                        index = self.scriptNotebook.GetPageCount() - 1
                    script = self.scriptNotebook.GetPage(index)
                    if dirname != '':
                        self.SetScriptTabname(basename, script)
                        script.filename = filename
                        script.workdir = dirname
                    elif not root.startswith(self.NewFileName):
                        self.SetScriptTabname(root, script)
                    script.ParseFunctions(scripttext)
                    script.SetText(scripttext)
                    self.UpdateRecentFilesList(filename)

                if f_encoding is not None:
                    script.encoding = f_encoding
                if eol != -1:
                    script.eol = eol
                if workdir is not None:
                    script.workdir = workdir
                if framenum is not None:
                    script.lastFramenum = framenum
                if last_length is not None:
                    script.lastLength = last_length
                if splits is not None:
                    script.lastSplitVideoPos = splits[0]
                    script.lastSplitSliderPos = splits[1]
                    script.sliderWindowShown = splits[2]
                if group != -1 and script.group != group:
                    script.group = group
                    self.UpdateScriptTabname(index=index)
                if group_frame is not None:
                    script.group_frame = group_frame
                if setSavePoint:
                    script.EmptyUndoBuffer()
                    script.SetSavePoint()
                if snapshots is not None:
                    self.GetSnapShotFromSession(script, snapshots)
                if matrix is not None:
                    script.matrix = matrix

                if hidePreview and self.previewWindowVisible:
                    self.HidePreviewWindow()
                # handle the script bookmarks
                bCount = 0
                if loadBookmarks: # only on loading session False
                    if bookmarks: # only on reopen closed tab, but normaly bookmarks {}
                        tbc = self.tabChangeLoadBookmarks
                        self.tabChangeLoadBookmarks = False
                        try:
                            self.scriptNotebook.SetSelection(index)
                        finally:
                            script = self.scriptNotebook.GetPage(index)
                            bCount = len(bookmarks)
                            script.bookmarks = None
                            script.bookmarks = dict(bookmarks)
                            self.tabChangeLoadBookmarks = tbc
                            self.SetTabBookmarks(script.bookmarks)
                    else:
                        self.scriptNotebook.SetSelection(index)
                        script = self.scriptNotebook.GetPage(index)
                        if forceSetBookmarks or (index == indexCur): # then bookmarks must set
                            if self.tabChangeLoadBookmarks:
                                self.DeleteAllFrameBookmarks(bmtype=0)
                                self.titleDict.clear()
                                if ext.lower() == '.avs' and self.options['bookmarksfromscript']:
                                    bCount = self.OnMenuBookmarksFromScript(difWarn=False)
                        elif (ext.lower() == '.avs') and self.options['bookmarksfromscript']:
                            bCount = len(script.bookmarks)
                    if selections is not None: # only on session or reopen closed tab
                        script.selections.clear()
                        script.selections.update(selections)
                        self.SetSelectionsDict(script.selections)
                else:
                    self.scriptNotebook.SetSelection(index) # only on load session


                if self.previewWindowVisible and self.extended_move: # on load session not visible
                    script.refreshAVI = True
                    if self.zoomwindow:
                        self.ShowVideoFrame(forceCursor=True)  # GPo 2020, keep extended move and reset XY
                    else:
                        self.ShowVideoFrame(scroll=(0,0), forceCursor=True)  # GPo 2020, keep extended move and reset XY
                else:
                    self.extended_move = False  # reset only if not visible

                if not self.previewWindowVisible and loadBookmarks and (ext.lower() == '.avs'):
                    self.GetStatusBar().SetStatusText(_('%d Bookmarks imported') % bCount)

                return index

    def GetMarkedScriptFromFile(self, filename, returnFull=False):
        txt, f_encoding, eol = self.GetTextFromFile(filename)
        lines = txt.rstrip().split('\n')
        lines.reverse()
        header = '### AvsP marked script ###'

        if self.options['savemarkedavs'] and (lines[0] == header):  # GPo, added save option must also enabled
            newlines = []
            for line in lines[1:]:
                if line == header:
                    break
                if line.startswith('# '):
                    newlines.append(line[2:])
                else:
                    if returnFull:
                        return (txt, txt), f_encoding, eol
                    else:
                        return txt, f_encoding, eol

            newlines.reverse()

            # GPo read now the original script
            orgtxt = ''
            idx = txt.find(header)
            if idx > 1:
                orgtxt = txt[:idx-1].rstrip()

            # GPo, now compare it with the marked part
            if self.getCleanText('\n'.join(newlines), False).rstrip() != orgtxt:
                dlg = wx.MessageDialog(self, _('AvsPmod marked script and original script different.\n\n' +
                                               'If you load the marked script:\n'
                                               'Changes made with another editor are not visible and will be lost when saving again.\n\n' +
                                               'If you not load the marked script:\n'+
                                               'You must remove the marked part manually bevor saving again.\n' +
                                               'If this message appears while loading from session file, you must '+
                                               'reopen the script to see the hiden text\n\n' +
                                               'Do you want to load the AvsPmod marked script?'),
                                             _('Warning'), wx.YES_NO)
                ID = dlg.ShowModal()
                dlg.Destroy()
                if ID != wx.ID_YES:
                    if returnFull:
                        return (txt, txt), f_encoding, eol
                    else:
                        return txt, f_encoding, eol

            if returnFull:
                return ('\n'.join(newlines), txt), f_encoding, eol
            else:
                return '\n'.join(newlines), f_encoding, eol
        else:
            if returnFull:
                return (txt, txt), f_encoding, eol
            else:
                return txt, f_encoding, eol

    def GetTextFromFile(self, filename):
        '''Return text and encoding from a file'''

        with open(filename, mode='rb') as f:
            raw_txt = f.read()

        boms = ((codecs.BOM_UTF8, 'utf-8-sig'),
                (codecs.BOM_UTF16_LE, 'utf-16-le'),
                (codecs.BOM_UTF16_BE, 'utf-16-be'),
                (codecs.BOM_UTF32_LE, 'utf-32-le'),
                (codecs.BOM_UTF32_BE, 'utf-32-be'))
        for bom, f_encoding in boms:
            if raw_txt.startswith(bom):
                raw_txt = raw_txt[len(bom):]
                break
        else:
            f_encoding = 'utf8'
        try:
            txt = raw_txt.decode(f_encoding)
        except UnicodeDecodeError:
            f_encoding = encoding
            txt = raw_txt.decode(f_encoding)
        if '\r' in txt:
            eol = 'crlf'
            txt = txt.replace('\r\n', '\n') # to simplify text handling on macros and avoid mixing line endings
        elif '\n' in txt:
            eol = 'lf'
        else:
            eol = None
        return txt, f_encoding, eol

    def OnMenuFileClearRecentFiles(self, event):
        self.options['recentfiles'] = []
        menu = self.GetMenuBar().GetMenu(0)
        nMenuItems = menu.GetMenuItemCount()
        i = nMenuItems - 1 - 2
        while i >= 0:
            menuItem = menu.FindItemByPosition(i)
            if menuItem.IsSeparator():
                break
            i -= 1
        if i == 0:
            return
        pos = i + 1
        nNameItems = (nMenuItems - 1 - 2) - pos + 1
        if nNameItems > 0:
            for i in range(nNameItems):
                badMenuItem = menu.FindItemByPosition(pos)
                menu.Delete(badMenuItem.GetId())

    def UpdateRecentFilesList(self, filename=None):
        # Update the persistent internal list
        if filename is not None:
            if type(filename) != unicode:
                filename = unicode(filename, encoding)
            # Add the filename to the internal list
            if not os.path.isfile(filename):
                return
            if self.options['recentfiles'] is None:
                self.options['recentfiles'] = []

            if filename in self.options['recentfiles']:
                return

            self.options['recentfiles'].insert(0, filename)
            n1 = len(self.options['recentfiles'])
            n2 = self.options['nrecentfiles']
            if n1 > n2:
                self.options['recentfiles'] = self.options['recentfiles'][:n2]
            nameList = [filename]
        else:
            if self.options['recentfiles'] is None:
                return
            nameList = self.options['recentfiles'][::-1]
        # Find the menu position
        menu = self.GetMenuBar().GetMenu(0)
        nMenuItems = menu.GetMenuItemCount()
        i = nMenuItems - 1 - 2
        while i >= 0:
            menuItem = menu.FindItemByPosition(i)
            if menuItem.IsSeparator():
                break
            i -= 1
        if i == 0:
            return
        # Insert the new menu items
        pos = i + 1
        for name in nameList:
            if len(name) > 43:
                label = name[:15] + '...' + name[-25:]
            else:
                label = name
            newMenuItem = menu.Insert(pos, wx.ID_ANY, label, _("Open this file"))
            self.Bind(wx.EVT_MENU, self.OnMenuFileRecentFile, newMenuItem)
        # Renumber and delete extra menu items
        nMenuItems = menu.GetMenuItemCount()
        nNameItems = (nMenuItems - 1 - 2) - pos + 1
        nMax = self.options['nrecentfiles']
        if nNameItems > nMax:
            item_pos = pos + nMax
            for i in range(nNameItems-nMax):
                badMenuItem = menu.FindItemByPosition(item_pos)
                menu.Delete(badMenuItem.GetId())
            nNameItems = nMax
        prefix = '&{0}  '
        prefix_len = len(prefix) - 3
        for i in range(nNameItems):
            menuItem = menu.FindItemByPosition(pos + i)
            menuLabel = menuItem.GetItemLabelText()
            if menuLabel != menuItem.GetItemLabel(): # GetAccel
                menuLabel = menuLabel[prefix_len:]
            accel = prefix.format((i + 1) % 10) if i < 10 else ''
            menuItem.SetItemLabel(accel + menuLabel)

    def UndoCloseTab(self):
        '''Reopen the last closed tab'''
        if self.lastClosed:
            self.LoadTab(self.lastClosed)
            self.ReloadModifiedScripts()

    @AsyncCallWrapper
    def CloseTab(self, index=None, prompt=False, discard=False):
        r'''CloseTab(index=None, prompt=False, discard=False)

        Closes the tab at integer 'index', where an index of 0 indicates the first
        tab. If 'index' is None (the default), the function will close the currently
        selected tab.

        If the argument 'discard' is True any unsaved changes are lost.  Otherwise,
        if 'prompt' is True the program will prompt the user with a dialog box to
        save the file if there are any unsaved changes.  If 'prompt' is False, the
        function will not prompt the user and will close the script only saving
        changes on scripts that already exist on the filesytem.

        '''
        # Get the script and corresponding index
        self.StopPlayback() # GPo 2020

        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False

        if self.AviThread_Running(script):
            self.HidePreviewWindow()
            return False

        if self.splitView:
            self.splitView = False
            if self.previewWindowVisible:
                self.ShowVideoFrame(forceLayout=True)
        if self.SplitClipCtrl.IsActive:
            self.SplitClipCtrl.Close()

        # Prompt user to save changes if necessary
        if not discard and script.GetModify():
            if prompt and not (self.options['closeneversaved'] and not script.filename):
                #~ self.HidePreviewWindow()
                tabTitle = self.scriptNotebook.GetPageText(index)
                dlg = wx.MessageDialog(self, _('Save changes before closing?'),
                    tabTitle, wx.YES_NO|wx.CANCEL)
                ID = dlg.ShowModal()
                dlg.Destroy()
                if (ID == wx.ID_YES and not self.SaveScript(script.filename, index) or
                    ID == wx.ID_CANCEL):
                    return False
            elif script.filename:
                self.SaveScript(script.filename, index)

        if not self.AppClosing:
            if not self.AviFree(script):
                return False

        # Save last state
        self.lastClosed = self.GetTabInfo(index)

        self.snapShotIdx = 0
        for key in script.snapShots.keys():
            script.snapShots[key] = utils.emptySnapShot

        script.lastFramenum = None # GPo, disable OnPageChanged

        # If only 1 tab, make another
        if self.scriptNotebook.GetPageCount() == 1:
            if self.previewWindowVisible:
                self.HidePreviewWindow()
            self.splitView = False
            self.DeleteFrameBookmark(None, refreshVideo=False, refreshProgram=True) # GPo, clear the bookmarks
            self.NewTab(copyselected=False)
            self.SetScriptTabname(self.NewFileName, index=1)

        if self.options['multilinetab']:
            rows = self.scriptNotebook.GetRowCount()

        if script.FrameThread:
            script.FrameThread.Exit()

        self.scriptNotebook.DeletePage(index)

        self.currentScript = self.scriptNotebook.GetPage(self.scriptNotebook.GetSelection())
        self.UpdateTabImages()
        if self.options['multilinetab']:
            if rows != self.scriptNotebook.GetRowCount():
                w, h = self.scriptNotebook.GetSize()
                self.scriptNotebook.SetSize((w, h-1))
                self.scriptNotebook.SetSize((w, h))
                self.SetMinimumScriptPaneSize() # GPo new
        return True

     # GPo 2022, changed
    def CloseAllTabs(self, discard=False, showSaveDlg=True):
        self.StopPlayback()
        needDlg = True
        if self.scriptNotebook.GetPageCount() == 1:
            needDlg = self.scriptNotebook.GetPage(0).GetText() != ''
        if needDlg and showSaveDlg:
            dlg = wx.MessageDialog(self, _('Save session before closing all tabs?'),
                _('Warning'), wx.YES_NO|wx.CANCEL)
            ID = dlg.ShowModal()
            dlg.Destroy()
            if ID == wx.ID_CANCEL:
                return
            if ID == wx.ID_YES:
                if not self.SaveSession():
                    return

        # It's tricky, the close order must be that the selection index is not changed
        # otherwise on each tab closing PageChanging and PageChange is called.
        # and finally we must delete the message query bevore we delete the last tab (Bug?)
        self.HidePreviewWindow()
        count = self.scriptNotebook.GetPageCount()-1
        self.scriptNotebook.SetSelection(count)
        idx = self.scriptNotebook.GetSelection()
        cl = -1
        for index in xrange(count,-1,-1):
            if index != idx:
                cl += int(self.CloseTab(index, discard=discard))
        wx.GetApp().SafeYieldFor(self.scriptNotebook, wx.wxEVT_ANY) # important, delete the message query
        cl += int(self.CloseTab(0, discard=discard))
        self.scriptNotebook.SendPageChangedEvent(self.scriptNotebook.GetSelection())
        return count == cl

    @AsyncCallWrapper
    def SaveScript(self, filename='', index=None, default=''):
        r'''SaveScriptAs(filename='', index=None, default='')

        Similar to the function SaveScript(), except that if the filename is an empty
        string, this function will always prompt the user with a dialog box for the
        location to save the file, regardless of whether or not the script exists on
        the hard drive.

        '''
        def getMarkedText(txt):
            txt = self.stripComment_2(txt)
            header = '### AvsP marked script ###'
            base = '\n'.join(['# %s' % line for line in scriptText.split('\n')])
            return '%(txt)s\n%(header)s\n%(base)s\n%(header)s' % locals()

        self.StopPlayback() # GPo 2020
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return None
        # Get filename via dialog box if not specified
        if not filename:
            initialdir, initialname = (default, '') if os.path.isdir(default) else os.path.split(default)
            isdir = os.path.isdir(initialdir)
            if not isdir or not initialname:
                source_dir, source_base = os.path.split(self.GetProposedPath())
                if not isdir:
                    initialdir = source_dir
                if not initialname:
                    initialname = source_base
            filefilter = (_('AviSynth script') + ' (*.avs, *.avsi)|*.avs;*.avsi|' +
                          _('All files') + ' (*.*)|*.*')
            dlg = wx.FileDialog(self,_('Save current script'),
                initialdir, initialname, filefilter, wx.SAVE | wx.OVERWRITE_PROMPT)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filename = dlg.GetPath()
            dlg.Destroy()
        # Save script if filename exists (either given or user clicked OK)
        if filename:
            savemsg = None
            # Process the filename
            dirname, basename = os.path.split(filename)
            root, ext = os.path.splitext(basename)
            if not os.path.isdir(dirname):
                wx.MessageBox(_('Directory %(dirname)s does not exist!') % locals(), _('Error'), style=wx.OK|wx.ICON_ERROR)
                return None
            if ext.lower() not in ('.avs', '.avsi', '.vpy'):
                basename = root+'.avs'
            if os.path.splitext(script.filename)[1].lower() == '.avsi':
                basename = root+'.avsi'
            filename = os.path.join(dirname, basename)

            # Get script's text, adding the marked version of the script if required
            scriptText = script.GetText()
            script.SetSavePoint()

            if not self.options['savetoggletags']:
                ctxt = self.cleanToggleTags(scriptText)
                if ctxt != scriptText:
                    scriptText = self.stripComment_2(ctxt)
                    if self.previewWindowVisible:
                        self.HidePreviewWindow()
                    script.SetText(scriptText)
                    script.refreshAVI = True

            txt = self.cleanSliders(scriptText)
            if txt != scriptText:
                script.refreshAVI = True
                if self.previewWindowVisible:
                    self.HidePreviewWindow()
                if self.options['savemarkedavs']:
                    txt = getMarkedText(txt)
                    savemsg = (3000, _('The saved script has changed because AvsP marked section added'), 1)
                else:
                    dlg = wx.MessageDialog(self,_('User sliders found, but option for save/read "marked" script is not enabled.\n\n' +
                                                  'Press "Yes" to save the marked script\n' +
                                                  'Press "No" removes the sliders in the saved script\n' +
                                                  'Press "Cancel" to cancel the process'), _('User sliders'), wx.YES_NO|wx.CANCEL)
                    ID = dlg.ShowModal()
                    dlg.Destroy()
                    if ID == wx.ID_YES:
                        txt = getMarkedText(txt)
                        savemsg = (3000, _('The saved script has changed because AvsP marked section added'), 1)
                    elif ID == wx.ID_NO:
                        pass
                    else:
                        return

            # Encode text and save it to the specified file
            txt = self.GetEncodedText(txt, bom=False) # GPo new, bom = False
            try:
                with open(filename, 'wb') as f:
                    f.write(txt)
                    f.close()
            except IOErroras as err: # errno 13 -> permission denied
                #if err.errno != 13:
                    self.StatusbarTimer_Start(5000, _('Error saving the script: %s') % filename, 2)
                    raise

            # Misc stuff
            if savemsg:
                self.StatusbarTimer_Start(savemsg[0], savemsg[1], savemsg[2])
            script.SetSavePoint()
            script.filename = filename
            script.workdir = os.path.dirname(filename)
            self.SetScriptTabname(basename, script)
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname

            self.UpdateRecentFilesList(filename)
        else:
            return None
        return filename

    def getScriptAtIndex(self, index):
        if index is None:
            script = self.currentScript
            index = self.scriptNotebook.GetSelection()
        else:
            try:
                index = int(index)
                if index < 0:
                    return None, None
                if index >= self.scriptNotebook.GetPageCount():
                    return None, None
                script = self.scriptNotebook.GetPage(index)
            except TypeError:
                return None, None
            except ValueError:
                return None, None
        return script, index

    def getCleanText(self, text, cleanToggleTags=True):
        text = self.cleanSliders(text)
        if cleanToggleTags:
            text = self.cleanToggleTags(text)
        return text

    def GetEncodedText(self, txt, bom=False, forceUtf8=False):
        '''Prepare a script's text for saving it to file

        Prefer system's encoding to utf-8, just in case other applications
        won't support it

        If bom == True, insert the BOM at the beginning (except for UTF-8
        without BOM on the original file)
        '''
        script = self.currentScript

        # convert line endings to CRLF if necessary
        if self.options['eol'] == 'force crlf' or self.options['eol'] == 'auto' and (
                script.eol == 'crlf' or script.eol is None and os.name == 'nt'):
            txt = txt.replace('\n', '\r\n')

        if forceUtf8:
            script.encoding = 'utf-8-sig'
            bom = False # Python writes the bom if it doesn't exist

        # try current encoding, else filesystem's
        encoded = False # GPo 2021
        try:
            encoded_txt = txt.encode(script.encoding)
            encoded = True
        except UnicodeEncodeError:
            sys_encoding = sys.getfilesystemencoding()
            if sys_encoding != script.encoding:
                try:
                    script.encoding = sys_encoding
                    encoded_txt = txt.encode(script.encoding)
                    encoded = True
                except UnicodeEncodeError:
                    encoded = False
        # mbcs just replaces invalid characters
        if encoded and script.encoding.lower() == 'mbcs':
            txt2 = encoded_txt.decode(script.encoding)
            if txt != txt2:
                encoded = False
        # fallback to utf-8
        if not encoded:
            script.encoding = 'utf8'
            bom = False # GPo 2021
            try:
                encoded_txt = txt.encode(script.encoding)
            except UnicodeEncodeError:
                encoded_txt = txt

        # Add BOM
        if bom:
            if script.encoding == 'utf-8-sig': # GPo added bom to bom, also check for bom
                if not encoded_txt.startswith(codecs.BOM_UTF8):
                    encoded_txt = codecs.BOM_UTF8 + encoded_txt
            if script.encoding == 'utf-16-le':
                encoded_txt = codecs.BOM_UTF16_LE + encoded_txt
            elif script.encoding == 'utf-16-be':
                encoded_txt = codecs.BOM_UTF16_BE + encoded_txt
            elif script.encoding == 'utf-32-le':
                encoded_txt = codecs.BOM_UTF32_LE + encoded_txt
            elif script.encoding == 'utf-32-be':
                encoded_txt = codecs.BOM_UTF32_BE + encoded_txt

        #if encoded_txt.startswith(codecs.BOM_UTF8):
            #encoded_txt = encoded_txt.replace(codecs.BOM_UTF8, '', 1)

        return encoded_txt

    def GetProposedPath(self, index=None, only=None, type_=None):
        r'''Return a proposed filepath for a script based on the script's filename
        (if saved), its tab's title, the first source in the script and the user
        preferences.  Posible 'type_' values: 'general', 'image'.

        If 'only' is set to 'dir' or 'base', return only the dirname or basename
        respectively.
        '''
        # Get script
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return ''

        # Get script filename
        dirname, basename = os.path.split(script.filename)
        if not basename and not only == 'dir':
            page_text = self.scriptNotebook.GetPageText(index)
            if not page_text.startswith(self.NewFileName):
                basename = page_text

        # Get default directory for 'type_'
        if not only == 'base':
            if type_ == 'image':
                type_dirname = self.options['imagesavedir']
                use_type_dirname = self.options['useimagesavedir']
            else:
                type_dirname = self.options['recentdir']
                use_type_dirname = self.options['userecentdir']
            if use_type_dirname:
                dirname = type_dirname

        # Use the first source in the script if necessary
        if not dirname and not only == 'base' or not basename and not only == 'dir':
            dir_source, base_source = os.path.split(self.GetSourcePath(script))
            if not basename:
                basename = os.path.splitext(base_source)[0]
            if not dirname:
                dirname = dir_source

        # Last fallback and return
        if not dirname and not only == 'base':
            dirname = type_dirname
        if only == 'dir':
            return dirname
        if not basename and not only == 'dir':
            basename = page_text
        if os.path.splitext(basename)[1] not in ('.avs', '.avsi', '.vpy'):
            basename += '.avs'
        if only == 'base':
            return basename
        return os.path.join(dirname, basename)

    def GetSourcePath(self, script=None):
        '''Parse script for the path on the first source filter'''
        if script is None:
            script = self.currentScript
        if os.name == 'nt':
            sourceFilterList = set(('directshowsource',))
        else:
            sourceFilterList = set(('ffvideosource', 'ffaudiosource'))
        noMediaFileList = ('import', 'loadplugin', 'loadcplugin', 'load_stdcall_plugin',
                           'loadvirtualdubplugin', 'loadvfapiplugin')
        re_templates = re.compile(r'\b(\w+)\s*\([^)]*?\[?\*{3}', re.I)
        for template in self.options['templates'].values():
            re_obj = re_templates.search(template)
            if re_obj:
                function_name = re_obj.group(1).lower()
                if function_name not in noMediaFileList:
                    sourceFilterList.add(function_name)
        findpos = -1
        lastpos = script.GetLength()
        noMediaExtList = ('.dll', '.vdf', 'vdplugin', '.vfp', '.so', '.avs', '.avsi', '.txt', '.log')
        for match in re.finditer('"(.+?)"', script.GetText()):
            s = match.group(1)
            if os.path.splitext(s)[1].lower() not in noMediaExtList and os.path.isfile(s):
                findpos = script.FindText(findpos+1, lastpos, s)
                openpos = script.GetOpenParenthesesPos(findpos)
                if openpos is not None:
                    wordstartpos = script.WordStartPosition(openpos,1)
                    if openpos == wordstartpos:
                        wordstartpos = script.WordStartPosition(script.WordStartPosition(openpos,0),1)
                    if wordstartpos != -1:
                        sourceFilter = script.GetTextRange(wordstartpos, openpos)
                        if sourceFilter.strip().lower() in sourceFilterList:
                            return s
        return ''

    @AsyncCallWrapper
    def RenameScript(self, new_title, index=None):
        """RenameScript(new_title, index=None)

        Renames the tab located at the integer 'index' to 'new_title'.  If 'index' is
        None, then the currently selected tab is used.

        If the script was saved to the filesystem the file is renamed as well.  Returns
        False if the file couldn't be renamed, True otherwise.

        """
        if index is None:
            index = self.scriptNotebook.GetSelection()
        script = self.scriptNotebook.GetPage(index)
        if script.filename:
            if os.path.splitext(new_title)[1] not in ('.avs', '.avsi', '.vpy'):
                new_title += '.avs'
            src = script.filename
            dirname = os.path.dirname(src)
            dst = os.path.join(dirname, new_title)
            try:
                os.rename(src, dst)
                script.filename = dst
            except OSError:
                return False
        self.SetScriptTabname(new_title, index=index)
        return True

    def RepositionTab(self, newIndex):
        if type(newIndex) is not int:
            id = newIndex.GetId()
            menu = self.scriptNotebook.contextMenu
            menuItem = menu.FindItemByPosition(menu.GetMenuItemCount()-1)
            menu = menuItem.GetSubMenu()
            for newIndex in range(menu.GetMenuItemCount()):
                if id == menu.FindItemByPosition(newIndex).GetId():
                    break
        index = self.scriptNotebook.GetSelection()
        page = self.scriptNotebook.GetPage(index)
        label = self.scriptNotebook.GetPageText(index, full=True)
        win = self.FindFocus()
        # GPo, fix the annoying behavior (tabs without AVI would initialized)
        forceShow = False
        if self.previewWindowVisible:
            count = self.scriptNotebook.GetPageCount() -1
            if count > 1:
                idx = index+1 if index < count else index-1
                # the check the next tab and disable load or show the next video when tab removed
                if self.scriptNotebook.GetPage(idx).AVI is None:
                    forceShow = True
                    self.HidePreviewWindow()
        autoHide = self.options['tabautopreview'] # GPo
        self.options['tabautopreview'] = False
        lastSplit = page.lastSplitVideoPos
        self.scriptNotebook.RemovePage(index)
        page.lastSplitVideoPos = lastSplit # restore the spliter pos
        self.scriptNotebook.InsertPage(newIndex, page, label, select=True)
        if forceShow:  # restor visible
            self.ShowVideoFrame()
        self.options['tabautopreview'] = autoHide
        if win:
            win.SetFocus()
        self.UpdateTabImages()

    def OnSortTabsAlpha(self, event=None):
        count = self.scriptNotebook.GetPageCount()
        if count < 2:
            return
        #~idx = self.scriptNotebook.GetSelection()
        #~currentLabel = self.scriptNotebook.GetPageText(idx, full=False)
        currentScript = self.currentScript
        process = False
        tabs = []
        self.currentScript.bookmarks = self.GetBookmarkDict() # save the slider bookmarks
        for i in range(count):
            page = self.scriptNotebook.GetPage(i)
            label = self.scriptNotebook.GetPageText(i, full=True)
            txt = self.scriptNotebook.GetPageText(i, full=False)
            tabs.append((txt, label, page))
        sortedTabs = sorted(tabs, key=lambda x: (x[0].lower()))
        for i in range(count):
            if tabs[i][0] != sortedTabs[i][0]:
                process = True
                break
        if not process:
            return

        multi = self.options['multilinetab']
        error = False

        self.SaveSession(self.lastSessionFilename)
        previewVisible = self.previewWindowVisible and self.previewOK()
        self.HidePreviewWindow()
        if self.readFrameProps and self.propWindowParent < 1: # then separate window
            self.propWindow.Close()
        if self.trimDialog.IsShown():
            self.trimDialog.Close()
        # cropDialog is closing on HideVideoWindow
        if multi:
            self.OnMenuOptionsMultilineTabStyle()
        self.scriptNotebook.Update()
        self.Update()

        # if not lock a changing and changed event is processed and slows down
        # LockPage blocks only the PageChanged event but sets the currentScript for the page
        self.scriptNotebook.LockPage = True # blocks only the PageChanged routines
        try:
            for i in range(count):
                try:
                    txt, label, page = sortedTabs[i]
                    if self.scriptNotebook.GetPageText(i, full=False) == txt:
                        continue
                    self.scriptNotebook.InsertPage(i, page, label, select=False)
                except:
                    wx.Bell()
                    error = True
                    break
                self.scriptNotebook.RemovePage(i+1)
        finally:
            self.scriptNotebook.LockPage = False
            if multi:
                self.OnMenuOptionsMultilineTabStyle()
            self.scriptNotebook.Update()
            #~idx = self.FindTabByName(currentLabel, select=False)
            for idx in range(self.scriptNotebook.GetPageCount()):
                if self.scriptNotebook.GetPage(idx) is currentScript:
                    break
            currIdx = self.scriptNotebook.GetSelection()
            if currIdx == idx or (idx < 0):
                # at least we must send a changed event if the selected index the same
                self.scriptNotebook.SendPageChangedEvent(currIdx)
            elif idx > -1:
                self.scriptNotebook.SetSelection(idx)
            if previewVisible:
                self.ShowVideoFrame()

            self.UpdateTabImages()
            if count != self.scriptNotebook.GetPageCount():
                wx.MessageBox(
                    "Error sorting tabs: Tab count befor %i now %i\nPlease open the last session 'File menu'" %
                    (count, self.scriptNotebook.GetPageCount()))
            elif error:
                wx.MessageBox('Error sorting tabs: Tabs my be unsorted')

    def cleanSliders(self, text):
        return self.regexp.sub(self.re_replace, text)

    def cleanToggleTags(self, text, removeFilters=True):
        for endtag in re.findall('\[/.*?\]', text):
            tagname = endtag[2:-1]
            expr = re.compile('\[%s(\s*=.*?)*?\].*?\[/%s\]' % (tagname, tagname), re.IGNORECASE|re.DOTALL)
            if removeFilters:
                text = expr.sub(self.re_replace2, text)
            else: text = expr.sub(self.re_replace3, text)
        return text

    def ExportHTML(self, filename=None, ext_css=None, index=None):
        """Save a script as a HTML document

        If 'index' is None, the current tab is used
        If a filename is not specified, the user is asked for
        'ext_css' can be a filename for saving the style sheet
        """
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return
        if not script.GetLength():
            wx.MessageBox(_('Script has no text!'), _('Error'),
                          style=wx.OK|wx.ICON_ERROR)
            return
        if not filename:
            filefilter = (_('HTML files') + ' (*.html, *.htm)|*.html;*.htm|' +
                          _('All files') + ' (*.*)|*.*')
            initial_dir, initial_base = os.path.split(self.GetProposedPath(index))
            initial_base = os.path.splitext(initial_base)[0] + '.html'
            dlg = wx.FileDialog(self, _('Export HTML'), initial_dir, initial_base,
                                filefilter, wx.SAVE | wx.OVERWRITE_PROMPT)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filename = dlg.GetPath()
            dlg.Destroy()
        if filename:
            script.OnStyleNeeded(None, forceAll=True)
            dirname = os.path.dirname(filename)
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname
            html = script.GenerateHTML(self.GetProposedPath(only='base'), ext_css)
            if ext_css is not None:
                html, css = html
                with open(os.path.join(dirname, ext_css), 'w') as f:
                    f.write(css.encode('utf-8'))
            with open(filename, 'w') as f:
                f.write(html.encode('utf-8'))

    def LoadSession(self, filename=None, saverecentdir=True, resize=True, backup=False, startup=False):
        # Get the filename to load from the user
        if filename is None or not os.path.isfile(filename):
            filefilter = 'Session (*.ses)|*.ses'
            initialdir = self.options['recentdirSession']
            if not os.path.isdir(initialdir):
                initialdir = self.programdir
            dlg = wx.FileDialog(self,_('Load a session'),
                initialdir, '', filefilter, wx.OPEN)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filename = dlg.GetPath()
            dlg.Destroy()
        if filename is not None:
            # Load the session info from filename
            try:
                with open(filename, mode='rb') as f:
                    session = cPickle.load(f)
            except:
                return

            session['previewWindowVisible'] = False # GPo
            previewWindowVisible = False # GPo
            if self.previewWindowVisible:
                self.HidePreviewWindow()

            if backup:
                newfile = os.path.splitext(filename)[0]
                if os.path.isfile(newfile + 'backup.ses'):
                    shutil.copy2(newfile + 'backup.ses', newfile + 'backup_old.ses')
                shutil.copy(filename, newfile + 'backup.ses')

            # save the current bookmarks
            self.SelectTab(self.scriptNotebook.GetPageCount() - 1)
            self.currentScript.bookmarks = self.GetBookmarkDict()
            lastBookmarks = dict(self.currentScript.bookmarks)
            lastSelections = dict(self.currentScript.selections)
            self.DeleteAllFrameBookmarks(None)
            self.currentScript.selections.update(lastSelections)

            selectedIndex = -1
            loadList = []
            tbc = self.tabChangeLoadBookmarks
            self.tabChangeLoadBookmarks = False

            mapping = session['scripts'] and isinstance(session['scripts'][0], collections.Mapping)
            for item in session['scripts']:
                if not 'bookmarks' in item:
                    item['bookmarks'] = None # old sessions
                if not 'snapshots' in item:
                    item['snapshots'] = None # old sessions
                if not 'selections' in item:
                    item['selections'] = None
                index = self.LoadTab(item, compat=not mapping, hidePreview=True, loadBookmarks=False) # GPo, hidePreview, loadBookmarks
                # GPo, set script bookmarks, selections
                if isinstance(index, int):
                    loadList.append(index)
                    script = self.scriptNotebook.GetPage(index)
                    if item['bookmarks'] is not None:
                        script.bookmarks = None
                        script.bookmarks = dict(item['bookmarks'])
                    if not script.bookmarks and self.options['bookmarksfromscript']: # GPo, new
                        script.bookmarks = self.BookmarkDictFromScript(script=script)
                    if item['selections'] is not None: # only on session or reopen closed tab
                        script.selections.clear()
                        script.selections.update(item['selections'])

                # script bookmarks, selections end
                if mapping:
                    boolSelected = item['selected']
                else:
                    boolSelected = (item + (None, None)[len(item):])[1]
                if boolSelected:
                    selectedIndex = self.scriptNotebook.GetSelection()

            # Prompt to reload modified files
            if not startup:
                self.ReloadModifiedScripts()

            if selectedIndex > -1:
                self.scriptNotebook.SetSelection(selectedIndex)
            self.tabChangeLoadBookmarks = tbc

            bCount = -1
            script = self.currentScript

            if self.options['bookmarksfromscript']:
                bCount = self.OnMenuBookmarksFromScript()
            if bCount <= 0:
                bCount = self.SetTabBookmarks(script.bookmarks)
            self.SetSelectionsDict(script.selections)

            if bCount > -1:
                wx.CallAfter(self.GetStatusBar().SetStatusText, _('%d Bookmarks imported') % bCount)

            # Change preview placement if needed
            if session.get('preview_placement', wx.SPLIT_HORIZONTAL) != self.mainSplitter.GetSplitMode():
                self.TogglePreviewPlacement()
            # Set the video slider to last shown frame number
            if startup:
                self.previewWindowVisible = previewWindowVisible
                self.startupframe = session['frame']
            else:
                if not previewWindowVisible:
                    if self.previewWindowVisible:
                        self.HidePreviewWindow()
                else:
                    self.ShowVideoFrame(session['frame'], resize=resize)
            # Set the last closed tab
            if session.get('lastclosed'): # backward compatibility
                self.lastClosed = session['lastclosed']

            if session.get('saveViewPos'):
                self.saveViewPos = int(session['saveViewPos']) # was bool on older versions

            # Save the recent dir
            if saverecentdir:
                dirname = os.path.dirname(filename)
                if os.path.isdir(dirname):
                    self.options['recentdirSession'] = dirname
        return True

    def LoadTab(self, item, compat=False, hidePreview=False, loadBookmarks=True):
        '''Open/reload a tab from info returned from GetTabInfo

        compat? tuple : dict
        '''
        if compat:
            nItems = len(item)
            defaults = (None, None, None, None, None, 0, 'latin1', '', {})
            name, selected, text, hash, splits, current_frame, f_encoding, workdir, bookmarks, snapshots, selections, matrix= item + defaults[nItems:]
            item = locals()
        scriptname = item['name']
        dirname, basename = os.path.split(scriptname)
        reload = False
        setSavePoint = False
        if not os.path.isdir(dirname):
            if basename:
                scriptname = '%s.avs' % basename
            else:
                scriptname = '%s.avs' % self.NewFileName
        else:
            if os.path.isfile(scriptname):
                txt, txtFromFile = self.GetMarkedScriptFromFile(scriptname, returnFull=True)[0]
                #~ if txt == self.getCleanText(scripttext):
                try:
                    if txt == item['text']:
                        setSavePoint = True
                    else:
                        setSavePoint = False
                except UnicodeEncodeError:
                    setSavePoint = False
                if item['hash'] is not None:
                    hash = md5(txtFromFile.encode('utf8')).hexdigest()
                    if item['hash'] != hash:
                        reload = True
        index = self.OpenFile(filename=scriptname, f_encoding=item['f_encoding'],
                              eol=item.get('eol'), workdir=item['workdir'], scripttext=item['text'],
                              setSavePoint=setSavePoint, splits=item['splits'],
                              framenum=item['current_frame'], last_length=item.get('last_length'),
                              group=item.get('group', -1), group_frame=item.get('group_frame'),
                              bookmarks=item.get('bookmarks'), snapshots=item.get('snapshots'),
                              selections=item.get('selections'), matrix=item.get('matrix'),
                              hidePreview=hidePreview, loadBookmarks=loadBookmarks)
        if reload and index is not None:
            # index is None -> the script was already loaded, different to this other version
            # but the user chose not to replace it.  If that's the case, don't prompt again
            # for discarding the current script state.
            self.reloadList.append((index, scriptname, txt))

        return index

    def ReloadModifiedScripts(self):
        if self.reloadList:
            for index, filename, text in self.reloadList:
                self.scriptNotebook.SetSelection(index)
                dlg = wx.MessageDialog(self, _('File has been modified since the session was saved. Reload?'),
                    os.path.basename(filename), wx.YES_NO)
                ID = dlg.ShowModal()
                dlg.Destroy()
                if ID == wx.ID_YES:
                    script = self.currentScript
                    script.SetText(text)
                    script.SetSavePoint()
                    script.bookmarks.clear()
                    if self.options['bookmarksfromscript']:
                        self.OnMenuBookmarksFromScript(difWarn=False)
            self.reloadList = []

    # backup the current tabs as _last_session and with date name in 'BackupSessions
    # if not sourcesession the current tabs is saved to _last_session
    def BackupSessionEx(self, sourcesession=''):
        saveDir = os.path.join(self.programdir, 'SessionBackups')
        if not os.path.isdir(saveDir):
            try:
                os.mkdir(saveDir)
            except:
                saveDir = self.programdir
                wx.SafeShowMessage(_('Error'), _('Cannot create Sessions Backup directory\n') + saveDir)
        if not sourcesession:
            sourcesession = self.lastSessionFilename
            if not self.SaveSession(filename=sourcesession, saverecentdir=False) or not os.path.isfile(self.lastSessionFilename):
                wx.SafeShowMessage(_('Cannot save the current session'))
                return

        fname = os.path.join(saveDir, '_session_backup_')
        timestr = time.strftime("%Y_%m_%d-%H.%M.%S")
        try:
            shutil.copy(sourcesession, fname + timestr + '.ses')
        except:
            wx.SafeShowMessage(_('Error'),_('Cannot backup the session\n') + sourcesession)
            return
        return os.path.isfile(fname + timestr + '.ses')

    def SaveSession(self, filename=None, saverecentdir=True, frame=None, previewvisible=None):
        # Get the filename to save from the user
        if filename is None:
            filefilter = 'Session (*.ses)|*.ses'
            initialdir = self.options['recentdirSession']
            if not os.path.isdir(initialdir):
                initialdir = self.programdir
            dlg = wx.FileDialog(self,_('Save the session'),
                initialdir, '', filefilter, wx.SAVE | wx.OVERWRITE_PROMPT)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filename = dlg.GetPath()
            dlg.Destroy()
        if filename is not None:
            # Get the text from each script
            scripts = []
            for index in xrange(self.scriptNotebook.GetPageCount()):
                scripts.append(self.GetTabInfo(index))
            # Get the remaining session information, store in a dict
            session = {}
            if frame is None:
                session['frame'] = self.GetFrameNumber()
            else:
                session['frame'] = frame
            if previewvisible is None:
                session['previewWindowVisible'] = self.previewWindowVisible
            else:
                session['previewWindowVisible'] = previewvisible
            session['preview_placement'] = self.mainSplitter.GetSplitMode()
            session['scripts'] = scripts
            session['lastclosed'] = self.lastClosed
            session['saveViewPos'] = self.saveViewPos # GPo
            session['bookmarks'] = list(self.GetBookmarkFrameList().items())
            session['titleDict'] = self.titleDict
            # Save info to filename
            f = open(filename, mode='wb')
            cPickle.dump(session, f, protocol=0)
            f.close()
            # Save the recent dir
            if saverecentdir:
                dirname = os.path.dirname(filename)
                if os.path.isdir(dirname):
                    self.options['recentdirSession'] = dirname
            return True

    def GetTabInfo(self, index=None):
        '''Get the script text and other info'''
        currentIndex = self.scriptNotebook.GetSelection()
        if index is None:
            index = currentIndex
        boolSelected = index == currentIndex
        script = self.scriptNotebook.GetPage(index)
        scriptname = script.filename
        if not os.path.isfile(scriptname):
            hash = None
            title = self.scriptNotebook.GetPageText(index)
            if not title.startswith(self.NewFileName):
                scriptname = title
        else:
            txt = self.GetTextFromFile(scriptname)[0]
            hash = md5(txt.encode('utf8')).hexdigest()
        if boolSelected: # get always the global bookmarks if the tab the current tap
            bookmarks = self.GetBookmarkDict()
        else:
            bookmarks = script.bookmarks
        #if not bookmarks: # on save or load session ? at the moment on load session
            #bookmarks = self.BookmarkDictFromScript(script=script) # for session info tool whe need the bm count

        splits = (script.lastSplitVideoPos, script.lastSplitSliderPos, script.sliderWindowShown)
        snapshots = self.GetScriptSnapshotDict(script)
        selections = script.selections
        return dict(name=scriptname, selected=boolSelected, text=script.GetText(),
                    hash=hash, splits=splits, current_frame=script.lastFramenum,
                    last_length=script.lastLength, f_encoding=script.encoding, eol=script.eol,
                    workdir=script.workdir, group=script.group, group_frame=script.group_frame,
                    bookmarks=bookmarks, snapshots=snapshots, selections=selections, matrix=script.matrix)

    def SaveImage(self, filename='', frame=None, silent=False, index=None, avs_clip=None, default='', quality=None, depth=None, resetFormat=False):
        script, index = self.getScriptAtIndex(index)
        # avs_clip: use 'index' tab, but with an alternative clip
        if not avs_clip:
            avs_clip = script.AVI
        else:
            # GPo, I need the script for threading, if no script then threading is disabled for get frame
            # see Macro 'Save Image Sequence'
            script = None
            for i in xrange(self.scriptNotebook.GetPageCount()):
                scr = self.scriptNotebook.GetPage(i)
                if scr.AVI == avs_clip:
                    script = scr
                    break

        if script is None and avs_clip is None:
            wx.MessageBox(_('No image to save'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return

        if frame is None:
            frame = self.currentframenum
        extlist = self.imageFormats.keys()
        extlist.sort()
        if not filename:
            defaultdir, title  = (default, '') if os.path.isdir(default) else os.path.split(default)
            isdir = os.path.isdir(defaultdir)
            if not isdir or not title:
                source_dir, source_base = os.path.split(self.GetProposedPath(index, type_='image'))
                if not isdir:
                    defaultdir = source_dir
                if not title:
                    title = os.path.splitext(source_base)[0]

            id = title if title else script.GetId() # GPo, GetId gets always the same ID, index dependent
            if (id == self.options['lastscriptid']) and self.options['imagenameformat'] and not resetFormat:
                fmt = self.options['imagenameformat']
            else:
                fmt = self.options['imagenamedefaultformat']
            try:
                defaultname = fmt % (title, frame)
            except:
                try:
                    defaultname = fmt % frame
                except:
                    try:
                        defaultname = fmt % (frame, title)
                    except:
                        try:
                            defaultname = fmt % title
                        except:
                            defaultname = fmt
            if silent:
                filename = os.path.join(defaultdir, defaultname +
                                        extlist[self.options['imagechoice']])
                self.options['imagenameformat'] = fmt
                self.options['lastscriptid'] = id
            else:
                if os.name != 'nt' and '2.9' <= wx.version() < '2.9.5': # XXX
                    defaultname = defaultname + extlist[self.options['imagechoice']]
                filefilterList = []
                for ext in extlist:
                    filefilterList.append('%s|*%s' % (self.imageFormats[ext][0], ext))
                maxFilterIndex = len(filefilterList) - 1
                filefilter = '|'.join(filefilterList)
                dlg = wx.FileDialog(self,_('Save current frame'), defaultdir, defaultname,
                    filefilter,wx.SAVE | wx.OVERWRITE_PROMPT,(0,0))
                dlg.SetFilterIndex(min(self.options['imagechoice'], maxFilterIndex))
                ID = dlg.ShowModal()
                if ID == wx.ID_OK:
                    filename = dlg.GetPath()
                    filter = extlist[dlg.GetFilterIndex()]
                    self.options['imagechoice'] = dlg.GetFilterIndex()
                    self.options['imagesavedir'] = os.path.dirname(filename)
                    fmt = os.path.splitext(os.path.basename(filename))[0]
                    fmt = re.sub(re.escape(title), '%s', fmt, 1)
                    if fmt.find(str(frame)):   # GPo 2020, if not, Formatting is lost
                        fmt = re.sub(r'([0]*?)%d' % frame,
                                     lambda m: '%%0%dd' % len(m.group(0)) if m.group(1) else '%d',
                                     fmt, 1)
                        self.options['imagenameformat'] = fmt
                        self.options['lastscriptid'] = id
                    else:
                        self.options['lastscriptid'] = '' # reset default format

                dlg.Destroy()
        else:
            filter = None
        if filename:
            ret = None
            ext = os.path.splitext(filename)[1].lower()
            if ext not in extlist:
                ext = filter if filter else '.bmp'
                filename = '%s%s' % (filename, ext)
            #~if ext == '.png' and depth == 16:
            if ext == '.png' and (depth == 16 or depth is None and self.check_RGB48(script)):
                if script:
                    if self.GetAviDisplayFrame(script, frame): # use thread if threaded
                        ret = avs_clip.RawFrame(frame)
                else:
                    ret = avs_clip.RawFrame(frame) # else get direct
                if ret:
                    self.SavePNG(filename, ret, avs_clip.Height / 2)
                    return filename
            else:
                w = avs_clip.DisplayWidth
                h = avs_clip.DisplayHeight
                bmp = wx.EmptyBitmap(w, h)
                mdc = wx.MemoryDC()
                mdc.SelectObject(bmp)
                if script:
                    if self.GetAviDisplayFrame(script, frame): # use thread if threaded
                        ret = avs_clip.DrawFrame(frame, mdc)
                else:
                    ret = avs_clip.DrawFrame(frame, mdc)
            if not ret:
                wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=frame),
                              avs_clip.clip.get_error())), _('Error'), style=wx.OK|wx.ICON_ERROR)
                return
            #~ bmp.SaveFile(filename, self.imageFormats[ext][1])
            img = bmp.ConvertToImage()
            if ext==".jpg":
                if quality is None:
                    quality = self.options['jpegquality']
                    if self.options['askjpegquality'] and not silent:
                        ret = self.MacroGetTextEntry(_('Introduce the JPEG Quality (0-100)'),
                                       (quality, 0, 100), _('JPEG Quality'), 'spin', 100)
                        if ret != '':
                            quality = self.options['jpegquality'] = ret
                else:
                    quality = int(quality)
                if quality > 100:
                    quality = 100
                elif quality < 0:
                    quality = 0
                img.SetOption(wx.IMAGE_OPTION_QUALITY, str(quality))
            img.SaveFile(filename, self.imageFormats[ext][1])
            return filename

    @staticmethod
    def check_RGB48(script):
        """Check if the clip returned by 'script' is RGB48

        This is supposed to be removed when SetExtraControlCreator is
        implemented in wx.FileDialog
        """
        convey = ('Dither_convey_rgb48_on_yv12',  # Dither package
                  'Dither_convert_yuv_to_rgb', 'rgb48yv12')
        re_convey = re.compile(r'[^#]*(?:{0})|({1})\s*\(.*(?(1){2}).*\)'.
                               format(*convey), re.I)
        for i in range(script.GetLineCount() - 1, -1, -1):
            if re_convey.match(script.GetLine(i)):
                return True

    @staticmethod
    def SavePNG(filename, buf, height, alpha=False, filter_type=None):
        """PNG encoder in pure Python, based on png.py v0.0.15

        Only accepts a RGB48 or RGB64 buffer as input
        """
        # png.py license
        #
        # Copyright (C) 2006 Johann C. Rocholl <johann@browsershots.org>
        # Portions Copyright (C) 2009 David Jones <drj@pobox.com>
        # And probably portions Copyright (C) 2006 Nicko van Someren <nicko@nicko.org>
        #
        # Original concept by Johann C. Rocholl.
        #
        # LICENCE (MIT)
        #
        # Permission is hereby granted, free of charge, to any person
        # obtaining a copy of this software and associated documentation files
        # (the "Software"), to deal in the Software without restriction,
        # including without limitation the rights to use, copy, modify, merge,
        # publish, distribute, sublicense, and/or sell copies of the Software,
        # and to permit persons to whom the Software is furnished to do so,
        # subject to the following conditions:
        #
        # The above copyright notice and this permission notice shall be
        # included in all copies or substantial portions of the Software.
        #
        # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        # EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
        # BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
        # ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
        # CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        # SOFTWARE.

        # http://www.w3.org/TR/PNG/

        byte_depth = 2
        if alpha:
            channels = 4
            color_type = 6
        else:
            channels = 3
            color_type = 2
        bpp = channels * byte_depth
        scanline_size = len(buf) / height
        width = scanline_size / channels / byte_depth
        if width <= 0 or height <= 0:
            raise ValueError("width and height must be greater than zero")
        if width > 2**32-1 or height > 2**32-1:
            raise ValueError("width and height cannot exceed 2**32-1")

        def sub_filter(scanline):
            """Apply 'Sub' filter (type 1) to a scanline"""
            for i in range(scanline_size - 1, bpp - 1, -1):
                scanline[i] = (scanline[i] - scanline[i - bpp]) & 0xFF
            return scanline

        if filter_type is None:
            filter_type = 0 if width * height > 6e5 else 1 # don't filter HD
        if filter_type == 0: # no filter
            filter = lambda x:x
        elif filter_type == 1: # 10-20% better compression, x3-6 overall time
            filter = sub_filter

        def write_chunk(file, tag, data=''):
            """
            Write a PNG chunk to the output file, including length and
            checksum.
            """
            file.write(struct.pack("!I", len(data)))
            file.write(tag)
            file.write(data)
            checksum = zlib.crc32(tag)
            checksum = zlib.crc32(data, checksum)
            checksum &= 2**32-1 # signed int -> unsigned
            file.write(struct.pack("!I", checksum))

        with open(filename, 'wb') as file:

            # PNG signature
            signature = struct.pack('8B', 137, 80, 78, 71, 13, 10, 26, 10)
            file.write(signature)

            # Image header
            write_chunk(file, 'IHDR', struct.pack("!2I5B", width, height,
                                           byte_depth * 8, color_type, 0, 0, 0))
            # Image data
            compressor = zlib.compressobj(9)
            chunk_limit = 2**20 # 1 MiB
            data = array.array('B') # ugly memory management ahead
            for i in range(0, len(buf), scanline_size):
                data.append(filter_type)
                scanline = array.array('H', buf[i:i + scanline_size])
                scanline.byteswap() # network order (big-endian)
                data.extend(filter(array.array('B', scanline.tostring())))
                if len(data) > chunk_limit:
                    compressed = compressor.compress(data)
                    if len(compressed):
                        write_chunk(file, 'IDAT', compressed)
                    del data[:]
            if len(data):
                compressed = compressor.compress(data)
            else:
                compressed = ''
            flushed = compressor.flush()
            if len(compressed) or len(flushed):
                write_chunk(file, 'IDAT', compressed + flushed)

            # Image trailer
            write_chunk(file, 'IEND')

    @AsyncCallWrapper
    def InsertText(self, txt, pos=-1, index=None):
        r'''InsertText(txt, pos=-1, index=None)

        Inserts the string 'txt' into the script of the tab located at the zero-based
        integer 'index' at the text position 'pos'.

        If the input 'index' is None, the text is inserted into the script of the
        currently selected tab.  The input 'pos' can be either an integer representing
        the zero-based position in the text document (a value of -1 is equivalent
        to the last position) or a tuple representing the zero-based line and column
        numbers (a value of -1 is equivalent to the last line or column, respectively).
        Alternatively, if 'pos' is equal to None, the text is inserted at the current
        cursor position in the document, replacing any existing selection.  In all
        cases, the cursor is positioned at the end of the inserted text.

        Returns False if insert failed (due to bad inputs), True otherwise.

        '''
        # Get the desired script
        if index == -1:
            script = self.scrapWindow.textCtrl
        else:
            script, index = self.getScriptAtIndex(index)
            if script is None:
                return False
        # Insert the text based on the input pos
        if type(txt) != unicode:
            txt = unicode(txt, encoding)
        if pos is None:
            script.ReplaceSelection(txt)
            return True
        elif type(pos) == type(0):
            if pos == -2:
                self.InsertTextAtScriptEnd(txt, script)
                return True
            if pos == -1 or pos > script.GetLength():
                pos = script.GetLength()
            if pos < 0:
                pos = 0
            scriptpos = pos
        elif type(pos) == type((0,0)):
            if len(pos) != 2:
                return False
            line, col = pos
            try:
                line = int(line)
                col = int(col)
            except ValueError:
                return False
            if line == - 1 or line >= script.GetLineCount():
                line = script.GetLineCount() - 1
            if line < 0:
                line = 0
            linepos = script.PositionFromLine(line)
            maxCol = script.GetLineEndPosition(line) - linepos
            if col == -1 or col > maxCol:
                col = maxCol
            if col < 0:
                col = 0
            scriptpos = linepos + col
        script.InsertText(scriptpos, txt)
        script.GotoPos(scriptpos + len(txt))
        return True

    def AutoUpdateVideo(self, force=False):
        script = self.currentScript
        newlinenum = script.LineFromPosition(script.GetCurrentPos())
        if self.options['autoupdatevideo']:
            marker = '__END__'
            pos = script.FindText(0, script.GetTextLength(), marker+'$', stc.STC_FIND_REGEXP)
            if pos != -1:
                line = script.LineFromPosition(pos)
                if newlinenum != line:
                    script.SetTargetStart(pos)
                    script.SetTargetEnd(script.GetLineEndPosition(line))
                    script.ReplaceTarget('')
                    pos = script.GetLineEndPosition(newlinenum)
                    script.InsertText(pos, marker)
            if self.oldlinenum is None:
                pass
            elif newlinenum != self.oldlinenum or force:
                script.OnUpdateUI(None)
                script.refreshAVI = True
                self.IdleCall.append((self.ShowVideoFrame, tuple(), {'focus': False, 'forceCursor': True}))

        self.oldlinenum = newlinenum

    def InsertSource(self, filename='', check_selection=False):
        script = self.currentScript
        if check_selection and not filename:
            text = script.GetSelectedText()
            ext = os.path.splitext(text)[1].lstrip('.')
            if ext in self.options['templates']:
                filename = text
        strsource, filename = self.GetSourceString(filename, return_filename=True)
        if script.GetText() == '' and filename is not None and os.path.splitext(filename)[1].lower() in ('.avs', '.avsi', '.vpy'):
            self.OpenFile(filename)
        else:
            if strsource != '':
                script.ReplaceSelection('%s\n' % strsource)
                script.SetFocus()
                self.AutoUpdateVideo()
                if self.FindFocus() == self.videoWindow:
                    self.refreshAVI = True
                    self.ShowVideoFrame()

    @AsyncCallWrapper
    def GetSourceString(self, filename='', default='', return_filename=False):
        r'''GetSourceString(filename='', default='')

        Returns an appropriate source string based on the file extension of the input
        string 'filename'.  For example, if 'filename' is "D:\test.avi", the function
        returns the string "AviSource("D:\test.avi")".  Any unknown extension is wrapped
        with "DirectShowSource(____)" (AviSynth) or "FFVideoSource(____)" (AvxSynth).
        Templates can be viewed and defined in the options menu of the program.

        If 'filename' is empty, the user is prompted to select a file from a dialog box
        with 'default' as the default filename; it can be just a directory or basename.

        '''
        if not filename or not os.path.isfile(filename):
            extlist = self.options['templates'].keys()
            extlist.sort()
            extlist1 = ', '.join(extlist)
            extlist2 = ';*.'.join(extlist)
            filefilter = (_('Source files') + ' (%(extlist1)s)|*.%(extlist2)s|' +
                          _('All files') + ' (*.*)|*.*') %  locals()
            default_dir, default_base = (default, '') if os.path.isdir(default) else os.path.split(default)
            initial_dir = default_dir if os.path.isdir(default_dir) else self.GetProposedPath(only='dir')
            dlg = wx.FileDialog(self, _('Insert a source'), initial_dir, default_base,
                                filefilter, wx.OPEN|wx.FILE_MUST_EXIST)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filename = dlg.GetPath()
            else:
                filename = None
            dlg.Destroy()
        if filename is not None and os.path.isfile(filename):
            dirname = os.path.dirname(filename)
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname
            ext = os.path.splitext(filename)[1][1:].lower()
            strsource = self.options['templates'].get(ext)
            # TODO: fix unicode bug here?
            if not strsource:
                strsource = self.GetPluginString(filename)
                if not strsource:
                   strsource = u'DirectShowSource(***)' if os.name == 'nt' else  u'FFVideoSource(***)'
            strsource = strsource.replace(u'[***]', u'"%s"' % os.path.basename(filename))
            strsource = strsource.replace(u'***', u'"%s"' % filename)

            ### GPo new, find matched filename e.g. d2v mp2 audio
            # > Tc*.mp2< or [> Tc*.mp2<] for basename
            pos = strsource.find('>')
            if pos > -1:
                pos2 = strsource.find('<', pos+1)
                if pos2 > -1:
                    ch = strsource[pos:pos2+1]
                    if ch:
                        mf = self.FindMatchedFilename(filename, ch[1:-1])
                        if mf:
                            strsource = strsource.replace('['+ch+']', u'"%s"' % os.path.basename(mf[0]))
                            strsource = strsource.replace(ch, u'"%s"' % mf[0])
            ### end
        else:
            strsource = ''
        if return_filename:
            return (strsource, filename)
        else:
            return strsource

    @AsyncCallWrapper
    def GetSourceStringFromFilename(self, filename):
        r'''GetSourceStringFromFilename(filename)
        Returns an appropriate source string based on the file extension of the input
        does not check if the file exists. see GetSourceString.
        '''
        ext = os.path.splitext(filename)[1][1:].lower()
        strsource = self.options['templates'].get(ext)
        if not strsource:
           strsource = u'DirectShowSource(***)' if os.name == 'nt' else  u'FFVideoSource(***)'
        strsource = strsource.replace(u'[***]', u'"%s"' % os.path.basename(filename))
        strsource = strsource.replace(u'***', u'"%s"' % filename)
        return strsource

    @AsyncCallWrapper
    def FindMatchedFilename(self, filename, append=''):
        f = os.path.splitext(filename)[0]
        fl = glob.glob(f + append)
        fl.sort()
        return fl

    def InsertPlugin(self, filename=''):
        txt = self.GetPluginString(filename)
        if txt != '':
            script = self.currentScript
            script.ReplaceSelection('%s\n' % txt)
            script.SetFocus()
            self.AutoUpdateVideo()
            if self.FindFocus() == self.videoWindow:
                self.refreshAVI = True
                self.ShowVideoFrame()

    @AsyncCallWrapper
    def GetPluginString(self, filename='', default=''):
        r'''GetPluginString(filename='', default='')

        Returns an appropriate load plugin string based on the file extension of the
        input string 'filename'.  For example, if 'filename' is "D:\plugin.dll", the
        function returns the string "LoadPlugin("D:\plugin.dll")".  VirtualDub and
        VFAPI (TMPGEnc) plugins are also supported.

        If 'filename' is empty, the user is prompted to select a file with a dialog
        box, always started on the last directory from which a plugin was loaded for
        easy selection and with 'default' as the default filename; it can be just a
        directory or basename.

        '''
        # It would be a good idea to deprecate this function as macro in favour of
        # using 'GetSourceString' for both sources and plugins (already does so)

        #~ script = self.currentScript
        if not filename or not os.path.isfile(filename):
            if os.name == 'nt':
                filefilter = (_('All supported plugins') + ' (*.dll;*.vdf;*.vdplugin;*.vfp)|*.dll;*.vdf;*.vdplugin;*.vfp|' +
                              _('AviSynth plugins') + ' (*.dll)|*.dll|' +
                              _('VirtualDub plugins') + ' (*.vdf;*.vdplugin)|*.vdf;*.vdplugin|' +
                              _('VFAPI plugins') + ' (*.vfp)|*.vfp|' +
                              _('Script import') + ' (*.avs;*.avsi)|*.avs;*.avsi|' +  # GPo 2018
                              _('All files') + ' (*.*)|*.*')
            else:
                filefilter = (_('AvxSynth plugins') + ' (*.so)|*.so|' +
                              _('All files') + ' (*.*)|*.*')

            default_dir, default_base = (default, '') if os.path.isdir(default) else os.path.split(default)
            initial_dir = default_dir if os.path.isdir(default_dir) else self.options['recentdirPlugins']
            if not os.path.isdir(initial_dir):
                initial_dir = self.ExpandVars(self.options['pluginsdir'])

            dlg = wx.FileDialog(self, _('Insert a plugin'), initial_dir, default_base,
                                filefilter, wx.OPEN|wx.FILE_MUST_EXIST)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filename = dlg.GetPath()
            else:
                filename = None
            dlg.Destroy()
        if filename:
            dirname, name = os.path.split(filename)
            basename, ext = os.path.splitext(name)
            ext = ext.lower()
            if ext in ('.dll', '.so'):
                txt = 'LoadPlugin("%s")' % filename
            elif ext in ('.vdf', '.vdplugin'):
                txt = 'LoadVirtualDubPlugin("%s", "%s", 0)' % (filename, basename)
            elif ext == '.vfp':
                txt = 'LoadVFAPIPlugin("%s", "%s")' % (filename, basename)
            elif ext in ('.avs', '.avsi'):
                txt = 'Import("%s")' % filename  # GPo
            else:
                txt = ''
            if os.path.isdir(dirname):
                self.options['recentdirPlugins'] = dirname
        else:
            txt = ''
        return txt

    def InsertFrameNumber(self):
        script = self.currentScript
        txt = str(self.GetFrameNumber())
        script.ReplaceSelection(txt)
        if self.FindFocus() == self.videoWindow:
            self.refreshAVI = True
            self.ShowVideoFrame()

    def InsertSelectionTrims(self, cutSelected=True, insertMode=0, useDissolve=0, singleClips=0, clipPrefix='c'):
        script = self.currentScript
        selections = self.GetSliderSelections(invert=cutSelected)
        if not selections:
            return False
        if singleClips:     # GPo
            clipText = ''
            trimLine = ''
            i = 0
            for start, stop in selections:
                clipText += '%s%i = Trim(%i, %i)' % (clipPrefix, i, start, stop) + '\n'
                trimLine += '%s%i ++ ' % (clipPrefix, i)
                i += 1
            trimLine = trimLine[: len(trimLine)-4]
            if useDissolve and len(selections) > 1:
                trimLine = 'Dissolve(%s, %s)' % (trimLine.replace(' ++', ','), useDissolve-1)
            trimText = clipText + trimLine + '\n'
        else:
            trimText = ' ++ '.join(['Trim(%i, %i)' % (start, stop) for start, stop in selections])
            if useDissolve and len(selections) > 1:
                trimText = 'Dissolve(%s, %s)' % (trimText.replace(' ++', ','), useDissolve-1)
        #~ script.ReplaceSelection(trimText)
        if insertMode == 0:
            self.InsertTextAtScriptEnd(trimText, script)
        elif insertMode == 1:
            script.ReplaceSelection(trimText)
        else:
            text_data = wx.TextDataObject(trimText)
            if wx.TheClipboard.Open():
                wx.TheClipboard.SetData(text_data)
                wx.TheClipboard.Close()
        if insertMode in (0,1):
            script.refreshAVI = True
            # Kill all bookmarks (rebuild non-selection bookmarks...)
            bookmarks = [value for value, title in self.GetBookmarkFrameList().items()]
            newbookmarks = bookmarks[:]
            newTitleDict = {}
            self.DeleteAllFrameBookmarks(refreshVideo=False)
            gapframes = 0
            framenum = self.GetFrameNumber()
            newframenum = framenum
            nSelections = len(selections)
            for i in xrange(nSelections):
                # Get the current and previous selection endpoints
                if i == 0:
                    a, b = selections[0]
                    c, d = selections[0]
                    gapframes += a
                else:
                    a, b = selections[i-1]
                    c, d = selections[i]
                    gapframes += (c - b - 1)
                # Create the bookmark marking the removed section
                if self.options['bookmarktotrim'] and i != nSelections - 1:
                    self.AddFrameBookmark(d-gapframes, toggle=False, refreshVideo=False)
                # Update the video slider handle position
                if framenum <= d and framenum > b:
                    if framenum >= c:
                        newframenum -= gapframes
                    else:
                        newframenum = (c-gapframes)
                elif i == 0 and framenum <= b:
                    if framenum >= a:
                        newframenum -= gapframes
                    else:
                        newframenum = 0
                # Update the old bookmarks
                for j in xrange(len(bookmarks)):
                    if i == 0:                          # GPo, fix for first selection
                        if bookmarks[j] <= b and bookmarks[j] >= a:
                            newbookmarks[j] -= gapframes
                    elif bookmarks[j] <= d and bookmarks[j] > b:
                        if bookmarks[j] >= c:
                            newbookmarks[j] -= gapframes
                        else:
                            newbookmarks[j] = (c-gapframes)
                    if bookmarks[j] in self.titleDict:  # GPo, update titles
                        newTitleDict[newbookmarks[j]] = self.titleDict[bookmarks[j]]

            for newbookmark in newbookmarks:
                self.AddFrameBookmark(newbookmark, toggle=False, refreshVideo=False)
            if insertMode in (0,1):
                self.titleDict.clear()
                self.titleDict.update(newTitleDict)
                self.DeleteAllSelections()
            self.ShowVideoFrame(newframenum)
        return True

    def GetSliderSelections(self, invert=False):
        script = self.currentScript
        selections = self.videoSlider.GetSelections()
        if not selections:
            return selections
        if not invert:
            return selections
        else:
            invertedselections = []
            nSelections = len(selections)
            lastframe = script.AVI.Framecount - 1
            for i in xrange(nSelections):
                if i == 0:
                    a, b = selections[0]
                    c, d = selections[0]
                    if a != 0:
                        invertedselections.append((0, a-1))
                else:
                    a, b = selections[i-1]
                    c, d = selections[i]
                    invertedselections.append((b+1, c-1))
                if i == nSelections - 1:
                    if d != lastframe:
                        invertedselections.append((d+1, lastframe))
            return invertedselections

    def ValueInSliderSelection(self, value, returnStartStop=False):
        selections = self.GetSliderSelections(self.invertSelection)
        if selections:
            for start, stop in selections:
                if value >= start and value <= stop:
                    if not returnStartStop:
                        return True
                    else: return start, stop
            if not returnStartStop:
                return False
            else: return None, None
        else:
            if not returnStartStop:
                return None
            else: return None, None

    # GPo 2020, returned value start and stop must check if it valid (visible) in timeline
    # if startpos == start of a selection, returns startpos, stop
    def GetNextSliderSelection(self, startpos, toggle, prev):
        if self.videoSlider.offsetSet:
            return None, None
        selections = self.GetSliderSelections(False)
        if selections:
            for start, stop in selections:
                if prev:
                    if stop >= startpos:
                        return start, stop
                elif start >= startpos:
                    return start, stop
            if toggle:
                return selections[0]
        return None, None

    def InsertTextAtScriptEnd(self, txt, script=None, replaceReturn=False):
        if script is None:
            script = self.currentScript
        text = script.GetText()
        # Find the first valid "return" statement (not in a function)
        lastline = script.GetLineCount() - 1
        maxpos = script.GetTextLength()
        findpos = script.FindText(0, maxpos, 'return', stc.STC_FIND_WHOLEWORD)
        def FindUncommentedText(text, startpos, endpos):
            pos = script.FindText(startpos, endpos, text, 0)
            while pos != -1:
                if script.GetStyleAt(pos) in script.nonBraceStyles:
                    if startpos < endpos:
                        pos = script.FindText(pos+1, endpos, text, 0)
                    else:
                        pos = script.FindText(pos-1, endpos, text, 0)
                else:
                    return pos
            if startpos < endpos:
                return maxpos + 1
            else:
                return pos
        while findpos != -1:
            # Check if line is commented
            boolComment = script.GetStyleAt(findpos) in script.nonBraceStyles
            # Check if the return is inside a function
            openposPre = FindUncommentedText('{', findpos, 0)
            closeposPre = FindUncommentedText('}', findpos, 0)
            openposPost = FindUncommentedText('{', findpos, maxpos)
            closeposPost = FindUncommentedText('}', findpos, maxpos)
            boolFunction = closeposPost < openposPost and openposPre > closeposPre
            # Find the next return if current one is invalid
            if boolComment or boolFunction:
                findpos = script.FindText(findpos+1, maxpos, 'return', stc.STC_FIND_WHOLEWORD)
            else:
                break
        if findpos == -1:
            for line in range(lastline, -1, -1):
                linetxt = script.GetLine(line)
                if linetxt.strip():
                    if linetxt.strip().startswith('#'):
                        continue
                    else:
                        if line < lastline:
                            pos = script.PositionFromLine(line+1)
                            script.GotoPos(pos)
                            script.ReplaceSelection('%s\n' % txt)
                        else:
                            pos = script.GetLineEndPosition(line)
                            script.GotoPos(pos)
                            script.ReplaceSelection('\n%s' % txt)
                    return
            script.GotoPos(0)
            script.ReplaceSelection(txt)
        else:
            line = script.LineFromPosition(findpos)
            endpos = script.GetLineEndPosition(line)
            text = script.GetTextRange(findpos, endpos)
            if text.count('+') > 0 or replaceReturn:
                # Possible conflict with + or ++ shorthand for Aligned/UnalignedSplice()
                script.SetTargetStart(findpos)
                script.SetTargetEnd(findpos+len('return'))
                script.ReplaceTarget('last =')
                while script.GetLine(line).strip()[-1] == '\\' and line < lastline:
                    line += 1
                if line < lastline:
                    pos = script.PositionFromLine(line+1)
                    script.GotoPos(pos)
                    script.ReplaceSelection('return %s\n' % txt)
                else:
                    pos = script.GetLineEndPosition(line)
                    script.GotoPos(pos)
                    script.ReplaceSelection('\nreturn %s' % txt)
            else:
                while script.GetLine(line).strip()[-1] == '\\' and line < lastline:
                    line += 1
                pos = script.GetLineEndPosition(line)
                while unichr(script.GetCharAt(pos-1)).strip() == '' or script.GetStyleAt(pos-1) in script.nonBraceStyles:
                    pos -= 1
                script.GotoPos(pos)
                script.ReplaceSelection('.%s' % txt)

    def GetBookmarkFrameList(self, copy=False):
        return self.videoSlider.GetBookmarks(copy)

    def GetBookmarkDict(self): # for script.bookmarks
        bDict = {}
        bookmarks = self.videoSlider.GetBookmarks(False)
        for i, item in enumerate(bookmarks.items()):
            bDict[item[0]] = self.titleDict.get(item[0], '')
        return bDict

    def SetTabBookmarks(self, inputDict): # for script.bookmarks
        bmtype = 0
        self.titleDict.clear()
        self.DeleteAllFrameBookmarks(bmtype=0)
        if not inputDict:
            return 0
        lastindex = len(inputDict) - 1
        for i, item in enumerate(inputDict.items()):
            try:
                value, t = item
            except:
                value = item
                t = ''
            if t:
                title = t.strip()
                if title:
                    self.titleDict[value] = title
            if i != lastindex:
                self.AddFrameBookmark(value, bmtype, refreshProgram=False)
            else:
                self.AddFrameBookmark(value, bmtype, refreshProgram=True)
        return len(inputDict)

    # set the tab selections dict
    def SetSelectionsDict(self, selDict):
        for slider in self.GetVideoSliderList():
            slider.childSelectionsDict = selDict # set tab selectionsDict as children
            slider.selectionsDict.clear()
            slider.selectionsDict.update(selDict)
            slider._Refresh(True)

    def SetBookmarkTitle(self, value, title=''):
        for slider in self.GetVideoSliderList():
            if value in slider.bookmarks:
                slider.bookmarks[value] = title
        if value in self.titleDict:
            if title:
                self.titleDict[value] = title.strip()
            else:
                del self.titleDict[value]


    """ out of date
    def SetBookmarkFrameList(self, bookmarks):
        self.DeleteAllFrameBookmarks(bmtype=None)
        lastindex = len(bookmarks) - 1
        for i, item in enumerate(bookmarks):
            try:
                value, bmType = item
            except TypeError:
                value = item
                bmType = 0
            if i != lastindex:
                self.AddFrameBookmark(value, bmType, refreshProgram=False)
            else:
                self.AddFrameBookmark(value, bmType, refreshProgram=True)
    """
    """ out of date
    def SetBookmarkFrameList(self, bookmarks, bmtype=None):
        self.DeleteAllFrameBookmarks(bmtype)
        for i, item in enumerate(bookmarks):
            try:
                value, bmType = item
            except TypeError:
                value = item
                bmType = 0
            if bmtype is None or bmType == bmtype:
                self.AddFrameBookmark(value, bmType, refreshProgram=False)
        # now refresh
        sliderList = self.GetVideoSliderList()
        for slider in sliderList:
            slider.RefreshSelections()
        self.UpdateBookmarkMenu()
        if self.trimDialog.IsShown():
            self.ShowVideoFrame()
    """

    def DeleteFrameBookmark(self, value, bmtype=0, refreshVideo=True, refreshProgram=True):
        for slider in self.GetVideoSliderList():
            if value is None:
                slider.RemoveAllBookmarks(clearSelections=bmtype is None)
            else:
                slider.RemoveBookmark(value, bmtype, refresh=refreshProgram)
        if refreshProgram:
            if value is None or not (bmtype in (1,2)):
                self.UpdateBookmarkMenu()
            if refreshVideo and self.trimDialog.IsShown():
                self.ShowVideoFrame()

    """ out of date
    def DeleteAllFrameBookmarks(self, bmtype=None, start=None, end=None, refreshVideo=True):
        if bmtype is None:
            self.DeleteFrameBookmark(None, refreshVideo=refreshVideo)
            self.frameTextCtrl.SetForegroundColour(wx.BLACK)
            self.frameTextCtrl.Refresh()
            if self.separatevideowindow:
                self.frameTextCtrl2.SetForegroundColour(wx.BLACK)
                self.frameTextCtrl2.Refresh()
        else:
            sliderList = [self.videoSlider]
            if self.separatevideowindow:
                sliderList.append(self.videoSlider2)
            for slider in sliderList:
                bookmarks = slider.GetBookmarks()
                lastindex = len(bookmarks) - 1
                bm = [(value, bmType) for (value, bmType) in bookmarks.items() if (bmtype == bmType)\
                        and (start is None or value >= start) and (end is None or value <= end)]
                if not bm:
                    return
                toggle_color = False
                for value, bmType in bm[:-1]:
                    slider.RemoveBookmark(value, bmtype, refresh=False)
                    if self.currentframenum == value:
                        toggle_color = True
                slider.RemoveBookmark(bm[-1][0], bmtype, refresh=True)
            if toggle_color:
                self.frameTextCtrl.SetForegroundColour(wx.BLACK)
                self.frameTextCtrl.Refresh()
                if self.separatevideowindow:
                    self.frameTextCtrl2.SetForegroundColour(wx.BLACK)
                    self.frameTextCtrl2.Refresh()
            self.UpdateBookmarkMenu()
    """
    # GPo new
    def DeleteAllFrameBookmarks(self, bmtype=None, start=None, end=None, refreshVideo=True):
        toggle_color = False
        if bmtype is None:
            self.DeleteFrameBookmark(None, 0, refreshVideo=refreshVideo) # removes also selections
            toggle_color = True
        elif bmtype == 0:
            sliderList = self.GetVideoSliderList()
            for slider in sliderList:
                if start is None and end is None:   # Faster if start and end None (default)
                    slider.RemoveAllBookmarks(clearSelections=False)
                    toggle_color = True
                else:
                    bookmarks = slider.GetBookmarks()
                    lastindex = len(bookmarks) - 1
                    bm = [(value, title) for (value, title) in bookmarks.items() if\
                            (start is None or value >= start) and (end is None or value <= end)]
                    if not bm:
                        return
                    for value, title in bm[:-1]:
                        slider.RemoveBookmark(value, bmtype, refresh=False)
                        if self.currentframenum == value:
                            toggle_color = True
                    slider.RemoveBookmark(bm[-1][0], bmtype, refresh=True)
        elif bmtype in (1,2):
            for slider in GetVideoSliderList():
                slider.RemoveAllSelections()
        if bmtype in (0, None):
            if toggle_color:
                self.frameTextCtrl.SetForegroundColour(wx.BLACK)
                self.frameTextCtrl.Refresh()
                if self.separatevideowindow:
                    self.frameTextCtrl2.SetForegroundColour(wx.BLACK)
                    self.frameTextCtrl2.Refresh()
            self.UpdateBookmarkMenu()

    # GPo new
    def AddFrameBookmark(self, value, bmtype=0, toggle=True, refreshVideo=True, refreshProgram=True):
        sliderList = self.GetVideoSliderList()
        if not toggle:
            for slider in sliderList:
                slider.SetBookmark(value, bmtype)
        elif bmtype in (1,2):
            for slider in sliderList:
                slider.SetBookmark(value, bmtype, refresh=refreshProgram)
        else:
            for slider in sliderList:
                if value in slider.bookmarks:
                    # DeleteFrameBookmark uses also an slider loop, so we need to break the loop
                    self.DeleteFrameBookmark(value, 0, refreshProgram=refreshProgram)
                    color = wx.BLACK
                    break
                else:
                    slider.SetBookmark(value, 0, refresh=refreshProgram)
                    color = wx.RED

            value = str(value)
            if value == self.frameTextCtrl.GetLineText(0):
                self.frameTextCtrl.SetForegroundColour(color)
                self.frameTextCtrl.Refresh()
            if self.separatevideowindow and value == self.frameTextCtrl2.GetLineText(0):
                self.frameTextCtrl2.SetForegroundColour(color)
                self.frameTextCtrl2.Refresh()
        if refreshProgram:
            if not bmtype in (1,2):
                self.UpdateBookmarkMenu()
            if refreshVideo and self.trimDialog.IsShown():
                self.ShowVideoFrame()

    def OffsetBookmarks(self, offset):
        if not offset:
            return
        bookmarkList = [frame + offset for frame, title in
                         self.GetBookmarkFrameList().iteritems()]
        self.DeleteAllFrameBookmarks(bmtype=0)
        self.MacroSetBookmark(frame for frame in bookmarkList if frame >= 0)

    def DeleteAllSelections(self, refresh=True):
        for slider in self.GetVideoSliderList():
            slider.RemoveAllSelections(refresh=refresh)

    def SetSelectionPoint(self, bmtype):
        if bmtype not in (1,2):
            return
        if not self.trimDialog.IsShown():
            self.OnMenuVideoTrimEditor(None)
        self.AddFrameBookmark(self.GetFrameNumber(), bmtype)

    def GetVideoSliderList(self):
        sliderList = [self.videoSlider]
        if self.separatevideowindow:
            sliderList.append(self.videoSlider2)
        return sliderList

    def UpdateBookmarkMenu(self, event=None):
        return
        '''
        I have been looking for a bug for almost 12 months that caused me a 4-5% increased CPU load when the slider window is visible.
        The bookmark menu is the culprit, there are entries there and if these entries are emptied and filled again when you change tabs,
        this leads to very strange behavior. The bookmark navigation menu is removed for now... TODO
        I've looked at all the calls to this routine and can't find any errors.
        What does the menu have to do with the slider window? nothing at all! I think this is a wx bug
        '''
        """
        for i in xrange(self.menuBookmark.GetMenuItemCount()-4):
            self.menuBookmark.DestroyItem(self.menuBookmark.FindItemByPosition(0))
        pos = 0
        bookmarkList = list(self.GetBookmarkFrameList().items())
        newCount = len(bookmarkList)
        if newCount > 3000 or newCount < 1:
            return
        sortItem = self.menuBookmark.FindItemByPosition(1)
        timecodeItem = self.menuBookmark.FindItemByPosition(2)
        titleItem = self.menuBookmark.FindItemByPosition(3)
        if sortItem.IsChecked():
            bookmarkList.sort()
        width = len(str(max(bookmarkList)[0])) if bookmarkList else 0
        fmt = '%%%dd ' % width
        for bookmark, title in bookmarkList:
            label = fmt % bookmark
            if timecodeItem.IsChecked():
                if self.currentScript.AVI:
                    sec = bookmark / self.currentScript.AVI.Framerate
                    min, sec = divmod(sec, 60)
                    hr, min = divmod(min, 60)
                    label += '[%02d:%02d:%06.3f]' % (hr, min, sec)
                else:
                    label += '[??:??:??.???]'
            if titleItem.IsChecked():
                label += ' ' + self.titleDict.get(bookmark, '')
            menuItem = self.menuBookmark.Insert(pos, wx.ID_ANY, label, _('Jump to specified bookmark'))
            self.Bind(wx.EVT_MENU, self.OnMenuVideoGotoFrameNumber, menuItem)
            pos += 1
            if pos > 1500: # GPo
                break
        """

    def MoveFrameRanges(self, ranges, paste_frame=None, paste_before=False,
                        insert_in_script=True):
        """Cut frames ranges from the timeline and paste them before or after a specified frame

        'ranges' is a sequence of (start, end) pairs. Return value is
        the new timeline in the same format.

        If 'paste_frame' is not given then the current frame is taken

        By default the ranges are inserted after 'paste_frame', set
        'paste_before' to True to insert them before.

        By default a line of Trims according to the new timeline is
        inserted at the end of the script and bookmarks are shifted,
        it can be disabled by setting 'insert_in_script' to False.

        """
        script = self.currentScript
        self.refreshAVI = True
        if self.UpdateScriptAVI() is None:
            self.UpdateScriptTabname(script)
            wx.MessageBox(_('Error loading the script'), _('Error'),
                          style=wx.OK|wx.ICON_ERROR)
            return False

        # Construct the new timeline
        cut_ranges = []
        new_timeline_left = []
        new_timeline_right = []
        last_end = -1
        if paste_frame is None:
            paste_frame = self.GetFrameNumber()
        paste_frame_done = False
        last_frame = script.AVI.Framecount - 1
        if paste_before:
            for (start, end) in sorted(ranges):
                if start - last_end >= 2:
                    if paste_frame_done:
                        new_timeline_right.append((last_end + 1, start - 1))
                    else:
                        if paste_frame <= end:
                            if paste_frame >= start:
                                new_timeline_left.append((last_end + 1, start - 1))
                            elif last_end + 1 == paste_frame:
                                new_timeline_right.append((last_end + 1, start - 1))
                            else:
                                new_timeline_left.append((last_end + 1, paste_frame - 1))
                                new_timeline_right.append((paste_frame, start - 1))
                            paste_frame_done = True
                        else:
                            new_timeline_left.append((last_end + 1, start - 1))
                elif not paste_frame_done and paste_frame <= end:
                    paste_frame_done = True
                cut_ranges.append((start, end))
                last_end = end
            if not paste_frame_done:
                new_timeline_left.append((last_end + 1, paste_frame - 1))
                new_timeline_right.append((paste_frame, last_frame))
            elif last_end < last_frame:
                new_timeline_right.append((last_end + 1, last_frame))
        else:
            for (start, end) in sorted(ranges):
                if start - last_end >= 2:
                    if paste_frame_done:
                        new_timeline_right.append((last_end + 1, start - 1))
                    else:
                        if paste_frame <= end:
                            if paste_frame >= start - 1:
                                new_timeline_left.append((last_end + 1, start - 1))
                            else:
                                new_timeline_left.append((last_end + 1, paste_frame))
                                new_timeline_right.append((paste_frame + 1, start - 1))
                            paste_frame_done = True
                        else:
                            new_timeline_left.append((last_end + 1, start - 1))
                elif not paste_frame_done and paste_frame <= end:
                    paste_frame_done = True
                cut_ranges.append((start, end))
                last_end = end
            if not paste_frame_done:
                if paste_frame == last_frame:
                    new_timeline_left.append((last_end + 1, last_frame))
                else:
                    new_timeline_left.append((last_end + 1, paste_frame))
                    new_timeline_right.append((paste_frame + 1, last_frame))
            elif last_end < last_frame:
                new_timeline_right.append((last_end + 1, last_frame))
        new_timeline = new_timeline_left + cut_ranges + new_timeline_right

        if not insert_in_script:
            return new_timeline

        # Shift bookmarks as needed

        # Get a dictionary {frame range: bookmarks in that range}
        range_bm_dict = collections.defaultdict(list)
        for frame, title in self.GetBookmarkFrameList().iteritems():
            for i, (start, end) in enumerate(new_timeline):
                if start <= frame <= end:
                    range_bm_dict[i].append(frame)
                    break

        # Get the new bookmark list
        new_bookmarks = []
        frame_count = 0
        new_frame = None
        for i, (start, end) in enumerate(new_timeline):
            offset = frame_count - start
            new_bookmarks.extend([bm + offset for bm in range_bm_dict[i]])
            frame_count += end - start + 1
            if new_frame is None and start <= paste_frame <= end:
                new_frame = paste_frame + offset

        # Replace the current bookmarks with the new ones
        self.DeleteAllFrameBookmarks(bmtype=0)
        self.MacroSetBookmark(new_bookmarks)

        # Fix case Trim(0,0)
        new_timeline2 = new_timeline[:]
        try: # 'end' parameter is only available in avisynth v2.6+
            new_timeline2[new_timeline.index((0,0))] = (0, -1)
        except ValueError:
            pass

        # Insert a line of Trims at the end of the script
        pos = script.GetLength()
        new_timeline_str = '++'.join(
                     ['Trim({},{})'.format(*trim) for trim in new_timeline2])
        script.InsertText(pos, '\n' + new_timeline_str)
        script.GotoPos(pos + 1 + len(new_timeline_str))

        # Navigate to the initial frame and hide trim selection editor
        self.refreshAVI = True
        self.ShowVideoFrame(new_frame)
        if self.trimDialog.IsShown():
            self.OnTrimDialogCancel(None)

        return new_timeline

    @AsyncCallWrapper
    def GetFrameNumber(self):
        r'''GetFrameNumber()

        Returns the current integer frame number of the video preview slider.

        '''
        return self.videoSlider.GetValue()

    def InsertUserSlider(self):
        script = self.currentScript
        sliderTexts, sliderProperties = self.GetScriptSliderProperties(script.GetText())
        labels = []
        for p in sliderProperties:
            if p is None:
                continue
            try:
                temp = str(p[0].strip('"'))
            except UnicodeEncodeError:
                temp = p[0].strip('"')
            labels.append(temp)
        # Check if user selected a number to replace
        txt = script.GetSelectedText()
        try:
            float(txt)
            dlg = UserSliderDialog(self, labels, initialValueText=txt)
        except ValueError:
            dlg = UserSliderDialog(self, labels)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            script.ReplaceSelection(dlg.GetSliderText())
            if self.FindFocus() == self.videoWindow:
                self.refreshAVI = True
                self.ShowVideoFrame()
        dlg.Destroy()

    def SetScriptStatusText(self, line=None, col=None):
        if line==None or col==None:
            script = self.currentScript
            pos = script.GetCurrentPos()
            line = script.LineFromPosition(pos)
            col = script.GetColumn(pos)
        line += 1
        text = _('Line: %(line)i  Col: %(col)i') % locals()
        statusBar = self.GetStatusBar()
        width = min(statusBar.GetClientSize()[0] - statusBar.GetTextExtent(text)[0] - intPPI(6),
                    statusBar.GetTextExtent(text)[0] + intPPI(30))
        width = max(0, width)
        statusBar.SetStatusWidths([-1, width])
        statusBar.SetStatusText(text, 1)

    def SetVideoStatusText(self, frame=None, primary=True, addon='', addon0=''):
        if self.cropDialog.IsShown():
            self.SetVideoCropStatusText()
            return
        if self.blockStatusbar:  # GPo 2020
            return
        if not frame:
            frame = self.videoSlider.GetValue()

        """ for playback speed test only
        self.SetStatusWidths([-1, 0])
        self.SetStatusText(addon0)
        self.SetStatusText('', 1)  # wx 2.9 bug
        return
        """
        int18 = intPPI(18)
        int6 = intPPI(6)
        script = self.currentScript
        previewIdx = '' if script.previewFilterIdx < 1 else 'P-Filter ' + str(script.previewFilterIdx)
        if script.AVI: # GPo, join and % are slower
            if self.splitView:
                offset = frame - self.splitView_nextScript.AVI.current_frame
                if self.splitView_freeze:
                    frozen = ', frozen R' if self.splitView_next else ', frozen L'
                else: frozen = ''
                splitview = '(SV-L %+i%s) ' % (offset,frozen) if self.splitView_next else '(SV-R %+i%s) ' % (offset,frozen)
            else:
                splitview = ''
            text = addon0 + self.status_bar_formatter.vformat(
                                ' ' + self.videoStatusBarInfoParsed + '      ',
                                [], self.GetVideoInfoDict(script, frame, addon)) + splitview + previewIdx
        else:
            text = ' %s %i %s'  % (_('Frame'), frame, '[%i]' % self.timelineRange if self.timelineRange > 0 else '')
        text2 = text.rsplit('\\T\\T', 1)
        if primary:
            if len(text2) == 2:
                statusBar = self.GetStatusBar()
                width = min(statusBar.GetClientSize()[0] - statusBar.GetTextExtent(text2[0])[0] - int6,
                            statusBar.GetTextExtent(text2[1])[0] + int18)
                if width < 0:
                    width = 0
                statusBar.SetStatusWidths([-1, width])
                statusBar.SetStatusText(text2[0], 0)
                statusBar.SetStatusText(text2[1], 1)
            else:
                self.SetStatusText('', 1)  # wx 2.9 bug
                self.SetStatusWidths([-1, 0])
                self.SetStatusText(text)

        if self.separatevideowindow:
            if len(text2) == 2:
                width = min(self.videoStatusBar.GetClientSize()[0] - self.videoStatusBar.GetTextExtent(text2[0])[0] - int6,
                            self.videoStatusBar.GetTextExtent(text2[1])[0] + int18)
                if width < 0:
                    width = 0
                self.videoStatusBar.SetStatusWidths([-1, width])
                self.videoStatusBar.SetStatusText(text2[0], 0)
                self.videoStatusBar.SetStatusText(text2[1], 1)
            else:
                self.videoStatusBar.SetStatusText('', 1)  # wx 2.9 bug
                self.videoStatusBar.SetStatusWidths([-1, 0])
                self.videoStatusBar.SetStatusText(text)

    def SetVideoCropStatusText(self):
        int6 = intPPI(6)
        int12 = intPPI(12)
        script = self.currentScript
        left = self.cropValues['left']
        top = self.cropValues['top']
        mright = self.cropValues['-right']
        mbottom = self.cropValues['-bottom']
        wcrop = script.AVI.Width - left - mright
        if wcrop % 32 == 0:
            wmod = 'WMOD = 32'
        elif wcrop % 16 == 0:
            wmod = 'WMOD = 16'
        elif wcrop % 8 == 0:
            wmod = 'WMOD =  8'
        elif wcrop % 4 == 0:
            wmod = 'WMOD =  4'
        elif wcrop % 2 == 0:
            wmod = 'WMOD =  2'
        else:
            wmod = 'WMOD =  1'
        hcrop = script.AVI.Height - top - mbottom
        if hcrop % 32 == 0:
            hmod = 'HMOD = 32'
        elif hcrop % 16 == 0:
            hmod = 'HMOD = 16'
        elif hcrop % 8 == 0:
            hmod = 'HMOD =  8'
        elif hcrop % 4 == 0:
            hmod = 'HMOD =  4'
        elif hcrop % 2 == 0:
            hmod = 'HMOD =  2'
        else:
            hmod = 'HMOD =  1'
        arCrop = '%.03f:1' % (wcrop / float(hcrop))
        if arCrop == '1.000:1':             # GPo 2018 added elif (arCrop, ar)
            arCrop = '1:1'
        elif arCrop == '1.333:1':
            arCrop = '4:3'
        elif arCrop == '1.778:1':
            arCrop = '16:9'
        ar = '%.03f:1' % (script.AVI.Width / float(script.AVI.Height))
        if ar == '1.000:1':
            ar = '1:1'
        elif ar == '1.333:1':
            ar = '4:3'
        elif ar == '1.778:1':
            ar = '16:9'
        zoom = ''
        if self.zoomfactor != 1:
            if self.zoomfactor < 1 or self.zoomwindow:
                zoom = '(%.2fx) ' % self.zoomfactor
            else:
                zoom = '(%ix) ' % self.zoomfactor
        text = (
            ' Crop(%i,%i,-%i,-%i) - %ix%i (%s) - %s  %s \\T\\T %s %ix%i (%s)  -  %.03f fps      ' %
            (
                left, top, mright, mbottom,
                wcrop, hcrop, arCrop, wmod, hmod,
                zoom, script.AVI.Width, script.AVI.Height, ar, script.AVI.Framerate
            )
        )
        text2 = text.rsplit('\\T\\T', 1)
        statusBar = self.GetStatusBar()
        width = min(statusBar.GetClientSize()[0] - statusBar.GetTextExtent(text2[0])[0] - int6,
                    statusBar.GetTextExtent(text2[1])[0] + int12)
        if width < 0:
            width = 0
        statusBar.SetStatusWidths([-1, width])
        statusBar.SetStatusText(text2[0], 0)
        statusBar.SetStatusText(text2[1], 1)
        if self.separatevideowindow:
            width = min(self.videoStatusBar.GetClientSize()[0] - self.videoStatusBar.GetTextExtent(text2[0])[0] - int6,
                        self.videoStatusBar.GetTextExtent(text2[1])[0] + int12)
            if width < 0:
                width = 0
            self.videoStatusBar.SetStatusWidths([-1, width])
            self.videoStatusBar.SetStatusText(text2[0], 0)
            self.videoStatusBar.SetStatusText(text2[1], 1)

    def ResetStatusText(self):
        if self.FindFocus() == self.videoWindow:
            self.SetVideoStatusText()
        else:
            self.SetScriptStatusText()

    def GetVideoInfoDict(self, script=None, frame=None, addon='', clean=False):
        if script is None:
            script = self.currentScript
        if script.AVI is None:
            self.UpdateScriptAVI(script)
        if not frame:
            frame = self.videoSlider.GetValue()
        v = script.AVI
        framerate = v.Framerate
        framecount = v.Framecount
        #~dmatrix = '%s (%s)' % (v.matrix if v.matrix_found else '*' + v.matrix, v.sourceMatrix)
        dmatrix = '%s (%s)' % (v.matrix, v.sourceMatrix)
        timelinerange = '' if self.timelineRange == 0 else '[%i]' % self.timelineRange
        time = self.FormatTime(frame/framerate)
        totaltime = self.FormatTime(framecount/framerate)
        bookmarktitle = self.titleDict.get(frame, '')
        zoom = ''
        width, height = v.DisplayWidth, v.DisplayHeight
        if script.resizeFilter[0]:
            if script.resizeFilter[2] != 1:
                if self.zoomfactor != 1:
                    zoom = '(%.2f x r%.2f x %ix%i) ' % (self.zoomfactor, script.resizeFilter[2], v.Width, v.Height)
                else:
                    zoom = '(r%.2f x %ix%i) ' % (script.resizeFilter[2], v.Width, v.Height)
            else:
                if self.zoomfactor != 1:
                    zoom = '(%.2f x r%.2f x %ix%i) ' % (self.zoomfactor, float(width) / v.Width, v.Width, v.Height)
                else:
                    zoom = '(r%.2f x %ix%i) ' % (float(width) / v.Width, v.Width, v.Height)
        elif self.zoomfactor != 1:
            zoom = '(%.2fx) ' % self.zoomfactor
        if addon:
            pixelpos, pixelhex, pixelrgb, pixelrgba, pixelyuv, pixelyuva = addon
            if v.IsYUV:
                pixelclr = pixelyuv
            elif v.IsYUVA:
                pixelclr = pixelyuva
            elif v.IsRGBA:
                pixelclr = pixelrgba
            else:
                pixelclr = pixelrgb
        else:
            pixelpos, pixelhex, pixelrgb, pixelrgba, pixelyuv, pixelyuva, pixelclr = '', '', '', '', '', '', ''
        frameratenum, framerateden, audiorate, audiolength, audiochannels, audiobits, colorspace, parity, bitdepth = v.FramerateNumerator, v.FramerateDenominator, v.Audiorate, v.Audiolength, v.Audiochannels, v.Audiobits, v.Colorspace, v.GetParity, v.bits_per_component
        if v.IsFrameBased:
            fieldframebased = _('Frame Based')
        else:
            fieldframebased = _('Field Based')
        if parity == 0:
            parity = _('Bottom Field First')
            parityshort = _('BFF')
        else:
            parity = _('Top Field First')
            parityshort = _('TFF')
        if v.IsAudioInt:
            audiotype = _('Integer')
        else:
            audiotype = _('Float')

        if not clean:
            # on resizeFilter, previewFilter, displayFilter show 'r' if displayClip resized
            aspectratio = '%.03f:1' % (width / float(height))
            if v.Width != width:
                width = 'r' + str(width)
            if v.Height != height:
                height = 'r' + str(height)
        else: # videoinfo need clean result (original dimeensions)
            width = v.Width
            height = v.Height
            aspectratio = '%.03f:1' % (width / float(height))
        if aspectratio == '1.000:1':  # GPo 2018 added elif
            aspectratio = '1:1'
        elif aspectratio == '1.333:1':
            aspectratio = '4:3'
        elif aspectratio == '1.778:1':
            aspectratio = '16:9'

        return locals()

    def ParseVideoStatusBarInfo(self, info):
        showVideoPixelInfo = False
        for item in ('%POS', '%HEX', '%RGB', '%YUV', '%CLR'):
            if info.count(item) > 0:
                showVideoPixelInfo = True
                break
        keyList = [
            ('%POS', '{pixelpos}'),
            ('%HEX', '{pixelhex}'),
            ('%RGB', '{pixelrgb}'),
            ('%YUV', '{pixelyuv}'),
            ('%CLR', '{pixelclr}'),
            ('%FRN', '{frameratenum}'),
            ('%FRD', '{framerateden}'),
            ('%AUR', '{audiorate:.3f}'),
            ('%AUL', '{audiolength}'),
            ('%AUC', '{audiochannels}'),
            ('%AUB', '{audiobits}'),
            ('%AUT', '{audiotype}'),
            ('%FC', '{framecount}'),
            ('%TR', '{timelinerange}'),
            ('%TT', '{totaltime}'),
            ('%FR', '{framerate:.3f}'),
            ('%CS', '{colorspace}'),
            ('%BIT', '{bitdepth}'),
            ('%AR', '{aspectratio}'),
            ('%FB', '{fieldframebased}'),
            ('%PS', '{parityshort}'),
            ('%BM', '{bookmarktitle}'),
            ('%W', '{width}'),
            ('%H', '{height}'),
            ('%F', '{frame}'),
            ('%T', '{time}'),
            ('%P', '{parity}'),
            ('%Z', '{zoom}'),
            ('%DYR', '{dmatrix}'),
        ]
        for key, item in keyList:
            info = info.replace(key, item)
        return info, showVideoPixelInfo

    def GetPixelInfo(self, event, string_=False):
        def calcYUV(R,G,B):
            Y = int(0.257*R + 0.504*G + 0.098*B + 16)
            U = int(-0.148*R - 0.291*G + 0.439*B + 128)
            V = int(0.439*R - 0.368*G - 0.071*B + 128)
            return (Y,U,V)

        script = self.currentScript

        if self.splitView or script.AVI is None:
            return '' if string_ else (0, 0), None, None, None, None, None

        videoWindow = self.videoWindow

        # GPo 2020, if call without mouse event then check if mouse in videoWindow
        if event:
            xpos, ypos = event.GetPosition()
        else:
            xpos, ypos = videoWindow.ScreenToClient(wx.GetMousePosition())
            # if not in client then return, speed up
            if not videoWindow.GetClientRect().Inside((xpos, ypos)):
                return '' if string_ else (0, 0), None, None, None, None, None

        w, h = script.AVI.DisplayWidth, script.AVI.DisplayHeight
        dc = wx.ClientDC(videoWindow)
        dc.SetDeviceOrigin(self.xo, self.yo)
        try: # DoPrepareDC causes NameError in wx2.9.1 and fixed in wx2.9.2
            videoWindow.DoPrepareDC(dc)
        except:
            videoWindow.PrepareDC(dc)

        zoomfactor = self.zoomfactor
        if zoomfactor != 1:
            dc.SetUserScale(zoomfactor, zoomfactor)

        x = dc.DeviceToLogicalX(xpos)
        y = dc.DeviceToLogicalY(ypos)

        xposScrolled, yposScrolled = videoWindow.CalcUnscrolledPosition(xpos,ypos)
        if 0 <= x < w and 0 <= y < h and xposScrolled>=self.xo and yposScrolled>=self.yo:
            # Get color from display
            rgb = dc.GetPixel(x, y)
            dR,dG,dB = rgb.Get()
            A = yA = -1

            if script.AVI.bits_per_component == 8:
                cR = cY = cH = '*'
            else:
                cR = cY = cH = '8bit_'

            if 'flipvertical' in self.flip:
                y = script.AVI.DisplayHeight - 1 - y
            if 'fliphorizontal' in self.flip:
                x = script.AVI.DisplayWidth - 1 - x

            # Get color from AviSynth
            if not self.bit_depth and (self.snapShotIdx < 1): # disable avisynth if snapshot visible
                try:
                    if script.AVI.IsYUV:
                        avsYUV = script.AVI.GetPixelYUV(x, y)
                        if avsYUV != (-1,-1,-1):
                            Y,U,V = avsYUV
                            cY = cH = ''
                            if script.AVI.component_size == 1: # 8bit
                                hexcolor = '$%02x%02x%02x' % (Y,U,V)
                            elif script.AVI.component_size == 2: # 10 to 16bit
                                hexcolor = '$%04x,%04x,%04x' % (Y,U,V) # comma separated is more visible
                            else: # 32 bit
                                hexcolor = '%.5f,%.5f,%.5f' % (Y,U,V) # no reason for 32 bit float in hex

                    elif script.AVI.IsYUVA:
                        avsYUVA = script.AVI.GetPixelYUVA(x, y)
                        if avsYUVA != (-1,-1,-1,-1):
                            Y,U,V,yA = avsYUVA
                            cY = cH = ''
                            if script.AVI.component_size == 1:
                                hexcolor = '$%02x%02x%02x%02x' % (Y,U,V,yA)
                            elif script.AVI.component_size == 2:
                                hexcolor = '$%04x,%04x,%04x,%04x' % (Y,U,V,yA) # comma separated is more visible
                            else: # 32 bit
                                hexcolor = '%.5f,%.5f,%.5f,%.5f' % (Y,U,V,yA) # no reason for 32 bit float in hex

                    elif script.AVI.IsRGBA: # RGB32, RGB64, PlanarRGBA
                        avsRGBA = script.AVI.GetPixelRGBA(x, y)
                        if avsRGBA != (-1,-1,-1,-1):
                            R,G,B,A = avsRGBA
                            cR = cH = ''
                            if script.AVI.component_size == 1:
                                hexcolor = '$%02x%02x%02x%02x' % (R,G,B,A)
                            elif script.AVI.component_size == 2:
                                hexcolor = '$%04x,%04x,%04x,%04x' % (R,G,B,A)
                            else:
                                hexcolor = '%.5f,%.5f,%.5f,%.5f' % (R,G,B,A)

                    elif script.AVI.IsRGB:
                        avsRGB = script.AVI.GetPixelRGB(x, y)
                        if avsRGB != (-1,-1,-1):
                            R,G,B = avsRGB
                            cR = cH = ''
                            if script.AVI.component_size == 1: # 8bit
                                hexcolor = '$%02x%02x%02x' % (R,G,B)
                            elif script.AVI.component_size == 2: # 10 to 16bit
                                hexcolor = '$%04x,%04x,%04x' % (R,G,B)
                            else: # 32bit
                                hexcolor = '%.5f,%.5f,%.5f' % (R,G,B) # no reason for 32 bit float in hex
                except:
                    pass

            # return only 8bit calculated values
            if cY:
                Y,U,V = calcYUV(dR,dG,dB)
            if cR:
                R,G,B = (dR,dG,dB)
            if cH:
                hexcolor = '$%02x%02x%02x' % (dR,dG,dB)

            if not string_:
                return (x, y), hexcolor.upper()[1:], (R, G, B), (R, G, B, A), (Y, U, V) , (Y, U, V, A)
            xystring = '%s=(%i,%i)' % (_('pos'),x,y)
            hexstring = '%s=%s' % (_(cH+'hex'),hexcolor.upper())

            if isinstance(R, int):
                rgbstring = '%s=(%i,%i,%i)' % (_(cR+'rgb'),R,G,B)
                rgbastring = '%s=(%i,%i,%i,%i)' % (_(cR+'rgba'),R,G,B,A)
            else:
                rgbstring = '%s=(%.5f,%.5f,%.5f)' % (_(cR+'rgb'),R,G,B)
                rgbastring = '%s=(%.5f,%.5f,%.5f,%.5f)' % (_(cR+'rgba'),R,G,B,A)

            if isinstance(Y, int):
                yuvstring = '%s=(%i,%i,%i)' % (_(cY+'yuv'),Y,U,V)
                yuvastring = '%s=(%i,%i,%i,%i)' % (_(cY+'yuva'),Y,U,V,yA)
            else:
                yuvstring = '%s=(%.5f,%.5f,%.5f)' % (_(cY+'yuv'),Y,U,V)
                yuvastring = '%s=(%.5f,%.5f,%.5f,%.5f)' % (_(cY+'yuva'),Y,U,V,yA)

            return xystring, hexstring, rgbstring, rgbastring, yuvstring, yuvastring
        else:
            if not 0 <= x < w:
                x = 0 if x < 0 else w - 1
            if not 0 <= y < h:
                y = 0 if y < 0 else h - 1
            if 'flipvertical' in self.flip:
                y = script.AVI.DisplayHeight - 1 - y
            if 'fliphorizontal' in self.flip:
                x = script.AVI.DisplayWidth - 1 - x
            xystring = '%s=(%i,%i)' % (_('pos'),x,y)
            return xystring if string_ else (x, y), None, None, None, None, None

    @AsyncCallWrapper
    def SelectTab(self, index=None, inc=0):
        r'''SelectTab(index=None, inc=0)

        Selects the tab located at the integer 'index', where an index of 0 indicates
        the first tab.  If the 'index' is None, the integer 'inc' is used instead
        to determine which tab to select, where inc is an offset from the currently
        selected tab (negative values for inc are allowable).  Returns False upon
        failure (invalid input), True otherwise.

        '''
        nTabs = self.scriptNotebook.GetPageCount()
        if nTabs == 1:
            self.scriptNotebook.SetSelection(0)
            return True
        if index is None:
            index = inc + self.scriptNotebook.GetSelection()
            # Allow for wraparound with user-specified inc
            if index<0:
                index = nTabs - abs(index) % nTabs
                if index == nTabs:
                    index = 0
            if index > nTabs-1:
                index = index % nTabs
        # Limit index if specified directly by user
        if index < 0:
            return False
        if index > nTabs - 1:
            return False
        self.scriptNotebook.SetSelection(index)
        return True

    def ShowFunctionDefinitionDialog(self, functionName=None, functionArgs=None):
        dlg = AvsFunctionDialog(
            self,
            self.optionsFilters,
            self.options['filteroverrides'],
            self.avsfilterdict,
            self.options['filterpresets'],
            self.options['filterremoved'],
            self.options['autocompletepluginnames'],
            self.plugin_shortnames,
            self.installed_plugins_filternames,
            self.installed_avsi_filternames,
            functionName=functionName,
            functionArgs=functionArgs,
            CreateDefaultPreset=self.currentScript.CreateDefaultPreset,
            ExportFilterData=self.ExportFilterData,

        )
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            self.options['filteroverrides'] = dlg.GetOverrideDict()
            self.options['filterremoved'] = dlg.GetRemovedSet()
            self.options['filterpresets'] = dlg.GetPresetDict()
            self.options['autocompletepluginnames'] = dlg.GetAutocompletePluginNames()
            self.plugin_shortnames = dlg.GetPluginShortNames()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
            self.defineScriptFilterInfo()
            for i in xrange(self.scriptNotebook.GetPageCount()):
                self.scriptNotebook.GetPage(i).Colourise(0, 0) # set script.GetEndStyled() to 0
        dlg.Destroy()

    def TogglePreviewPlacement(self):
        if self.separatevideowindow:
            return
        if self.previewWindowVisible:
            self.HidePreviewWindow()
            show_preview = True
        else:
            show_preview = False
        if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
            self.mainSplitter.SetSplitMode(wx.SPLIT_VERTICAL)
        else:
            self.mainSplitter.SetSplitMode(wx.SPLIT_HORIZONTAL)
        self.SetMinimumScriptPaneSize()
        if show_preview:
            self.ShowVideoFrame()

    @AsyncCallWrapper
    def HidePreviewWindow(self):
        r'''HideVideoWindow()

        Hides the video preview window if it is visible (note that the video controls
        are always visible).

        '''
        self.StopPlayback()
        if self.getPixelInfo: # break MacroGetPixelInfo waitTimeout
            self.getPixelInfo = None
        if not self.separatevideowindow:
            if self.mainSplitter.IsSplit():
                self.SaveZoom()
            self.mainSplitter.Freeze()
            self.mainSplitter.Unsplit()
            self.TryThaw(self.mainSplitter)
        else:
            if self.videoDialog.IsShown():
                self.SaveZoom()
            self.videoDialog.Hide()
        self.previewWindowVisible = False

        try:
            if self.cropDialog.IsShown():
                self.OnCropDialogCancel(None)
        except AttributeError:
            pass

        self.toggleButton.SetBitmapLabel(self.bmpVidUp)
        self.toggleButton.Refresh()
        self.currentScript.SetFocus()

    # GPo, for zoom layout bugfix, for wx. 2.93 not needed
    def fix_zoom(self, zoom):
        return zoom

    def TryThaw(self, obj):
        if obj.IsFrozen():
            self.blockEventSize = True
            try:
                obj.Thaw()
            except:
                pass

    def previewOK(self, script=None):
        if script is None:
            script = self.currentScript
        if script.AVI is None or self.AviThread_Running(script, prompt=False):
            return False
        try:
            error = script.AVI.error_message is not None\
                    or script.AVI.display_clip.get_error() is not None
        except:
            return False
        return not error

    def ShowVideoFrame_CheckPreview(self, forceRefresh=None, resize=None, scroll=None): # Ceck it again, preview now off is new avi (Update script)
        self.zoom_antialias = False
        script = self.currentScript
        if forceRefresh is None:
            forceRefresh = self.ScriptChanged(script)
        forceCursor = forceRefresh or script.display_clip_refresh_needed
        if not forceRefresh and (script.previewFilterIdx > 0) and not self.ComparePreviewFilterDict(): # then update the slider
            self.OnMenuPreviewFilter(None, script.previewFilterIdx, updateUserSliders=False)
            self.IdleCallDict['UpdateUserSliders'] = self.UpdateUserSliders()
        else:
            self.ShowVideoFrame(forceRefresh=forceRefresh, forceLayout=True, forceCursor=forceCursor and self.options['refreshpreview'],
                resize=resize, scroll=scroll, frameToFrametime=self.options['frametoframetime'])
        self.ResetZoomAntialias()

    # GPo 2020, only for playback without threads ( with threads there are new routine in PlayPauseVideo )
    # for initial values must call ShowVideoFrame bevor and after
    def ShowVideoFrameFast(self, framenum, addon0='', threaded=True, forceShow=False): # forceShow experimental
        def GetFrame(script, framenum):
            try:
                script.AVI.display_clip.get_frame(framenum)
                #script.AVI._GetDisplayFrame(framenum)
            except:
                pass

        if not self.playing_video and not forceShow:
            if self.previewOK():
                self.GetPixelInfo(None, string_=True)
                return self.ShowVideoFrame(forceLayout=True, focus=True)
            return

        script = self.currentScript
        if self.AviThread_Running(script, prompt=False):
            return

        self.currentframenum = framenum
        self.videoSlider.SetValue(framenum)
        self.frameTextCtrl.Replace(0, -1, str(framenum))

        if self.separatevideowindow:
            self.videoSlider2.SetValue(framenum)
            self.frameTextCtrl2.Replace(0, -1, str(framenum))

        # GPo new, get frame threaded
        if threaded:
            if not self.UseNewFrameThread:
                th = threading.Thread(target=GetFrame, args=(script, framenum,))
                th.daemon = True
                script.AviThread = th
                th.start()
                _t = time.time() + 9.0
                while th.isAlive() and time.time() <= _t:
                    wx.MilliSleep(1)
                if th.isAlive():
                    if not self.TH_WaitForFrame(script, th, framenum):
                        return
                else:
                    script.AviThread = None
            else:
                th = script.FrameThread
                if th.IsRunning():
                    return

                th.Start(framenum)
                _t = time.time() + 9.0
                while th.IsRunning() and time.time() <= _t:
                    wx.MilliSleep(1)

                if th.IsRunning():
                    if not self.WaitForFrameThread(script, th, framenum):
                        return
                else:
                    re = th.IsError()
                    th.Reset()
                    if re:
                        return
        else:
            script.AVI.display_clip.get_frame(framenum)

        if not self.playing_video:
            return

        error = script.AVI.display_clip.get_error()
        if error is not None:
            self.HidePreviewWindow()  # stop also playback
            wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=framenum),
                              error)), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False

        dc = wx.ClientDC(self.videoWindow)
        self.PaintAVIFrame(dc, script, framenum)

        # If error clip, highlight the line with the error
        errmsg = script.AVI.error_message
        if errmsg is not None:
            self.HidePreviewWindow()
            lines = errmsg.lower().split('\n')
            items = lines[-1].split()
            try:
                index = items.index('line') + 1
                if index < len(items):
                    try:
                        linenum = int(items[index].strip('),')) - 1
                        if linenum < script.GetLineCount():
                            posA = script.PositionFromLine(linenum)
                            posB = script.GetLineEndPosition(linenum)
                            script.SetSelection(posA, posB)
                            doFocusScript = True
                    except ValueError:
                        pass
            except ValueError:
                pass
            script.SetFocus()
            script.EnsureCaretVisible()
            return False

        script.lastFramenum = framenum
        self.SetVideoStatusText(framenum, primary=True, addon0=addon0)
        return True

    def ShowVideoFrame(self, framenum=None, forceRefresh=False, wrap=True, script=None,
                       userScrolling=False, keep_env=None, forceLayout=False, doLayout=True,
                       resize=None, scroll=None, focus=True, adjust_handle=False,
                       check_playing=False, forceCursor=False, addon0='', forceThread=False,
                       frameToFrametime=False, disableFastClip=False):

        def UpdateSliders():
            doFocusScript = False
            toggleTagNames = [a for a,b in script.toggleTags]
            oldToggleTagNames = [a for a,b in script.oldToggleTags]
            if forceRefresh:
                script.oldSliderTexts = oldToggleTagNames = script.oldAutoSliderInfo = None
            if not userScrolling and (script.sliderTexts != script.oldSliderTexts or toggleTagNames != oldToggleTagNames or script.autoSliderInfo != script.oldAutoSliderInfo):
                needLayout = True
                if toggleTagNames != oldToggleTagNames:
                    self.createToggleTagCheckboxes(script)
                if script.autoSliderInfo != script.oldAutoSliderInfo:
                    self.createAutoUserSliders(script)
                if script.sliderTexts != script.oldSliderTexts:
                    if not self.createUserSliders(script):
                        doFocusScript = True
                script.sliderWindow.Freeze()
                script.videoSidebarSizer.Layout()
                script.propertySizer.Layout()
                script.sliderWindow.FitInside()
                self.TryThaw(script.sliderWindow)
            return doFocusScript


        if script is None:
            script = self.currentScript

        # Exit if disable preview option is turned on
        if self.options['disablepreview']:
            if script.previewFilterIdx > 0:
                self.SetPreviewFilterMenus()
            if self.SplitClipCtrl.IsActive:
                    self.SplitClipCtrl.Close()
            return

        # Check thread still alive
        if self.AviThread_Running(script, prompt=False):
            #try:
                #self.DeletePendingEvents()
           # except:
                #pass
            return

        if script.AVI is None:
            forceRefresh = True
            forceCursor = True
            frameToFrametime = False
        else:
            if frameToFrametime:
                _lastFramerate = script.AVI.Framerate
            if framenum: # force cursor if step size > 1 frame
                if abs(framenum - script.lastFramenum) > 1:
                    forceCursor = True

        needLayout = None
        display_clip_refresh_needed = script.display_clip_refresh_needed

        if forceCursor and not wx.IsBusy():
            wx.BeginBusyCursor()

        try:
            # Attention, OnPageChange UpdateScriptAVI is called if the preview is visible,
            # then boolNewAvi is here False or None. Therefore no further check for a new Avi is possible here.
            boolNewAVI = self.UpdateScriptAVI(script, forceRefresh, keep_env=keep_env, showCursor=self.options['refreshpreview'] and not forceCursor,
                                                disableFastClip=disableFastClip)

            #boolNewAVI = self.UpdateScriptAVI(script, forceRefresh, keep_env=keep_env, showCursor=False,
                                                #disableFastClip=disableFastClip)
            if boolNewAVI is None:
                #if self.UseAviThread:
                self.HidePreviewWindow()
                self.ClipRefreshPainter = False
                self.bmpVideo = None
                self.UpdateScriptTabname(self.currentScript)
                self.SetPreviewFilterMenus()
                if self.SplitClipCtrl.IsActive:
                    self.SplitClipCtrl.Close()
                self.splitView = False
                return False

            # Get the desired AVI frame to display
            if framenum is None:
                framenum = script.lastFramenum
            try:
                # assume framenum is an integer
                if framenum is None:
                    framenum = self.videoSlider.GetValue()
                framenum += 0
            except TypeError:
                # assume framenum is a string (time)
                timetxt = framenum.split(':')
                if len(timetxt) == 3:
                    try:
                        hours = int(timetxt[0])
                        minutes = int(timetxt[1])
                        seconds = float(timetxt[2])
                        total_seconds = hours * 60 * 60 + minutes * 60 + seconds
                        framenum = int(round((script.AVI.Framerate * total_seconds)))
                    except ValueError:
                        framenum = 0
                else:
                    framenum = 0
            except AttributeError: # don't know what framenum is
                framenum = 0
            else: # convert framenum to previous frame time
                if frameToFrametime and _lastFramerate != script.AVI.Framerate \
                    and script.lastLength != script.AVI.Framecount and script.lastFramenum == framenum and framenum > 0:
                        try:
                            framenum = int(round((float(script.AVI.Framerate) / _lastFramerate) * framenum))
                            """ # alternative
                            ms = float(framenum) / _lastFramerate
                            framenum = int(round(script.AVI.Framerate * ms))
                            """
                        except:
                            pass

            if framenum < 0:
                if wrap:
                    while framenum < 0:
                        framenum += script.AVI.Framecount
                else:
                    framenum = 0

            if framenum >= script.AVI.Framecount:
                framenum = script.AVI.Framecount-1
            if self.currentframenum != framenum:
                self.snapShotIdx = 0

            # Reset the video frame slider range if necessary (if not AutoReset do nothing)
            if self.videoSlider.GetMax() != script.AVI.Framecount-1:
                if adjust_handle:
                    pos = float(framenum - self.videoSlider.minValue) / (
                            self.videoSlider.GetMax()+1 - self.videoSlider.minValue)
                    framenum = min(max(int(round(pos * script.AVI.Framecount)), 0), script.AVI.Framecount-1)
                if self.timelineAutoReset or not self.videoSlider.offsetSet or (script.AVI.Framecount < 49): # minimum count for allowed offset is 30
                    self.videoSlider.SetOffset(0, 0)
                    self.timelineRange = 0
                    self.videoSlider.SetRange(0, script.AVI.Framecount - 1, refresh=False)
                    if self.separatevideowindow:
                        self.videoSlider2.SetOffset(0, 0)
                        self.videoSlider2.SetRange(0, script.AVI.Framecount - 1, refresh=False)
                else:
                    self.videoSlider.SetRange(0, script.AVI.Framecount - 1, refresh=False)
                    if self.separatevideowindow:
                            self.videoSlider2.SetRange(0, script.AVI.Framecount - 1, refresh=False)
                    if self.videoSlider.offsetSet:
                        self.OnMenuSetTimeLineRange(frange=self.timelineRange, r_center=framenum)
                    else:
                        self.videoSlider.SetOffset(0, 0)
                        self.timelineRange = 0
                        if self.separatevideowindow:
                            self.videoSlider2.SetOffset(0, 0)

            # set the new center for the slider range (if autoScroll) and update the slider position
            if self.videoSlider.offsetSet and (self.videoSlider.GetVirtualMax() < framenum \
                or self.videoSlider.startOffset > framenum):
                if self.timelineAutoScroll:
                    if not self.OnMenuSetTimeLineRange(frange=self.timelineRange, r_center=framenum):
                        self.videoSlider.SetValue(framenum)
                else:
                    # if not autoScroll set the min and max allowed frame nr
                    framenum = max(min(framenum, self.videoSlider.GetVirtualMax()), self.videoSlider.startOffset)
                    self.videoSlider.SetValue(framenum)
            else:
                self.videoSlider.SetValue(framenum)
            self.currentframenum = framenum

            if framenum in self.GetBookmarkFrameList():
                color = wx.RED
                if self.bellAtBookmark and framenum != script.lastFramenum:  # GPo
                    wx.Bell()
            else:
                color = wx.BLACK

            self.frameTextCtrl.SetForegroundColour(color)
            self.frameTextCtrl.ChangeValue(str(framenum))
            self.frameTextCtrl.Update()
            if self.separatevideowindow:
                self.videoSlider2.SetValue(framenum)
                self.frameTextCtrl2.SetForegroundColour(color)
                self.frameTextCtrl2.ChangeValue(str(framenum))
                self.frameTextCtrl2.Update()

            # get the frame from avisynth. forceThread=True is only on pagechange event set
            if not forceThread and (script.AVI.current_frame == framenum): # make it faster don't use thread (for sliders and other funcs that uses ShowFrame)
                script.AVI.display_clip.get_frame(framenum)
            elif self.UseAviThread:
                if not self.GetAviDisplayFrame(script, framenum, srcFrame=False): # then user hase canceled the thread
                    self.HidePreviewWindow()
                    self.ClipRefreshPainter = False
                    if self.readFrameProps:
                        self.AVICallBack('property', 'Error', framenum)
                    return False
            else:
                script.AVI.display_clip.get_frame(framenum)

            # Check for errors when retrieving the frame before updating the gui
            error = script.AVI.display_clip.get_error()
            if error is not None:
                self.HidePreviewWindow()
                self.bmpVideo = None
                self.ClipRefreshPainter = False
                if self.readFrameProps:
                    self.AVICallBack('property', 'Error', framenum)
                if self.SplitClipCtrl.IsActive:
                    self.SplitClipCtrl.Close()
                if wx.IsBusy():
                    wx.EndBusyCursor()
                ID = wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=framenum),
                              error)), _('Error'), style=wx.OK|wx.ICON_ERROR)
                return False

            try:
                if self.forceZoom: # position and zoom for each script (must be set Notebook.OnPageChange)
                    self.forceZoom = False # reset it immediately
                    if script.lastZoom is not None and not self.splitView:
                        if self.saveViewPos == 2:
                            scroll, self.zoomfactor, self.zoomwindow, self.zoomwindowfill, self.zoomwindowfit = script.lastZoom
                        elif self.saveViewPos == 1:
                            scroll = script.lastZoom[0]
            except:
                self.forceZoom = False

            # Resize the video window as necessary
            oldSize = self.videoWindow.GetVirtualSize()
            videoWidth = w = int(script.AVI.DisplayWidth * self.zoomfactor)
            videoHeight = h = int(script.AVI.DisplayHeight * self.zoomfactor)
            if self.zoomwindowfit and not self.splitView:
                self.videoWindow.SetVirtualSize((0,0))

            """ At this place before (frame, bmpVideo, dc) are initialized,
                python memory proplems if many sliders created then videoWindow loses the dc or whatever (on first run).
                But only if the avsp.py bytecode was created (pyo) with the normal avsp.py there are no problems. """
            #doFocusScript = UpdateSliders()

            needLayout = doLayout and (forceLayout or not self.previewWindowVisible or (videoWidth != self.oldWidth) or (videoHeight != self.oldHeight))
            if needLayout:
                if not self.splitView:
                    zfa = intPPI(3 if self.zoomfactor <= 2 else 4)  # GPo, make the free space larger over 2.0 zoom, must also change OnEraseBackground()
                    if self.extended_move and not self.zoomwindow and not self.separatevideowindow:
                        wA, hA = self.videoWindow.GetClientSize()
                        self.videoWindow.SetVirtualSize((w + self.xo + zfa + int(wA/2), h + self.yo + zfa))
                    elif not self.zoomwindow:
                        self.videoWindow.SetVirtualSize((w + self.xo + zfa, h + self.yo + zfa))
                    elif self.zoomwindowfill:
                        self.videoWindow.SetVirtualSize((w + self.xo + zfa, 0))
                if self.zoomwindow:
                    oldSize = (-1,-1) # force calculate zoom and erase background
                if script.AVI.IsErrorClip():
                    script.lastSplitVideoPos = None

                # freeze always if forceLayout (eliminate flickering)
                if not self.separatevideowindow:
                    self.mainSplitter.Freeze()
                self.videoWindow.Freeze()

                """ moved down
                self.LayoutVideoWindows(w, h, forceRefresh=forceRefresh or display_clip_refresh_needed)
                self.toggleButton.SetBitmapLabel(self.bmpVidDown)
                self.toggleButton.Refresh()
                """
            newSize = self.videoWindow.GetVirtualSize()
            # Force a refresh when resizing the preview window
            oldVideoSize = (self.oldWidth, self.oldHeight)
            newVideoSize = (videoWidth, videoHeight)
            self.bmpVideo = None
            if newSize != oldSize or newVideoSize != oldVideoSize or not self.previewWindowVisible:
                self.previewWindowVisible = True
                needCalcZoom = self.zoomwindow
                # use IdleCall otherwise separate video window flickers on showing (TODO: Layout is moved test it again)
                self.IdleCall.append((self.UpdateScriptTabname, tuple(), {'script': script}))

                # GPo 2020, if zoomwindow zoom must calc new, if preview wasn't visible or layout or size changed
                # also must new set the video size values (self.zoomfactor is changed)
                """ moved after LayoutVideoWindows
                if self.zoomwindow:
                    self.CalculateZoomFitFill(script)
                    videoWidth = w = int(script.AVI.DisplayWidth * self.zoomfactor)
                    videoHeight = h = int(script.AVI.DisplayHeight * self.zoomfactor)
                    newVideoSize = (videoWidth, videoHeight)
                    # end new set
                    if self.zoomwindowfill and not self.splitView:
                        zfa = 3 if self.zoomfactor <= 2 else 4
                        self.videoWindow.SetVirtualSize((w + self.xo + zfa, 0))
                """
                if self.customHandler > 0:
                    self.PostMessage(self.customHandler, self.AVSP_VID_SIZE, videoWidth, videoHeight)

                self.OnEraseBackground() # leave it before paint (better for zooming with the mouse wheel)
                self.PaintAVIFrame(wx.ClientDC(self.videoWindow), script, self.currentframenum)
            else:
                needCalcZoom = False
                self.PaintAVIFrame(wx.ClientDC(self.videoWindow), script, self.currentframenum)

            # That's the pain, we have to scroll the video window, the frame can't be drawn with offset, so it flickers.
            # We have to do something about it. Freeze seems to be the only way. Freeze is also calling on mouse event zoom
            if scroll is not None:
                self.videoWindow.Scroll(*scroll)

            """
            New position to create the sliders. After the videoWindow dc is initialized and the frame is drawn. See above (memory problems)
            But now we must Layout later else the sliders doesn't update
            For Layout It is also a better place for the separate video window and generally flickering is reduced
            """
            """ !!! UpdateSliders must be before Layout, sets also needLayout=True if sliders changed !!! """
            doFocusScript = UpdateSliders()
            if needLayout:
                self.LayoutVideoWindows(w, h, forceRefresh=forceRefresh or display_clip_refresh_needed)
                self.toggleButton.SetBitmapLabel(self.bmpVidDown)
                self.toggleButton.Refresh()
                self.mainSplitter.UpdateSize()

            # zoom (fit, fill) can only be calculated after the layout, so if the layout changed,
            # the paint event repaint the video window with the new zoomfactor ( self.videoWindow.Thaw() )
            if needCalcZoom:
                if not needLayout:
                    self.mainSplitter.UpdateSize()
                self.CalculateZoomFitFill(script)
                videoWidth = w = int(script.AVI.DisplayWidth * self.zoomfactor)
                videoHeight = h = int(script.AVI.DisplayHeight * self.zoomfactor)
                newVideoSize = (videoWidth, videoHeight)
                if self.zoomwindowfill and not self.splitView:
                    zfa = 3 if self.zoomfactor <= 2 else 4
                    self.videoWindow.SetVirtualSize((w + self.xo + zfa, 0))

            # If error clip, highlight the line with the error
            errmsg = script.AVI.error_message
            if errmsg is not None:
                if not self.options['autoupdatevideo']:
                    lines = errmsg.lower().split('\n')
                    items = lines[-1].split()
                    try:
                        index = items.index('line') + 1
                        if index < len(items):
                            try:
                                linenum = int(items[index].strip('),')) - 1
                                if linenum < script.GetLineCount():
                                    posA = script.PositionFromLine(linenum)
                                    posB = script.GetLineEndPosition(linenum)
                                    script.SetSelection(posA, posB)
                                    doFocusScript = True
                            except ValueError:
                                pass
                    except ValueError:
                        pass
            else:
                # antialias
                if (self.zoomfactor != 1 or self.zoomwindow) and self.zoom_antialias:
                    self.IdleCallDict['videoWindowRefresh'] = self.videoWindow.Refresh # only one refresh

            if doFocusScript:
                script.SetFocus()
                script.EnsureCaretVisible()
            else:
                if focus:
                    self.videoWindow.SetFocus()
                    primary = True
                else:
                    primary = self.FindFocus() == self.videoWindow
                addon = None
                if primary:
                    self.TryThaw(self.videoWindow)
                    pixelInfo = self.GetPixelInfo(event=None, string_=True)
                    if pixelInfo[1] is not None:
                        addon = pixelInfo
                self.SetVideoStatusText(framenum, primary=primary, addon=addon)

            # Store video information (future use)
            self.oldWidth = videoWidth
            self.oldHeight = videoHeight
            self.oldFramecount = script.AVI.Framecount
            script.oldSliderTexts = script.sliderTexts
            script.oldAutoSliderInfo = script.autoSliderInfo
            script.oldToggleTags = script.toggleTags
            script.lastFramenum = framenum
            script.lastLength = script.AVI.Framecount
            # is only called if preview was not visible on create the new avi
            # but now it is also called on resize filter or display filter changed
            # so check it... TODO
            if boolNewAVI and not display_clip_refresh_needed:
                self.ShowFreeMemory()
            if script.AVI.readFrameProps:
                self.AVICallBack('property', script.AVI.properties)

        finally: # so also on abort (return)
            if wx.IsBusy():
                wx.EndBusyCursor()
            if needLayout:
                self.TryThaw(self.mainSplitter)
                self.TryThaw(self.videoWindow)
        return True

    def LayoutVideoWindows(self, w=None, h=None, forcefit=False, forceRefresh=False):
        script = self.currentScript
        if w is None:
            w = int(script.AVI.DisplayWidth * self.zoomfactor)
        if h is None:
            h = int(script.AVI.DisplayHeight * self.zoomfactor)
        # Show or hide slider window
        if True:
            if self.propWindowParent > 0:
                boolSliders = True # for display frame properties in the slider window
            else:
                boolSliders = bool(script.sliderTexts or script.sliderProperties or script.toggleTags or script.autoSliderInfo)
            if boolSliders:
                self.toggleSliderWindowButton.Enable()
                if script.sliderWindowShown:
                    script.sliderWindow.Show()
                    self.ShowSliderWindow(script, vidrefresh=False)
                    #print('ShowSliderWindow')
                else:
                    if forceRefresh and not self.videoSplitter.IsSplit() and not self.options['keepsliderwindowhidden'] and not script.userHidSliders:
                        self.ToggleSliderWindow()
                    else:
                        #print('HideSliderWindow')
                        if self.videoSplitter.IsSplit():
                            self.HideSliderWindow(script, vidrefresh=False)
            else:
                if self.videoSplitter.IsSplit():
                    script.sliderWindowShown = True
                    self.ToggleSliderWindow()
                self.toggleSliderWindowButton.Disable()
                script.sliderWindowShown = False

        if self.separatevideowindow:
            if not self.videoDialog.IsShown():
                def videoWndShow():
                    self.zoom_antialias = False
                    self.videoDialog.Show()
                    self.ResetZoomAntialias()
                self.UpdateScriptTabname(script=script)
                # we need CallAfter, otherwise thread dialog is not closed if dialog is shown
                wx.CallAfter(videoWndShow)
            else:
                wx.CallAfter(self.videoDialog.Show)
            return
        # Set the splitter positions
        if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
            self.SplitVideoWindow(h, forcefit=forcefit)
        else:
            self.SplitVideoWindow(w, forcefit=forcefit)

    def SplitVideoWindow(self, pos=None, forcefit=False):
        if not self.mainSplitter_SetSashPos:
            sash_pos = self.GetMainSplitterNegativePosition(pos=pos, forcefit=forcefit)
        else:
            sash_pos = self.mainSplitter_SetSashPos
            self.mainSplitter_SetSashPos = None
        if not isinstance(sash_pos, int):
            return
        if self.mainSplitter.IsSplit():
            self.mainSplitter.SetSashPosition(sash_pos)
            #if self.zoomwindow:(
                #self.currentScript.lastSplitVideoPos = sash_pos #GPo moved to OnFocusVideoWindow
        else:
            if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
                self.mainSplitter.SplitHorizontally(self.scriptNotebook, self.videoPane, sash_pos)
            else:
                self.mainSplitter.SplitVertically(self.scriptNotebook, self.videoPane, sash_pos)
        if self.previewOK():
            self.currentScript.lastSplitVideoPos = sash_pos # GPo new

    def GetMainSplitterNegativePosition(self, pos=None, forcefit=False):
        if not forcefit and isinstance(self.currentScript.lastSplitVideoPos, int): #self.currentScript.lastSplitVideoPos is not None:
            pos = self.currentScript.lastSplitVideoPos
        else:
            script = self.currentScript
            if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
                if pos is None:
                    if script.AVI is None:
                        vidheight = 0 #? return -17 makes this sense ?
                        #return -self.GetClientSize()[1] # equal to None makes more sense ?
                    else:
                        vidheight = script.AVI.DisplayHeight
                    h = int(vidheight * self.zoomfactor)
                else:
                    h = pos
                pos = -(h + (2 * self.yo) + 5 + self.mainSplitter.GetSashSize()/2) # GPo, leave it or must change GetFitWindowSize
            else:
                if pos is None:
                    if script.AVI is None:
                        vidwidth = 0
                        #return -self.GetClientSize()[0] # equal to None
                    else:
                        vidwidth = script.AVI.DisplayWidth
                    w = int(vidwidth * self.zoomfactor)
                else:
                    w = pos
                pos = -(w + 2 * self.xo + 5 + self.mainSplitter.GetSashSize()/2 +
                        self.toggleSliderWindowButton.GetSize()[0])
        return pos

    def ToggleSliderWindow(self, vidrefresh=False):
        #self.videoPaneSizer.Layout()
        # TODO...
        if True: #button.IsEnabled():
            if self.currentScript.sliderWindowShown:
                self.HideSliderWindow(self.currentScript, vidrefresh=vidrefresh)
            else:
                self.ShowSliderWindow(self.currentScript, vidrefresh=vidrefresh)
        if vidrefresh:
            if self.zoomwindowfill:
                self.ShowVideoFrame(focus=False, doLayout=False)

    def ShowSliderWindow(self, script, vidrefresh=True):
        isShown = self.videoSplitter.IsSplit()
        if not isShown:
            self.zoom_antialias = False

        button = self.toggleSliderWindowButton
        # Show the sliders
        ''' We must restore the parent '''
        if script.sliderWindow.Parent != self.videoSplitter:
            script.sliderWindow.Reparent(self.videoSplitter)

        self.videoSplitter.Freeze()
        if isShown:
            self.videoSplitter.ReplaceWindow(self.videoSplitter.GetWindow2(), script.sliderWindow)
            self.videoSplitter.SetSashPosition(script.lastSplitSliderPos)
        else:
            if self.propWindowParent > 0:
                script.propertySizer.Layout()
                #if self.propWindowParent == 1:
                    #script.videoSidebarSizer.Layout()
            self.videoSplitter.SplitVertically(self.videoWindow, script.sliderWindow, script.lastSplitSliderPos)

        self.TryThaw(self.videoSplitter)
        script.sliderWindow.Show()
        script.sliderWindowShown = True
        button.SetBitmapLabel(button.bmpHide)
        button.Refresh()
        if not isShown and vidrefresh: # make sure only on show (there multiple calls to this function)
            resize = self.previewOK(script) and script.resizeFilter[0] and script.resizeFilter[2] == 1 and not script.resizeFilter[3]
            if resize:
                if self.splitView:
                    self.ResizeFilterUpdateSplitView()
                else:
                    script.display_clip_refresh_needed = True
            self.ShowVideoFrame(forceLayout=True)
            self.ResetZoomAntialias()

    def HideSliderWindow(self, script, vidrefresh=True):
        isShown = self.videoSplitter.IsSplit()
        if isShown and vidrefresh:
            self.zoom_antialias = False
        button = self.toggleSliderWindowButton
        # Hide the sliders
        self.videoSplitter.Unsplit()
        script.sliderWindow.Hide()
        ''' Workaround for slow program move on the screen. The more sliders the slower is the moving. Is also with the original version.
        # Seems to be a wxPython bug, hidden slider window receive events and slows down moving the program on the screen.
        # So we change the parent to a hidden wnd (tempVideoDialog) if slider window hidden.
        # This concerns the whole program (not only the video dialog)
        '''
        if script.sliderWindow.Parent == self.videoSplitter:
            script.sliderWindow.Reparent(self.tempVideoDialog)

        script.sliderWindowShown = False
        button.SetBitmapLabel(button.bmpShow)
        button.Refresh()
        if isShown and vidrefresh: # make sure only on hide (there multiple calls to this function)
            resize = self.previewOK(script) and script.resizeFilter[0] and script.resizeFilter[2] == 1 and not script.resizeFilter[3]
            if resize:
                if self.splitView:
                    self.ResizeFilterUpdateSplitView()
                else:
                    script.display_clip_refresh_needed = True
            self.ShowVideoFrame(forceLayout=True)
            self.ResetZoomAntialias()

    def ShowVideoOffset(self, offset=0, units='frames', focus=True):
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=False)
            self.playing_video = ''
        script = self.currentScript
        if script.AVI is None:
            self.UpdateScriptAVI()
        units = units.lower()
        if units == 'frames':
            offsetFrames = offset
        elif units in ('sec', 'seconds'):
            offsetFrames = offset * int(round(script.AVI.Framerate))
        elif units in ('min', 'minutes'):
            offsetFrames = offset * int(round(script.AVI.Framerate * 60))
        elif units in ('hr', 'hours'):
            offsetFrames = offset * int(round(script.AVI.Framerate * 60 * 60))
        else: offsetFrames = offset
        framenum = offsetFrames + self.videoSlider.GetValue()
        self.ShowVideoFrame(framenum, wrap=False, script=script, focus=focus,forceCursor=self.ScriptChanged(script))
        if self.playing_video == '':
            self.PlayPauseVideo()

    # GPo 2020 bmtype 0,1,2 or 3 (3 = only bookmarks with title)
    def GotoNextBookmark(self, reverse=False, forceCursor=False, bmtype=[]):
        if self.playing_video:
            self.PlayPauseVideo()
            self.playing_video = ''
        current_frame = self.GetFrameNumber()
        clip = self.currentScript.AVI
        bmDict = self.GetBookmarkFrameList(copy=True) # !! copy=True otherwise you change the bookmarks !!
        bmDict.update(self.videoSlider.selectionsDict)  # add selections
        if clip is not None:
            if not bmtype:
                bookmarkValues = [value for value in bmDict.keys() if value < clip.Framecount] # goto all
            elif not 3 in bmtype:                                                              # goto bmtype (0,1,2)
                bookmarkValues = [value for value, btype in bmDict.items()
                                    if (btype in bmtype) or (isinstance(btype, basestring) and 0 in bmtype) and value < clip.Framecount]
            else:
                bookmarkValues = [value for value, btype in self.GetBookmarkFrameList().items() # go only to titled bookmarks
                                    if value in self.titleDict and value < clip.Framecount]
        else:
            if not bmtype:
                bookmarkValues = [value for value in bmDict.keys()]
            elif not 3 in bmtype:
                bookmarkValues = [value for value, btype in bmDict.items() if (btype in bmtype) or (isinstance(btype, basestring) and 0 in bmtype)]
            else:
                bookmarkValues = [value for value, btype in self.GetBookmarkFrameList().items()
                                    if value in self.titleDict]

        if len(bookmarkValues) == 0:
            return
        bookmarkValues.sort()

        if reverse:
            idx = bisect.bisect_left(bookmarkValues, current_frame) or len(bookmarkValues)
            new_frame = bookmarkValues[idx-1]
        else:
            idx = bisect.bisect_right(bookmarkValues, current_frame)
            if idx == len(bookmarkValues):
                new_frame = bookmarkValues[0]
            else:
                new_frame = bookmarkValues[idx]

        self.zoom_antialias = False
        v = self.previewWindowVisible
        self.ShowVideoFrame(new_frame, forceCursor=forceCursor)
        if self.options['zoom_antialias']:
            if self.zoomfactor != 1 or self.zoomwindow:
                if not v: self.SaveCallYield() #wx.Yield()
                self.zoom_antialias = True
                self.videoWindow.Refresh()
            else:
                self.zoom_antialias = True

        if self.playing_video == '':
            wx.CallAfter(self.PlayPauseVideo)  # GPo

    # GPo 2020, extern for better handling
    def CalculateZoomFitFill(self, script = None):
        if script is None:
            script = self.currentScript
        if self.zoomwindow and script.AVI is not None:
            try:
                fitWidth, fitHeight = self.GetFitWindowSize()
                if fitWidth == None:
                    return
                if self.splitView and self.zoomwindowfit:
                    zoomfactorWidth = float(fitWidth) / script.AVI.DisplayWidth / 2
                    zoomfactorHeight = float(fitHeight) / script.AVI.DisplayHeight
                else:
                    zoomfactorWidth = float(fitWidth) / script.AVI.DisplayWidth
                    zoomfactorHeight = float(fitHeight) / script.AVI.DisplayHeight
                if self.zoomwindowfill:
                    self.zoomfactor = zoomfactorHeight
                else:
                    self.zoomfactor = min(zoomfactorWidth, zoomfactorHeight)
            except TypeError:
                pass

    # call back for avi clip
    def AVICallBack(self, ident, value, framenr=-1):
        def _showMessage(title, msg):
            wx.SafeShowMessage(title, msg)

        # Make thread safe, so for some calls 'CallAfter'
        if ident == 'preview':
            wx.CallAfter(self.OnMenuPreviewFilter, index=value)
        elif ident == 'property':
            if framenr == -1:
                self.propWindow.SetText(value)
            else:
                self.propWindow.SetText('Frame: ' + str(framenr) + '\n' + value)
        elif ident == 'splitclip':
            if self.SplitClipCtrl.IsActive:
                wx.CallAfter(self.SplitClipCtrl.Close)
        elif ident == 'bit_depth':
            self.bit_depth = False
            wx.CallAfter(self.UpdateMenuItem, _('Display'), True, 'video', [_('Bit depth'), _('8-bit')])
        elif ident == 'error':
            wx.CallAfter(_showMessage, str(framenr), str(value))
        elif ident == 'errorclip':
            return True
            """ # moved to UpdateScriptAvi
            # on error clip set 100% zoom and disable the resizeFilter only for currentScript leaf show=False!
            wx.CallAfter(self.OnMenuVideoZoom, zoomfactor=1, show=False,
                resizeFilterOff=True, script=self.currentScript)
            """
        elif ident == 'displayerror':
            wx.CallAfter(_showMessage,'Convert RGB32 error', value)
        else:
            return
        return True

    def AviFree(self, script, updateTabname=False):

        def _avifree(script):
            try:
                script.AVI = None
            except:
                wx.CallAfter(_print, 'Error while releasing clip.')

        if script.AVI is None:
            return True
        # if avisynth in progress we cannot release the clip also return
        if self.AviThread_Running(script, prompt=not self.AppClosing):
            if self.AppClosing:
                return True
            return

        # Don't use thread if app on closing
        if not self.AppClosing and self.UseAviThread:
            th = threading.Thread(target=_avifree, args=(script,))
            th.daemon = True
            script.AviThread = th
            th.name = 'clip'
            th.start()
            th.join(10)
            if th.isAlive():
                self.Enable(False)
                i = 0
                msgShown = False
                msg = utils.resource_str_threadwait
                msg_1 = msg if self.WinVersion < 7 else ''

                progress = wx.ProgressDialog(_('Waiting for avisynth release memory'),msg_1,10,self,
                                style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                try:
                    while th.isAlive():
                        c,s = progress.Pulse()
                        if not c:
                            if i > 15: break
                            else:
                                msgShown = True
                                progress.Pulse(msg)
                        if not msgShown and i > 10:
                            msgShown = True
                            progress.Pulse(msg)
                        i += 1
                        th.join(0.5)
                finally:
                    self.Enable(True)
                    progress.Destroy()

                if th.isAlive():
                    self.StatusbarTimer_Start(3000, _('Clip not released. Memory still allocated'))
                    return False
                script.AviThread = None
                self.StatusbarTimer_Start(3000, _('Clip successful released'))
            else:
                script.AviThread = None

            if updateTabname:
                self.UpdateScriptTabname(script)
        else:
            script.AVI = None
            script.AviThread = None
            if updateTabname:
                self.UpdateScriptTabname(script)
        #gc.collect()
        return True

    # calculate the resize values, only for spezial cases
    # normaly pyavs AVI clip calculates the values
    # if you change it you must change pyavs CalcResizeFilter
    def CalcResizeFilter(self, script, zoom=1, fitHeight=True):
        if not script.AVI:
            return
        cSize = self.videoWindow.GetSize()
        if cSize[0] < 12 or cSize[1] < 12:
            return
        vi = script.AVI.main_clip_vi if not script.AVI.IsSplitClip else script.AVI.split_clip_vi
        mod = 2 if not vi.is_yv411() else 4
        #if you change it you must change GetResizeFilterInfo
        cSize[1] -= (self.xo*2) + self.mainSplitter.GetSashSize()/2
        cSize[0] -= (self.yo*2) + self.mainSplitter.GetSashSize()/2
        vW, vH = vi.width, vi.height
        ratio = float(vW)/vH
        if zoom == 1:
            factorWidth = float(cSize[0]) / vW
            factorHeight = float(cSize[1]) / vH
            if fitHeight or factorWidth >= factorHeight:
                H = int(float(cSize[1])/mod)*mod
                W = round(float(H)*ratio/mod)*mod
                if fitHeight and not self.options['hidescrollbars'] and W > cSize[0]:
                    H -= utils.GetScrollbarMetric_X() - 2
                    H = int(float(H)/mod)*mod
                    W = round(float(H)*ratio/mod)*mod
            else:
                W = round(float(cSize[0])/mod)*mod
                H = int(float(W)/ratio/mod)*mod
        else:
            W = round(vW* zoom) //mod*mod
            H = round(vH* zoom) //mod*mod

        if W < 12 or H < 12 or (float(W + H) / (vW + vH) > 2.5):
            return
        return (self.options['resizefilter'],W,H,vW,vH)

    # create the resize info for the AVI clip,
    # this info must be send to the AVI before a displayClip is new created
    # e.g. AVI.SetResizeFilter(GetResizeFilterInfo(script))
    def GetResizeFilterInfo(self, script, fixed_Size=None):
        if script.resizeFilter[0]: # then enabled
            if fixed_Size is None:
                cSize = self.videoWindow.GetSize()
                #if you change it you must change CalcResizeFilter
                cSize[1] -= (self.xo*2) + self.mainSplitter.GetSashSize()/2
                cSize[0] -= (self.yo*2) + self.mainSplitter.GetSashSize()/2
                scrollbarhiden = self.options['hidescrollbars']
            else:
                cSize = fixed_Size
                scrollbarhiden = True
            if cSize[0] < 36 or cSize[1] < 36:
                return
            try:
                e, f, zoom, fit = script.resizeFilter
            except:
                return
            return (f, cSize[0], cSize[1], zoom, fit, scrollbarhiden)
        return

    def UpdateScriptAVI(self, script=None, forceRefresh=False, keep_env=None,
                        prompt=True, showCursor=True, resizeFilterInfo=None, disableFastClip=False):

        def updateAbandonedScript(AVI, script, scripttxt, scr_filename):
            def _showDialog(idx):
                if self.IsEnabled() and not self.ClipRefreshPainter:
                    wx.GetApp().ProcessIdle()
                    dlg = wx.MessageDialog(self,_('Abandoned clip assigned. Select the tab?'), style=wx.YES_NO|wx.CENTRE)
                    ID = dlg.ShowModal()
                    dlg.Destroy()
                    if ID == wx.ID_YES:
                        self.HidePreviewWindow()
                        self.scriptNotebook.SetSelection(idx)
            try:
                # check the clip and script again in the main thread, ignor AVI.isErrorClip
                if isinstance(AVI, pyavs.AvsClipBase) and isinstance(script, AvsStyledTextCtrl):
                    idx = -1
                    for i in xrange(self.scriptNotebook.GetPageCount()):
                        if self.scriptNotebook.GetPage(i) is script:
                            idx = i
                            break
                    if idx > -1:
                        if script.GetText() != scripttxt:
                            script.SetText(scripttxt) # set the text with which the clip was loaded
                        script.Colourise(0, script.GetTextLength())
                        script.previewtxt = self.ScriptChanged(script, return_styledtext=True)[1]
                        script.AVI = AVI
                        script.display_clip_refresh_needed = True
                        self.StopPlayback()
                        self.UpdateScriptTagProperties(script, scripttxt)
                        self.GetAutoSliderInfo(script, scripttxt)
                        self.UpdateScriptTabname(script) # set loaded state
                        self.StatusbarTimer_Start(3000, _(u'Abandoned clip assigned: "{0}"').format(scr_filename), bellcount=1)
                        if self.scriptNotebook.GetSelection() != idx:
                            wx.CallAfter(_showDialog, idx)
                        return True
            except:
                pass
            return False

        # only used if not AVI Updated and only a new DisplayClip is needed
        def TH_CreateDisplayClip(script, readmatrix, killFilterClip):
            def _createDisplayClip(script, readmatrix, q):
                ok = script.AVI.CreateDisplayClip(matrix=script.matrix, interlaced=self.interlaced,
                        swapuv=self.swapuv, bit_depth=self.bit_depth, readmatrix=readmatrix, killFilterClip=killFilterClip, killSplitClip=False)
                q.put(ok)
            q = queue.Queue()
            try:
                th = threading.Thread(target=_createDisplayClip, args=(script, readmatrix, q,))
                if not isinstance(th, threading.Thread):
                    raise
                th.daemon = True
                th.name = 'clip'
                script.AviThread = th
                th.start()
                wx.MilliSleep(5)
            except:
                return False
            ok = False
            disabler = wx.WindowDisabler()
            th.join(self.progressDelayTime)
            try:
                try:
                    ok = q.get_nowait()
                except:
                   pass

                if th.isAlive() and not ok:
                    i = 0
                    c = True
                    msg =  _('Process display clip...')
                    progress = wx.ProgressDialog(_('Waiting for display clip'),msg ,10,self,
                        style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                    try:
                        while th.isAlive():
                            c,s = progress.Pulse()
                            if not c:
                                if i > 10: break
                            i += 1
                            th.join(0.5)

                        if c: # if wx.GetApp().ProcessIdle() then never show
                            progress.Pulse(_('Process finished'))
                    finally:
                        progress.Destroy()
                        wx.GetApp().ProcessIdle()
                    try:
                        ok = q.get_nowait()
                    except:
                        pass

                    if th.isAlive():
                        self.Thread_List.append((th,q))
            finally:
                del disabler
                if not th.isAlive():
                    script.AviThread = None
                return ok

        def _getClip(script,scripttxt,filename,workdir,env,fitHeight,fitWidth,oldFramecount,matrix,interlaced,swapuv,bit_depth,callBack,
                        readmatrix,displayFilter,readFrameProps,resizeFilter,previewFilter,useSplitClip,useFastClip, q,rq):
            scr_filename = script.filename
            AVI = None
            wx.MilliSleep(30) # wait a little, give priority to the main thread

            if useFastClip and script.AVI is not None:
                if script.AVI.CreateFastClip(script=script,useSplitClip=useSplitClip,previewFilter=previewFilter,matrix=matrix,
                                             readmatrix=readmatrix,interlaced=interlaced,swapuv=swapuv,bit_depth=bit_depth):
                    AVI = script.AVI
                else:
                    del script.AVI # cannot show progress dialog on freeing, but loading progress is shown.. all good
                    script.AVI = None

            if not AVI:
                try:
                    AVI = pyavs.AvsClip(
                                    scripttxt, filename, workdir=workdir,env=env,fitHeight=fitHeight,fitWidth=fitWidth,
                                    oldFramecount=oldFramecount,matrix=matrix,interlaced=interlaced,swapuv=swapuv,
                                    bit_depth=bit_depth,callBack=callBack,readmatrix=readmatrix,displayFilter=displayFilter,
                                    readFrameProps=readFrameProps,resizeFilter=resizeFilter,previewFilter=previewFilter,
                                    useSplitClip=useSplitClip, app=self)
                except:
                    q.put(AVI)
                    return

            re = rq.get(block=True, timeout=4)
            if not re: # user not canceled, main loop waiting, also return the AVI
                q.put(AVI)
                return

            clp = isinstance(AVI, pyavs.AvsClipBase)
            # check for clip and script and assign the AVI to the script, do this in the main thread (CallAfter) or AsyncCall
            try:
                if self.options['avithreadassignlater'] and clp and isinstance(script, AvsStyledTextCtrl):
                    found = False
                    for i in xrange(self.scriptNotebook.GetPageCount()):
                        if self.scriptNotebook.GetPage(i) is script:
                            found = True
                            break
                    if found:
                        while self.ClipRefreshPainter or not self.IsEnabled():
                            wx.MilliSleep(1000)
                        if AsyncCall(updateAbandonedScript, AVI, script, scripttxt, scr_filename).Wait():
                            return
            except:
                pass
            # on script or AVI error freeing the clip
            try:
                AVI = None
                if clp:
                    wx.CallAfter(self.StatusbarTimer_Start, 5000, _(u'Abandoned clip released: "{0}"').format(scr_filename), bellcount=2)
            except:
                pass
            return

        def TH_GetClip(script,scripttxt,filename,workdir,env,fitHeight,fitWidth,oldFramecount,matrix,interlaced,swapuv,
                bit_depth,callBack,readmatrix,displayFilter,readFrameProps,resizeFilter,previewFilter,useSplitClip,useFastClip):

            def GetFreeMemory():
                try:
                    mem = max(int(wx.GetFreeMemory()/1024/1024), 0)
                except:
                    mem = 0
                return mem

            AVI = None
            q = queue.Queue()
            rq = queue.LifoQueue()
            rq.put(False)
            try:
                th = threading.Thread(target=_getClip, args=(script,scripttxt,filename,workdir,env,fitHeight,fitWidth,
                                        oldFramecount,matrix,interlaced,swapuv,bit_depth,callBack,readmatrix,displayFilter,
                                        readFrameProps,resizeFilter,previewFilter,useSplitClip,useFastClip, q,rq,))
                if not isinstance(th, threading.Thread):
                    raise
                th.daemon = True
                th.name = 'clip'
                script.AviThread = th
                th.start()
            except:
                wx.MessageBox(_('Error creating the clip thread.\n'+
                        'Options->Access Avisynth in threads should be deaktivated.\n'+
                        'Then restart the program.'), style=wx.OK|wx.ICON_ERROR)
                return

            disabler = wx.WindowDisabler()
            sash = self.mainSplitter.GetSashPosition()
            progress = None
            wx.GetApp().ProcessIdle() # New

            msg = utils.resource_str_threadwait2 if self.options['avithreadassignlater'] else utils.resource_str_threadwait
            msg_mem = '\n\nAvailable memory: %i MB'
            msg_1 = msg if self.WinVersion < 7 else _('Process clip...')

            try:
                if self.ClipRefreshPainter:
                    self.videoWindow.SetDoubleBuffered(True)
                    t = 0
                    while th.isAlive() and t < self.progressDelayTime:
                        if not progress and wx.GetKeyState(wx.WXK_CONTROL):
                            progress = wx.ProgressDialog(_('Waiting for avisynth clip'), msg_1,10,self,
                                        style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                        if progress:
                            c,s = progress.Pulse()
                        t += 2
                        th.join(2)
                        if t % 4 == 0:
                            if wx.GetApp().Pending():
                                pass # The request seems to be enough
                            if wx.GetKeyState(wx.WXK_SHIFT):
                                if self.IsIconized():
                                    self.Iconize(False)
                                    self.mainSplitter.SetSashPosition(sash)
                                    try:
                                        wx.GetApp().SafeYieldFor(self.videoWindow, wx.wxEVT_PAINT)
                                    except:
                                        pass
                                else:
                                    if not progress:
                                        progress = wx.ProgressDialog(_('Waiting for avisynth clip'), msg_1,10,self,
                                            style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                                    self.Iconize(True)
                else:
                    th.join(self.progressDelayTime)

                try:
                    AVI = q.get_nowait()
                except:
                   pass # no clip returned
                # if not th.isAlive() and not clip returned then avisynth load dll error must be
                # handle the dll error later
                if AVI is None and th.isAlive():
                    i = 0
                    c = True
                    msgShown = False
                    show_mem = self.WinVersion > 6 and self.options['threaddlgshowmem']

                    if self.ClipRefreshPainter and self.options['threadprogressopt'] == 2:
                        pass
                    elif not progress:
                        progress = wx.ProgressDialog(_('Waiting for avisynth clip'),msg_1,10,self,
                                    style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL|wx.PD_AUTO_HIDE)

                    while th.isAlive():
                        if not progress and i % 2 == 0 and wx.GetKeyState(wx.WXK_CONTROL):
                            progress = wx.ProgressDialog(_('Waiting for avisynth clip'),msg_1,10,self,
                                        style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                        if progress:
                            c,s = progress.Pulse()
                            if not c:
                                if i > 10: break
                                elif not msgShown:
                                    msgShown = True
                                    progress.Pulse(msg)
                            elif i > 9 and i % 5 == 0:
                                if show_mem:
                                    progress.Pulse(msg + (msg_mem % GetFreeMemory()))
                                elif not msgShown:
                                    msgShown = True
                                    progress.Pulse(msg)
                        i += 1
                        if self.ClipRefreshPainter and i % 5 == 0:
                            if wx.GetApp().Pending():
                                pass # The request seems to be enough
                            if wx.GetKeyState(wx.WXK_SHIFT):
                                if self.IsIconized():
                                    self.Iconize(False)
                                    self.mainSplitter.SetSashPosition(sash)
                                    try:
                                        wx.GetApp().SafeYieldFor(self.videoWindow, wx.wxEVT_PAINT)
                                    except:
                                        pass
                                else:
                                    if not progress:
                                        progress = wx.ProgressDialog(_('Waiting for avisynth clip'),msg_1,10,self,
                                            style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                                    self.Iconize(True)
                        th.join(0.5)
                    ### end loop

                    if c and progress and self.WinVersion > 6:
                        progress.Pulse(_('Clip process finished'))

                    try:
                        AVI = q.get_nowait()
                    except:
                        pass

                    if th.isAlive():
                        rq.put(True) # flag for thread (release or assign later the clip)
                        self.Thread_List.append((th,q))
            finally:
                del disabler # must be at first
                """
                if self.ClipRefreshPainter:
                    if wx.GetApp().Pending():
                        try:
                            wx.GetApp().SafeYieldFor(self,  wx.wxEVT_TIMER)
                        except:
                           pass
                """
                self.progressShown = progress is not None # needed for frame thread if ClipRefreshPainter

                if progress:
                    progress.Destroy()
                self.videoWindow.SetDoubleBuffered(False)

                if not th.isAlive():
                    script.AviThread = None
                if not AVI or (AVI and AVI.IsErrorClip()):
                    self.GetStatusBar().SetStatusText(_('Clip not initialized'))
                return AVI

        def checkMatrix(script, setScriptMatrix):
            if self.options['readmatrix']:
                if setScriptMatrix and script.AVI and not script.AVI.IsErrorClip() and script.AVI.matrix_found:
                    script.matrix = script.AVI.matrix_found[:]
                #return # Display anyway the matrix? disabled for now
                if script == self.currentScript:
                    if script.matrix[0] != lastmatrix[0] or script.matrix[1] != lastmatrix[1]:
                        if script.matrix[0] == 'auto':
                            s1 = _('Resolution-based')
                        else: s1 = _('BT.' + script.matrix[0])
                        s2 = _(script.matrix[1].upper() + ' levels')
                        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), s1])
                        self.UpdateMenuItem(_('Display'), True, 'video', [_('YUV -> RGB'), s2])

        def mustReadMatrix(script):
            readmatrix = self.options['readmatrix']
            if readmatrix:
                matrix = self.MatrixFromScript(script)
                if matrix:
                    script.matrix = matrix
                    readmatrix = False # force the writen matrix in the script
            return readmatrix

        def autoTakeSnapshot(script):
            self.snapShotIdx = 0
            bmp = wx.EmptyBitmap(script.AVI.DisplayWidth, script.AVI.DisplayHeight)
            dc = wx.MemoryDC()
            dc.SelectObject(bmp)
            nr = script.AVI.current_frame
            if script.AVI.DrawFrame(nr, dc):
                script.snapShots['shot2'][1] = None # free bmp
                script.snapShots['shot2'] = [nr, bmp, script.lastText, script.previewFilterIdx]
            else:
                 bmp = None
                 script.snapShots['shot2'] = utils.emptySnapShot

        def getDisplayFilter():
            if self.displayFilter:
                displayFilter = ''
                for line in self.options['displayfilter'].split('\n'):
                    if line and not line.lstrip().startswith('#'):
                        displayFilter += line
                return displayFilter.strip()
            return None

        ##### Func start ( UpdateScriptAvi )
        try:
            if not script:
                script = self.currentScript
                index = self.scriptNotebook.GetSelection()
            else:
                index = 0
                for index in xrange(self.scriptNotebook.GetPageCount()):
                    if script == self.scriptNotebook.GetPage(index):
                        break

            if script.AVI is None: # or script.AVI.IsErrorClip():
                forceRefresh = True

            boolNewAVI = newRefreshed = False
            if forceRefresh or ((self.refreshAVI or script.refreshAVI) and self.options['refreshpreview']):
                if not script.previewtxt:
                    script.Colourise(0, script.GetTextLength())
                self.ClipRefreshPainter = False
                if forceRefresh or self.ScriptChanged(script):
                    # Backup the current session if paranoia mode is on
                    if self.options['paranoiamode']:
                        self.SaveSession(self.lastSessionFilename, saverecentdir=False, previewvisible=False)
                    if self.playing_video:
                        self.PlayPauseVideo(refreshFrame=False)
                        self.playing_video = ''
                    if self.readFrameProps:
                        self.AVICallBack('property','', -1)
                    if self.AviThread_Running(script):
                        return None
                    if showCursor and not wx.IsBusy():
                        wx.BeginBusyCursor()
                    script.AviThread = None
                    script.display_clip_refresh_needed = False
                    scripttxt = script.GetText()
                    sDirname = os.path.dirname(script.filename)
                    sBasename = self.scriptNotebook.GetPageText(index)
                    filename = os.path.join(sDirname, sBasename)
                    lastmatrix = script.matrix[:] # store for checkMatrix
                    previewFilter = None
                    previewFilterIdx = script.previewFilterIdx
                    if script.AVI is None:
                        oldFramecount = 240
                        boolOldAVI = False
                        env = None
                        script.lastSplitVideoPos = None
                        self.bmpVideo = None
                    else:
                        # auto snapshot
                        if self.options['autosnapshot']:
                            if not script.AVI.IsErrorClip() and script.AVI.current_frame > -1:
                                autoTakeSnapshot(script)
                            script.flagModified = False # tell the script save last text before text changes

                        ############### new preview filter
                        if previewFilterIdx > 0:
                            self.ParseScriptPreviewFilters()
                            if previewFilterIdx in self.previewFilterDict.keys():
                                previewFilter = self.previewFilterDict[previewFilterIdx][1]
                        if not previewFilter and previewFilterIdx > 0:
                            self.SetPreviewFilterMenus()
                        ##############

                        oldFramecount = script.AVI.Framecount
                        oldWidth, oldHeight = script.AVI.Width, script.AVI.Height
                        boolOldAVI = True
                        newRefreshed = True
                        env = script.AVI.env if keep_env else None

                    workdir_exp = self.ExpandVars(self.options['workdir'])
                    if (self.options['useworkdir'] and self.options['alwaysworkdir']
                        and os.path.isdir(workdir_exp)):
                            workdir = workdir_exp
                    else:
                        workdir = script.workdir
                    # vpy hack, remove when VapourSynth is supported
                    if os.name == 'nt' and filename.endswith('.vpy'):
                        self.SaveScript(filename)

                    #if showCursor and not wx.IsBusy():
                        #wx.BeginBusyCursor()

                    self.ClipRefreshPainter = self.GetVideoWindowBitmap()
                    useFastClip = self.options['usefastclip'] and script.AVI is not None and not disableFastClip and not script.disableFastClipOnce

                    # freeing the AVI
                    if not useFastClip:
                        if not self.AviFree(script):
                            if showCursor and wx.IsBusy():
                                wx.EndBusyCursor()
                            return None

                    # returns true if MatrixFromScript not found and options read matrix set
                    readmatrix = mustReadMatrix(script)
                    if readmatrix and self.options['resetmatrix']:
                        script.matrix = list(self.options['selectedmatrix'])

                    # get values
                    displayFilter = getDisplayFilter()
                    resizeFilter = self.GetResizeFilterInfo(script) if not resizeFilterInfo else resizeFilterInfo
                    useSplitClip = self.SplitClipCtrl.IsActive and boolOldAVI and self.options['usesplitclip']
                    script.disableFastClipOnce = False # reset fast clip

                    if script == self.currentScript:
                        self.GetStatusBar().SetStatusText(_('Initialize clip. %s') % (self.ShowFreeMemory(returnStr=True)))

                    if self.UseAviThread:
                        script.AVI = TH_GetClip(script, self.getCleanText(scripttxt), filename,
                            workdir=workdir, env=env, fitHeight=None, fitWidth=None,
                            oldFramecount=oldFramecount, matrix=script.matrix, interlaced=self.interlaced,
                            swapuv=self.swapuv, bit_depth=self.bit_depth, callBack=self.AVICallBack,
                            readmatrix=readmatrix, displayFilter=displayFilter, readFrameProps=self.readFrameProps,
                            resizeFilter=resizeFilter, previewFilter=previewFilter, useSplitClip=useSplitClip,
                            useFastClip=useFastClip)
                        if script.AVI is None:
                            if self.customHandler > 0:
                                self.PostMessage(self.customHandler, self.AVSP_VID_SIZE, 0, 0)
                            return None
                    else:
                        if useFastClip:
                            if not script.AVI.CreateFastClip(script,useSplitClip=useSplitClip,previewFilter=previewFilter,matrix=script.matrix,
                                                            readmatrix=readmatrix,interlaced=self.interlaced,swapuv=self.swapuv,bit_depth=self.bit_depth):
                                if not self.AviFree(script):
                                    if showCursor and wx.IsBusy():
                                        wx.EndBusyCursor()
                                    return None

                        if script.AVI is None:
                            script.AVI = pyavs.AvsClip(
                                self.getCleanText(scripttxt), filename, workdir=workdir, env=env,
                                fitHeight=None, fitWidth=None, oldFramecount=oldFramecount,
                                matrix=script.matrix, interlaced=self.interlaced, swapuv=self.swapuv,
                                bit_depth=self.bit_depth,callBack=self.AVICallBack,
                                readmatrix=readmatrix, displayFilter=displayFilter, readFrameProps=self.readFrameProps,
                                resizeFilter=resizeFilter, previewFilter=previewFilter, useSplitClip=useSplitClip)
                        if not script.AVI or script.AVI.IsErrorClip():
                            self.GetStatusBar().SetStatusText(_('Clip not initialized'))

                    if not script.AVI or not script.AVI.initialized:
                        if self.customHandler > 0:
                            self.PostMessage(self.customHandler, self.AVSP_VID_SIZE, 0, 0)
                        if prompt:
                            if wx.IsBusy():
                                wx.EndBusyCursor()
                            self.HidePreviewWindow()
                            s1 = _('Error loading AviSynth!')
                            if script.AVI.error_message:
                                s2 = script.AVI.error_message
                            else:
                                s2 = _(
                                    'Make sure you have AviSynth installed and that there are no '
                                    'unstable plugins or avsi files in the AviSynth plugins directory.'
                                )
                            wx.MessageBox('%s\n\n%s' % (s1, s2), _('Error'), style=wx.OK|wx.ICON_ERROR)
                        if isinstance(script.AVI,  pyavs.AvsClipBase):
                            self.AviFree(script)
                        else: script.AVI = None
                        return None

                    boolNewAVI = True
                    checkMatrix(script, True)
                    # Update the script tag properties
                    self.UpdateScriptTagProperties(script, scripttxt)
                    self.GetAutoSliderInfo(script, scripttxt)
                    script.previewtxt = self.ScriptChanged(script, return_styledtext=True)[1]

                    if previewFilterIdx > 0:
                        if script.AVI.preview_filter:
                            self.SetPreviewFilterMenus(previewFilterIdx)
                        else:
                            self.SetPreviewFilterMenus()

                # end new AVi
                if script == self.currentScript:
                    self.refreshAVI = False
                script.refreshAVI = False

            # end refresh Avi
            if script.display_clip_refresh_needed and not boolNewAVI:
                script.display_clip_refresh_needed = False
                boolOldAVI = True
                if showCursor and not wx.IsBusy():
                    wx.BeginBusyCursor()
                # display filter
                script.AVI.displayFilter = getDisplayFilter()
                # resizeFilter
                resizeFilter = self.GetResizeFilterInfo(script) if not resizeFilterInfo else resizeFilterInfo
                script.AVI.SetResizeFilter(resizeFilter)
                lastmatrix = script.matrix[:] # store for checkMatrix, if boolNewAVI the matrix has stored there
                # normaly without risk, but resizeFilter and displayFilter can get problems so we run it now threaded
                if self.UseAviThread:
                    ok = TH_CreateDisplayClip(script, False, killFilterClip=False)
                else:
                    ok = script.AVI.CreateDisplayClip(matrix=script.matrix, interlaced=self.interlaced,
                                                      swapuv=self.swapuv, bit_depth=self.bit_depth,
                                                      readmatrix=False, killFilterClip=False, killSplitClip=False)
                if ok:
                    boolNewAVI = True
                    checkMatrix(script, False)
                else:
                    return None
        finally:
            if showCursor and wx.IsBusy():
               wx.EndBusyCursor()

        if boolNewAVI:
            # SplitClipCtrl
            if not script.AVI.IsErrorClip():
                if self.SplitClipCtrl.IsActive and not script.AVI.IsSplitClip:
                    self.SplitClipCtrl.Close()
                elif script.AVI.IsSplitClip and not self.SplitClipCtrl.IsActive:
                    self.SplitClipCtrl.Activate()
            # Error
            if script.AVI.IsErrorClip():
                script.lastSplitVideoPos = None
                self.playing_video = False
                if self.cropDialog.IsShown():
                    self.cropDialog.Hide()
                if self.SplitClipCtrl.IsActive:
                    self.SplitClipCtrl.Close()
                self.OnMenuVideoZoom(zoomfactor=1,show=False,resizeFilterOff=True,single=True,script=script)
            elif newRefreshed and not self.zoomwindow \
                and not (script.resizeFilter[0] and script.resizeFilter[2] == 1) \
                and ((oldWidth, oldHeight) != (script.AVI.Width, script.AVI.Height)):
                #and self.options['resizevideowindow')
                script.lastSplitVideoPos = None

            script.autocrop_values = None
            if self.cropDialog.IsShown():
                if self.resizeFilter[0]:
                    self.cropDialog.Hide()
                else:
                    self.PaintCropWarnings()
            self.SetVideoStatusText()
            if self.playing_video == '':
                wx.CallAfter(self.PlayPauseVideo)

        return boolNewAVI

    def ScriptChanged(self, script=None, return_styledtext=False):
        """Compare scripts including style, but excluding comment/newline/space"""
        if script is None:
            script = self.currentScript

        scripttxt = script.GetStyledText(0, script.GetTextLength())
        styledtxt = []
        pFilter = False
        spClip = False

        for i in range(0, len(scripttxt), 2):
            style = ord(scripttxt[i+1]) & 31

            if pFilter:
                if style == script.STC_AVS_PREVIEWFILTER_END:
                    pFilter = False
                continue

            if spClip:
                if style == script.STC_AVS_PREVIEWFILTER_END:
                    spClip = False
                    continue
                if (style == script.STC_AVS_DEFAULT and scripttxt[i] in ' \t'): # no \n else on wrong written no changes can be found
                    continue
                styledtxt.append(style) # reverse append, otherwise it is not possible to distinguish whether a script filter or split clip filter has been changed
                styledtxt.append(scripttxt[i])
                continue

            if style in script.commentStyle_2 or (style == script.STC_AVS_DEFAULT and scripttxt[i] in ' \t\n'):
                if style == script.STC_AVS_PREVIEWFILTER:
                    pFilter = True
                elif style == script.STC_AVS_SPLITCLIP:
                    spClip = True
                continue

            styledtxt.append(scripttxt[i])
            styledtxt.append(style)
        script_changed = styledtxt != script.previewtxt
        if return_styledtext:
            return script_changed, styledtxt
        return script_changed

    #####################
    #### User sliders
    #####################

    def UpdateScriptTagProperties(self, script, scripttxt=None):
        if script.AVI.IsErrorClip():
            script.toggleTags = []
            script.sliderProperties = []
            script.sliderTexts = []
            return
        if scripttxt is None:
            scripttxt = script.GetText()
        # First strip out comments from scripttxt
        #if not self.options['savetoggletags']:
            #~scripttxt = re.sub(r'#.*?\n', r'\n', '%s\n' % scripttxt) # original
        scripttxt = re.sub(r'#(?!>).*?\n', r'\n', '%s\n' % scripttxt) # GPo, exclude comment if # followed by >  (#>)
        # Get the toggle tag info
        script.toggleTags = self.GetScriptToggleTagProperties(scripttxt, stripComments=False)
        # Get the slider info
        script.sliderTexts, script.sliderProperties = self.GetScriptSliderProperties(scripttxt, stripComments=False)

    def OnToggleTagChecked(self, event):
        script = self.currentScript
        label = event.GetEventObject().GetName()
        value = 1 if event.IsChecked() else 0
        # Update the script
        newText = re.sub(r'\[%s(\s*=.*?)*?\]' % label, '[%s=%i]' % (label, value), script.GetText())

        ## GPo new, check if check-radio
        label = label.split('>')
        if len(label) == 2:
            for item in script.toggleTagSizer.GetChildren():
                checkbox = item.GetWindow()
                if isinstance(checkbox, wx.CheckBox):
                    if checkbox.GetName() == label[1]:
                        if int(checkbox.GetValue()) == value:
                            checkbox.SetValue(not value)
                            newText = re.sub(r'\[%s(\s*=.*?)*?\]' % label[1], '[%s=%i]' % (label[1], int(not value)), newText)
                        break
        ##
        script.Freeze()
        pos = script.GetCurrentPos()
        script.SetText(newText)
        script.GotoPos(pos)
        self.TryThaw(script)
        script.Colourise(0, script.GetTextLength()) # GPo, need new update for scriptChanged
        # Update the video
        # GPo 2021, if tag in preview filter and preview filter is off then no update required
        scriptChanged = self.ScriptChanged(script)
        if script.previewFilterIdx > 0 or scriptChanged:
            self.SliderShowVideoFrame(userScrolling=not scriptChanged, selfrefreshAVI=scriptChanged, script=script, scriptChanged=scriptChanged)

    def OnScrollUserSlider(self, event):
        pass

    def OnLeftUpUserSlider(self, event):
        slider = event.GetEventObject()
        self.UserSliderVideoUpdate(slider)
        event.Skip()

    def UserSliderVideoUpdate(self, slider):
        script = self.currentScript
        label = slider.GetName()
        sOpen = self.sliderOpenString
        sClose = self.sliderCloseString
        sliderText = None
        selfrefreshAVI = False
        for text in self.regexp.findall(script.GetText()):
            if label == text.lstrip(sOpen).rstrip(sClose).split(',')[0].strip('"').strip("'"):
                sliderText = text
                break
        if sliderText:
            pos = script.FindText(0, script.GetTextLength(), sliderText)
            script.SetTargetStart(pos)
            posEnd = script.FindText(pos, script.GetTextLength(), '>]') + 2
            script.SetTargetEnd(posEnd)
            newVal = slider.GetValue()
            items = [s.strip() for s in sliderText.strip('[]').split(',')]
            if len(items) == 4:
                newSliderText = '%s"%s", %s, %s, %s%s' % (sOpen, label, items[1], items[2], newVal, sClose)
                script.ReplaceTarget(newSliderText)
                script.Colourise(pos, pos+len(newSliderText)+1) # needed for ScriptChanged
                selfrefreshAVI = True
        self.SliderShowVideoFrame(userScrolling=True, selfrefreshAVI=selfrefreshAVI , script=script)

    def SliderShowVideoFrame(self, userScrolling, selfrefreshAVI, script, scriptChanged=None):
        if self.playing_video:
            self.PlayPauseVideo(refreshFrame=True)

        if scriptChanged is None:
            scriptChanged = self.ScriptChanged(script)

        if not scriptChanged:
            if script.previewFilterIdx > 0:
                self.OnMenuPreviewFilter(None, script.previewFilterIdx, updateUserSliders=False)
        else:
            if not script.chkDisableRefresh.IsChecked():
                keep_env = script.previewFilterIdx == 0
                self.refreshAVI = selfrefreshAVI
                self.ShowVideoFrame(forceRefresh=True, userScrolling=userScrolling, keep_env=keep_env, forceCursor=True)
            else:
                self.refreshAVI = True
                script.refreshAVI = True
                #if script.previewFilterIdx > 0:
                    #self.KillFilterClip()
        """
        if script.previewFilterIdx > 0 and not scriptChanged:
            self.OnMenuPreviewFilter(None, script.previewFilterIdx, updateUserSliders=False)
        elif not script.chkDisableRefresh.IsChecked():
            if not selfrefreshAVI or selfrefreshAVI is None:
                selfrefreshAVI = False
            keep_env = not scriptChanged
            self.refreshAVI = selfrefreshAVI
            self.ShowVideoFrame(userScrolling=userScrolling, keep_env=keep_env, forceCursor=scriptChanged)
        else:
            self.refreshAVI = True
        """

    def createUserSliders(self, script, parseonly=False):
        sliderTexts = script.sliderTexts
        # Parse the slider texts
        labels = []
        argsList = []
        for text in sliderTexts:
            items = [s.strip() for s in text.lstrip(self.sliderOpenString).rstrip(self.sliderCloseString).split(',')]
            if len(items) != 4:
                if len(items) == 1:
                    splititem = items[0].split('=',1)
                    if len(splititem) == 2:
                        argsList.append([splititem[1].strip('"')])
                    else:
                        argsList.append([''])
                continue
            minValue = maxValue = value = None
            try:
                # Store the items
                label = items[0].strip(''' "' ''')#strip('"').strip("'")
                minValue = float(items[1])
                maxValue = float(items[2])
                value = float(items[3])
                if minValue >= maxValue:
                    self.displaySliderWarning(script, text, items[1], _('Invalid slider text: min > max'))
                    return False
                if value < minValue or value > maxValue:
                    self.displaySliderWarning(script, text, items[3], _('Invalid slider text: value not in bounds'))
                    return False
                # Get the number of decimals (to determine slider increments)
                nDecimal = 0
                items = [s.strip() for s in text.lstrip(self.sliderOpenString).rstrip(self.sliderCloseString).split(',')]
                for strnum in items[1:]:
                    strsplit = strnum.split('.')
                    if len(strsplit) == 2:
                        n = len(strsplit[1])
                    else:
                        n = 0
                    if n > nDecimal:
                        nDecimal = n
                # Get the modulo (slider step size)
                mod = None
                splitlabel = label.split('%', 1)
                if len(splitlabel) == 2:
                    try:
                        mod = int(splitlabel[1])
                    except ValueError:
                        self.displaySliderWarning(script, text, splitlabel[1].strip(), _('Invalid slider text: bad modulo label'))
                        return False
                if mod is not None:
                    if mod == 0:
                        mod = None
                    else:
                        invalidNumber = False
                        if (int(value) - int(minValue)) % mod != 0 or (int(maxValue) - int(minValue)) % mod != 0:
                            invalidNumber = True
                        if invalidNumber or mod > maxValue - minValue:
                            mod = None
                    if mod is not None:
                        nDecimal = 0
                        minValue = int(minValue) #tempMinValue
                        maxValue = int(maxValue) #tempMaxValue
                        value = int(value) #min(value + value % mod, maxValue)
                if label not in labels:
                    argsList.append((script, label, minValue, maxValue, value, nDecimal, mod))
                    labels.append(label)
                else:
                    self.displaySliderWarning(script, text, label, _('Invalid slider text: slider label already exists'))
                    return False
            except ValueError:
                if minValue is None:
                    highlightText = items[1]
                elif maxValue is None:
                    highlightText = items[2]
                elif value is None:
                    highlightText = items[3]
                else:
                    highlightText = items[0]
                self.displaySliderWarning(script, text, highlightText, _('Invalid slider text: invalid number'))
                return False
        if parseonly:
            parsedInfo = [arg[1:] for arg in argsList]
            return zip(sliderTexts, parsedInfo)
        # Create the new sliders
        script.sliderSizer.Clear(deleteWindows=True)
        for row, args in enumerate(argsList):
            if len(args) == 1:
                self.addAvsSliderSeparator(script, label=args[0], row=row)
            else:
                args = args + (row,)
                self.addAvsSlider(*args)
        if wx.VERSION > (2, 9):
            script.sliderSizer.Add((0, 0), (len(argsList), 3))
            if not script.sliderSizer.IsColGrowable(3):
                script.sliderSizer.AddGrowableCol(3)
        return True

    def displaySliderWarning(self, script, sliderText, highlightText, msg):
        pos = script.FindText(0, script.GetTextLength(), sliderText)
        posA = script.FindText(pos, script.GetTextLength(), highlightText, stc.STC_FIND_WHOLEWORD)
        posB = posA + len(highlightText)
        script.SetSelection(posA, posB)
        script.SetFocus()
        wx.MessageBox(msg, _('Warning'))

    def addAvsSlider(self, script, labelTxt, minValue, maxValue, value, nDecimal, mod=None, row=None, sizer=None):
        if minValue is None or maxValue is None or value is None or nDecimal is None:
            return
        if sizer is None:
            sizer = script.sliderSizer
        parent = script.sliderWindow
        isRescaled = False
        if not mod:
            if labelTxt[-1] == '+':
                minValue2 = 0
                mod = (maxValue - minValue) / 100.
                isRescaled = True
            elif labelTxt[-1] == '-':
                minValue2 = -100
                mod = (maxValue - minValue) / 200.
                isRescaled = True
        if isRescaled:
            def Rescale(val):
                return minValue2 + (val - minValue)/mod
        # Construct the format string based on nDecimal
        strTemplate = '%.'+str(nDecimal)+'f'
        strTemplate2 = '(%.'+str(nDecimal)+'f)'
        def OnScroll(event):
            value = slider.GetValue()
            valTxtCtrl.SetLabel(strTemplate % value)
            if isRescaled:
                valTxtCtrl2.SetLabel(strTemplate2 % Rescale(value))
        # Create the slider
        slider = wxp.Slider(parent, wx.ID_ANY,
            value, minValue, maxValue,
            size=(intPPI(50),-1),
            style=wx.SL_BOTH,
            name=labelTxt,
            nDecimal=nDecimal,
            mod=mod,
            #~ onscroll= lambda event: valTxtCtrl.SetLabel(strTemplate % slider.GetValue())
            onscroll = OnScroll,
        )
        # Slider event binding
        slider.Bind(wx.EVT_LEFT_UP, self.OnLeftUpUserSlider)
        # Create the static text labels
        labelTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, labelTxt)
        minTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, strTemplate % minValue)
        maxTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, strTemplate % maxValue)
        valTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, strTemplate % value)
        font = valTxtCtrl.GetFont()
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        valTxtCtrl.SetFont(font)
        if self.currentSliderWindow.customTheme:
            valTxtCtrl.SetForegroundColour(self.currentSliderWindow.foreDefValue)
            slider.SetBackgroundColour(self.currentSliderWindow.backSlider)
        else:
            valTxtCtrl.SetForegroundColour(wx.BLUE)
        valTxtCtrl.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        value_formatted = strTemplate % value
        valTxtCtrl.SetToolTip(wx.ToolTip(_('Reset to initial value: %(value_formatted)s') % locals()))
        if isRescaled:
            minTxtCtrl2 = wxp.StaticText(parent, wx.ID_ANY, strTemplate2 % minValue2)
            minTxtCtrlSizer = wx.BoxSizer(wx.VERTICAL)
            minTxtCtrlSizer.Add(minTxtCtrl, 0, wx.ALIGN_CENTER)
            minTxtCtrlSizer.Add(minTxtCtrl2, 0, wx.ALIGN_CENTER)
            maxTxtCtrl2 = wxp.StaticText(parent, wx.ID_ANY, strTemplate2 % Rescale(maxValue))
            maxTxtCtrlSizer = wx.BoxSizer(wx.VERTICAL)
            maxTxtCtrlSizer.Add(maxTxtCtrl, 0, wx.ALIGN_CENTER)
            maxTxtCtrlSizer.Add(maxTxtCtrl2, 0, wx.ALIGN_CENTER)
            value2_formatted = strTemplate2 % Rescale(value)
            valTxtCtrl2 = wxp.StaticText(parent, wx.ID_ANY, value2_formatted)
            valTxtCtrlSizer = wx.BoxSizer(wx.VERTICAL)
            valTxtCtrlSizer.Add(valTxtCtrl, 0, wx.EXPAND)
            valTxtCtrlSizer.Add(valTxtCtrl2, 0, wx.EXPAND)
            valTxtCtrl2.SetForegroundColour(wx.RED)
            valTxtCtrl2.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
            valTxtCtrl2.SetToolTip(wx.ToolTip(_('Reset to initial value: %(value2_formatted)s') % locals()))
        def OnTextLeftDown(event):
            valTxtCtrl.SetLabel(value_formatted)
            if isRescaled:
                valTxtCtrl2.SetLabel(value2_formatted)
            slider.SetValue(value)
            self.UserSliderVideoUpdate(slider)
        valTxtCtrl.Bind(wx.EVT_LEFT_DOWN, OnTextLeftDown)
        if isRescaled:
            valTxtCtrl2.Bind(wx.EVT_LEFT_DOWN, OnTextLeftDown)
        leftCtrl = wxButtons.GenBitmapButton(parent, wx.ID_ANY, self.bmpLeftTriangle, size=tuplePPI(16,16))
        leftCtrl.SetBezelWidth(1)
        leftCtrl.SetUseFocusIndicator(False)
        def OnLeftTimer(event):
            if leftCtrl.up:
                leftTimer.Stop()
                if leftCtrl.HasCapture():
                    leftCtrl.ReleaseMouse()
                self.UserSliderVideoUpdate(slider)
            else:
                newvalue = slider.Decrement()
                valTxtCtrl.SetLabel(strTemplate % newvalue)
                if isRescaled:
                    valTxtCtrl2.SetLabel(strTemplate2 % Rescale(newvalue))
            if event:
                event.Skip()
        leftTimer = wx.Timer(leftCtrl)
        leftCtrl.Bind(wx.EVT_TIMER, OnLeftTimer)
        def OnButtonDecLeftDown(event):
            newvalue = slider.Decrement()
            valTxtCtrl.SetLabel(strTemplate % newvalue)
            if isRescaled:
                valTxtCtrl2.SetLabel(strTemplate2 % Rescale(newvalue))
            if wx.GetKeyState(wx.WXK_CONTROL):
                self.fc = wx.CallLater(400, leftTimer.Start, 500)
            else:
                self.fc = wx.CallLater(300, leftTimer.Start, 100)
            event.Skip()
        def OnButtonDecLeftUp(event):
            if self.fc is not None:
                self.fc.Stop()
            leftTimer.Stop()
            wx.CallAfter(OnLeftTimer, None)
            event.Skip()
        leftCtrl.Bind(wx.EVT_LEFT_DOWN, OnButtonDecLeftDown)
        leftCtrl.Bind(wx.EVT_LEFT_UP, OnButtonDecLeftUp)
        leftCtrl.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)
        rightCtrl = wxButtons.GenBitmapButton(parent, wx.ID_ANY, self.bmpRightTriangle, size=tuplePPI(16,16))
        rightCtrl.SetBezelWidth(1)
        rightCtrl.SetUseFocusIndicator(False)
        def OnRightTimer(event):
            if rightCtrl.up:
                rightTimer.Stop()
                if rightCtrl.HasCapture():
                    rightCtrl.ReleaseMouse()
                self.UserSliderVideoUpdate(slider)
            else:
                newvalue = slider.Increment()
                valTxtCtrl.SetLabel(strTemplate % newvalue)
                if isRescaled:
                    valTxtCtrl2.SetLabel(strTemplate2 % Rescale(newvalue))
            if event:
                event.Skip()
        rightTimer = wx.Timer(rightCtrl)
        rightCtrl.Bind(wx.EVT_TIMER, OnRightTimer)
        def OnButtonIncLeftDown(event):
            newvalue = slider.Increment()
            valTxtCtrl.SetLabel(strTemplate % newvalue)
            if isRescaled:
                valTxtCtrl2.SetLabel(strTemplate2 % Rescale(newvalue))
            if wx.GetKeyState(wx.WXK_CONTROL):
                self.fc = wx.CallLater(400, rightTimer.Start, 500)
            else:
                self.fc = wx.CallLater(300, rightTimer.Start, 100)
            event.Skip()
        def OnButtonIncLeftUp(event):
            if self.fc is not None:
                self.fc.Stop()
            rightTimer.Stop()
            wx.CallAfter(OnRightTimer, None)
            event.Skip()
        rightCtrl.Bind(wx.EVT_LEFT_DOWN, OnButtonIncLeftDown)
        rightCtrl.Bind(wx.EVT_LEFT_UP, OnButtonIncLeftUp)
        rightCtrl.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)
        # Add the elements to the sliderSizer
        sizer.Add(labelTxtCtrl, (row,0), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, intPPI(10))
        if isRescaled:
            sizer.Add(minTxtCtrlSizer, (row,1), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.ALIGN_RIGHT)
        else:
            sizer.Add(minTxtCtrl, (row,1), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.ALIGN_RIGHT)
        sizer.Add(leftCtrl, (row,2), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, intPPI(5))
        sizer.Add(slider, (row,3), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.EXPAND)
        sizer.Add(rightCtrl, (row,4), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, intPPI(5))
        if isRescaled:
            sizer.Add(maxTxtCtrlSizer, (row,5), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, intPPI(10))
            sizer.Add(valTxtCtrlSizer, (row,6), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, intPPI(4))
        else:
            sizer.Add(maxTxtCtrl, (row,5), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, intPPI(10))
            sizer.Add(valTxtCtrl, (row,6), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, intPPI(4))

    def addAvsSliderSeparator(self, script, label='', row=None, sizer=None):
        if sizer is None:
            sizer = script.sliderSizer
        parent = script.sliderWindow
        # Add a separator
        tempsizer = wx.BoxSizer(wx.VERTICAL)
        if row == 0: border = 0
        else: border = intPPI(10)
        if label == '':
            tempsizer.Add(wx.StaticLine(parent), 0, wx.EXPAND|wx.ALIGN_BOTTOM|wx.TOP, border)
        else:
            staticText = wxp.StaticText(parent, wx.ID_ANY, label)
            font = staticText.GetFont()
            font.SetWeight(wx.FONTWEIGHT_BOLD)
            staticText.SetFont(font)
            tempsizer.Add(staticText, 0, wx.ALIGN_BOTTOM|wx.TOP, border)
            tempsizer.Add(wx.StaticLine(parent), 0, wx.EXPAND|wx.ALIGN_BOTTOM)
        sizer.Add(tempsizer, (row,0), (1,7), wx.EXPAND)

    def ValidateAvsSliderInputs(self, strDef, strMin, strMax, strMod):
        # Returns (error type, error message)
        # Error types: None: good / 0: bad default / 1: bad min / 2: bad max / 3: bad mod / -1: non-number
        errortype = errormessage = None
        if strDef.startswith('$'):
            try:
                hexstring = strDef.split('$', 1)[1]
                int(hexstring, 16)
                return (None, None, [hexstring])
            except ValueError:
                return (0, _('Invalid hexadecimal color!'), None)
        if strMin and not strMax:
            return (2, _('Must specify a max value!'), None)
        if strMax and not strMin:
            return (1, _('Must specify a min value!'), None)
        try:
            minValue = float(strMin)
        except ValueError:
            minValue = 0
            errortype = 1
            errormessage = _('Min value must be a number!')
        try:
            maxValue = float(strMax)
        except ValueError:
            maxValue = 1
            errortype = 2
            errormessage = _('Max value must be a number!')
        if not strDef:
            defValue = minValue
        else:
            try:
                defValue = float(strDef)
            except ValueError:
                errortype = 0
                errormessage = _('Default value must be a number!')
        if not strMod:
            modValue = None
        else:
            try:
                modValue = int(float(strMod))
            except ValueError:
                errortype = 3
                errormessage = _('Step size value must be a number!')
        if errormessage is not None:
            return (-1, errormessage, (strDef, strMin, strMax, strMod))
        if minValue >= maxValue:
            return (1, _('The min value must be less than the max!'), None)
        if defValue < minValue or defValue > maxValue:
            return (0,  _('The initial value must be between the min and the max!'), None)
        if modValue is not None and modValue >= 1:
            mod = modValue
            if int(minValue) % mod != 0:
                return (1, _('The min value must be a multiple of %(mod)s!') % locals(), None)
            if int(maxValue) % mod != 0:
                return (2, _('The max value must be a multiple of %(mod)s!') % locals(), None)
            if int(defValue) % mod != 0:
                return (0, _('The initial value must be a multiple of %(mod)s!') % locals(), None)
            if mod > (maxValue - minValue):
                return (0, _('The difference between the min and max must be greater than %(mod)s!') % locals(), None)
        return (None, None, (defValue, minValue, maxValue, modValue))


    ###################
    #### auto sliders
    ###################

    # also saved on ToggleSliderFold
    def SliderSaveCurrentFolds(self):
        script = self.currentScript
        if not script.sliderToggleLabels:
            return
        for item in script.sliderToggleLabels:
            label = item.GetLabel().strip(' -+')
            script.SliderFoldsBackup[label] = int(item.IsControlsVisible)

    def SliderRestoreFolds(self):
        script = self.currentScript
        i = -1
        count = len(script.sliderToggleLabels)-1
        for x, item in enumerate(script.sliderToggleLabels):
            label = item.GetLabel().strip(' -+')
            if label in script.SliderFoldsBackup:
                state = bool(script.SliderFoldsBackup[label])
                if state: # count the refreshes and do not refresh if count > 10 (refresh is slow, but restores without flicker)
                    i += 1
                #~self.ToggleSliderFold(item, fold=not state, refresh=(state and i < 11) or (x == count), scroll=False) # refresh on last item reduce flicker. Strange.
                # GPo new
                self.ToggleSliderFold(item, fold=not state, refresh=False, scroll=False) # Win10 no refresh needed, Win7 ?
            else:
                self.ToggleSliderFold(item, fold=True, refresh=False, scroll=False)

    def createAutoUserSliders(self, script):
        """
        def OnSetPFilterTime(event):
            self.ShowPFilterTime = event.IsChecked()
            if not self.ShowPFilterTime and self.currentScript.previewFilterIdx > 0:
                self.currentSliderWindow.Refresh()
        """
        script.sliderWindow.Freeze()
        try:
            script.sliderSizerNew.Clear(deleteWindows=True)
            script.sliderToggleLabels = []
            if not self.SlidersContextMenu: # GPo, save time
                menuInfoGeneral = []
                if not self.options['sliderhidetagmenu']:
                    menuInfoGeneral = [
                        (_('Add toggle tag'), '', self.OnSliderAddToggleTag, ''),
                        (_('Clear all tags and disable the filters'), '', self.OnMenuEditClearToggleTags2, ''),
                        (_('Clear all tags && disabled filters'), '', self.OnMenuEditClearToggleTags, ''),
                        (''),
                        ]
                menuInfoGeneral += [
                    (_('Edit filter database'), '', self.OnSliderLabelEditDatabase, ''),
                    (''),
                    (_('Toggle all folds'), '', self.OnSliderLabelToggleAllFolds, ''),
                    (_('Toggle exclusions filters'), '', self.OnSliderToggleExclusionsFilters, ''),
                    (_('General settings...'), '', self.OnSliderLabelSettings, ''),
                    (''),
                    (_('Set same width for all tabs'), '', self.OnSliderWindowsSameWidth, ''),
                    (_('Save window width for startup'), '', self.OnSliderWindowsSaveWidth, ''),
                    (_('Slider update immediately'), '', self.OnSliderToggleUpdateMode, '', wx.ITEM_CHECK, False),
                    (''),
                    #(_('Show Preview Filter time'), '', OnSetPFilterTime, '', wx.ITEM_CHECK, self.ShowPFilterTime),
                    (_('Update sliders'), '', self.OnSliderUpdate, ''),
                ]
                self.SlidersContextMenu = self.createMenu(menuInfoGeneral)

            menuGeneral = self.SlidersContextMenu

            if self.slidersShowExclusionFilters:
                exclusionList = []
            else:
                exclusionList = self.options['autosliderexclusions'].lower().split()
            row = 0
            addSnapshotPanel = True

            """ snapshot first, I can't make up my mind yet ;)
            if addSnapshotPanel:
                    separator = self.addAvsSliderSeparatorNew(script, label='Snapshot', menu=None, row=row, sizer=script.sliderSizerNew)
                    row += 1
                    self.addAvsSnapshotPanel(script, separator, row)
                    row += 1
            """
            #for filterName, filterInfo in script.autoSliderInfo:
            for filterName, filterInfo, extraInfo in script.autoSliderInfo: #GPo new extraInfo if previewFilter
                filterN = filterName.lower().split(' (')[0]
                if filterN in exclusionList:
                    continue
                separator = None
                filterName += extraInfo
                for info, enteredName, enteredValue, argIndex in filterInfo:
                    # Parse the argument info entered into the script
                    splitEnteredValue = enteredValue.split('=')
                    if len(splitEnteredValue) == 2:
                        namedArg, strValue = splitEnteredValue
                    else:
                        namedArg = None
                        strValue = enteredValue
                    strValue = strValue.strip(string.whitespace+'\\')
                    if strValue.startswith(self.sliderOpenString) and strValue.endswith(self.sliderCloseString):
                        continue
                    # Parse the calltip info and build the appropriate slider
                    argtype, argname, guitype, defaultValue, other = self.ParseCalltipArgInfo(info, strValue=strValue)
                    if argtype is None or argname is None or guitype is None or argtype not in ('int', 'float', 'bool', 'string'):
                        continue
                    if enteredName is not None:
                        if argname.startswith('"') and argname.endswith('"'):
                            argname = '"%s"' % enteredName.strip('"')
                        else:
                            argname = enteredName
                    boolException = False
                    if guitype == 'slider':
                        # Create a numerical slider
                        if not self.options['autoslidermakeintfloat']:
                            continue
                        minValue, maxValue, nDecimal, mod = other
                        try:
                            value = float(strValue)
                        except ValueError:
                            boolException = True
                            value = None
                        if value is None:
                            value = minValue
                        if value < minValue:
                            minValue = value
                        if value > maxValue:
                            maxValue = value
                        if separator is None:
                            separator = self.addAvsSliderSeparatorNew(script, label=filterName, menu=menuGeneral, row=row, sizer=script.sliderSizerNew)
                            row += 1
                        if boolException:
                            self.addAvsGenericArg(script, argname, strValue, row, separator, filterName, argIndex)
                        else:
                            self.addAvsSliderNew(script, argname, value, minValue, maxValue, defaultValue, nDecimal, mod, row, sizer=script.sliderSizerNew, separator=separator, filterName=filterName, argIndex=argIndex)
                        row += 1
                    elif guitype == 'color':
                        # Create a color picker button
                        if not self.options['autoslidermakecolor']:
                            continue
                        if strValue.startswith('$'):
                            try:
                                value = strValue.split('$', 1)[1]
                                int(value, 16)
                            except ValueError:
                                boolException = True
                        else:
                            try:
                                value = '%X' % int(strValue)
                                if len(value) <= 6:
                                    value = value.rjust(6, '0')
                                else:
                                    boolException = True
                            except ValueError:
                                boolException = True
                        if separator is None:
                            separator = self.addAvsSliderSeparatorNew(script, label=filterName, menu=menuGeneral, row=row, sizer=script.sliderSizerNew)
                            row += 1
                        if boolException:
                            self.addAvsGenericArg(script, argname, strValue, row, separator, filterName, argIndex)
                        else:
                            self.addAvsColorPicker(script, argname, value, defaultValue, row, separator, filterName, argIndex)
                        row += 1
                    elif guitype == 'boolradio':
                        # Create a true/false radio box
                        if not self.options['autoslidermakebool']:
                            continue
                        if strValue.lower() in ('true', 'false'):
                            if strValue.lower() == 'true':
                                value = True
                            else:
                                value = False
                        else:
                            boolException = True
                        if separator is None:
                            separator = self.addAvsSliderSeparatorNew(script, label=filterName, menu=menuGeneral, row=row, sizer=script.sliderSizerNew)
                            row += 1
                        if boolException:
                            self.addAvsGenericArg(script, argname, strValue, row, separator, filterName, argIndex)
                        else:
                            self.addAvsBooleanRadio(script, argname, value, defaultValue, row, separator, filterName, argIndex)
                        row += 1
                    elif guitype in ('intlist', 'stringlist'):
                        if guitype == 'intlist':
                            if not self.options['autoslidermakeintlist']:
                                continue
                        else:
                            if not self.options['autoslidermakestringlist']:
                                continue
                            if not strValue.startswith('"') or not strValue.endswith('"'):
                                boolException = True
                            else:
                                strValue = strValue.strip('"')
                        choices = other
                        if separator is None:
                            separator = self.addAvsSliderSeparatorNew(script, label=filterName, menu=menuGeneral, row=row, sizer=script.sliderSizerNew)
                            row += 1
                        if boolException:
                            self.addAvsGenericArg(script, argname, strValue, row, separator, filterName, argIndex)
                        else:
                            self.addAvsChoice(script, argname, strValue, choices, defaultValue, guitype, row, separator, filterName, argIndex)
                        row += 1
                    elif guitype == 'stringfilename':
                        if not self.options['autoslidermakestringfilename']:
                            continue
                        extList = other
                        if not strValue.startswith('"') or not strValue.endswith('"'):
                            boolException = True
                        else:
                            value = strValue.strip('"')
                        if separator is None:
                            separator = self.addAvsSliderSeparatorNew(script, label=filterName, menu=menuGeneral, row=row, sizer=script.sliderSizerNew)
                            row += 1
                        if boolException:
                            self.addAvsGenericArg(script, argname, strValue, row, separator, filterName, argIndex)
                        else:
                            self.addAvsFilenamePicker(script, argname, value, extList, row, separator, filterName, argIndex)
                        row += 1
                    elif guitype in ('undocumented', 'error'):
                        # Undocumented argument
                        if not self.options['autoslidermakeunknown']:
                            continue
                        if separator is None:
                            separator = self.addAvsSliderSeparatorNew(script, label=filterName, menu=menuGeneral, row=row, sizer=script.sliderSizerNew)
                            row += 1
                        self.addAvsGenericArg(script, argname, strValue, row, separator, filterName, argIndex)
                        row += 1

            """ if snapshot first
            if (addSnapshotPanel and row == 2) or (not addSnapshotPanel and row == 0):
                script.autoSliderInfo = []
            """
            if row == 0:
                script.autoSliderInfo = []
            else:
                if addSnapshotPanel:
                    separator = self.addAvsSliderSeparatorNew(script, label='Snapshot', menu=None, row=row, sizer=script.sliderSizerNew)
                    row += 1
                    self.addAvsSnapshotPanel(script, separator, row)
                    row += 1

                # Add a spacer
                height = 0
                if script.sliderTexts != []:
                    height = intPPI(20)
                script.sliderSizerNew.Add((5, height), (row, 7))

            if wx.VERSION > (2, 9):
                script.sliderSizerNew.Add((0, 0), (row, 3))
                if not script.sliderSizerNew.IsColGrowable(3):
                    script.sliderSizerNew.AddGrowableCol(3)

            # Fold according to user set preference
            # GPo 2020, restore last folds
            foldLevel = self.options['autosliderstartfold']
            if foldLevel == 3:
                if script.SliderFoldsBackup:
                    self.SliderRestoreFolds()
                else:
                    for item in script.sliderToggleLabels:
                        self.ToggleSliderFold(item, fold=True, refresh=False)
                    self.foldAllSliders = False
                self.SliderSaveCurrentFolds()
            elif foldLevel == 0:
                # Fold all filters
                for item in script.sliderToggleLabels:
                    self.ToggleSliderFold(item, fold=True, refresh=False)
                self.foldAllSliders = False
            elif foldLevel == 1:
                # Fold none, don't need to do anything
                self.foldAllSliders = True
            elif foldLevel == 2:
                # Fold only filters without numerical sliders
                boolAnyUnfolded = False
                for item in script.sliderToggleLabels:
                    if not item.hasNumericalSlider:
                        self.ToggleSliderFold(item, fold=True, refresh=False)
                    else:
                        boolAnyUnfolded = True
                if boolAnyUnfolded:
                    self.foldAllSliders = True
            else:
                pass
        finally:
            self.TryThaw(script.sliderWindow)

    def addAvsSliderNew(self, script, labelTxt, value, minValue, maxValue, defaultValue, nDecimal, mod=None, row=None, sizer=None, separator=None, filterName=None, argIndex=None):
        if minValue is None or maxValue is None or value is None or nDecimal is None:
            return
        if sizer is None:
            sizer = script.sliderSizer
        parent = script.sliderWindow
        int5 = intPPI(5)
        int10 = intPPI(10)
        # Construct the format string based on nDecimal
        strTemplate = '%.'+str(nDecimal)+'f'
        # Create the slider
        slider = wxp.Slider(parent, wx.ID_ANY,
            value, minValue, maxValue,
            size=(intPPI(50),-1),
            style=wx.SL_BOTH,
            name=labelTxt,
            nDecimal=nDecimal,
            mod=mod,
            onscroll=lambda event: valTxtCtrl.SetLabel(strTemplate % slider.GetValue())
        )
        slider.argName = labelTxt
        slider.script = script
        slider.argIndex = argIndex
        slider.lastValue = slider.GetValue()
        if filterName and filterName.find(' - P') > -1:
            idx = filterName[-1]
            slider.prevFilterIdx = int(idx) if idx.isdigit() else -2
        else:
            slider.prevFilterIdx = -2
        slider.filterName = filterName

        # Slider event binding
        def UserSliderVideoUpdateNew(slider, refreshVideo=True):
            # Create the new arg text
            newVal = slider.GetValueAsString()
            if refreshVideo:
                slider.lastValue = slider.GetValue()
            self.SetNewAvsValue(slider, newVal, refreshvideo=refreshVideo)
        #def OnLeftDownUserSlider(event):
            #event.Skip()
        def OnLeftUpUserSlider(event):
            if slider.lastValue != slider.GetValue():
                UserSliderVideoUpdateNew(slider)
            event.Skip()
        def OnMoveUserSlider(event):
            if self.options['autosliderupdatedirectly']:
                if slider.lastValue != slider.GetValue(): # disable move event on mouse up
                    if (self.currentScript.previewFilterIdx == slider.prevFilterIdx) and not wx.GetKeyState(wx.WXK_CONTROL):
                        UserSliderVideoUpdateNew(slider) # GPo, do not use call after!! or IdleCall!! AvsPmod crash if previewFilter !!
                    #else: # only needed if mouse wheel enabled
                        #UserSliderVideoUpdateNew(slider, False) # only set value to script, Win10 mouse wheel hack
            #else: # only needed if mouse wheel enabled
                #UserSliderVideoUpdateNew(slider, False) # only set value to script, Win10 mouse wheel hack
                #event.Skip()
        def OnKeyUpUserSlider(event):
            if slider.lastValue != slider.GetValue():
                UserSliderVideoUpdateNew(slider)
            event.Skip()
        def OnMouseWheelUserSlider(event): # Win10 sets automatically the focus on the object under the cursor, so disable it
            if event.LeftIsDown():
                if self.currentScript.previewFilterIdx == slider.prevFilterIdx: # disable mouse wheel on preview filters
                    return
                event.Skip()
        slider.Bind(wx.EVT_LEFT_UP, OnLeftUpUserSlider)
        slider.Bind(wx.EVT_SLIDER, OnMoveUserSlider)
        #slider.Bind(wx.EVT_LEFT_DOWN, OnLeftDownUserSlider)
        slider.Bind(wx.EVT_MOUSEWHEEL, OnMouseWheelUserSlider) # must be bind to disable the mouse wheel
        slider.Bind(wx.EVT_KEY_UP, OnKeyUpUserSlider)
        slider.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)
        # Create the static text labels
        labelTxtCtrl = self.MakeArgNameStaticText(parent, labelTxt, filterName, script, argIndex)
        minTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, strTemplate % minValue)
        maxTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, strTemplate % maxValue)
        valTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, strTemplate % value)
        font = valTxtCtrl.GetFont()
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        valTxtCtrl.SetFont(font)
        if self.currentSliderWindow.customTheme:
            valTxtCtrl.SetForegroundColour(self.currentSliderWindow.foreDefValue)
            slider.SetBackgroundColour(self.currentSliderWindow.backSlider)
        else:
            valTxtCtrl.SetForegroundColour(wx.BLUE)
        valTxtCtrl.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
        value_formatted = strTemplate % defaultValue
        valTxtCtrl.SetToolTip(wx.ToolTip(_('Reset to default value: %(value_formatted)s') % locals()))
        def OnTextLeftDown(event):
            valTxtCtrl.SetLabel(value_formatted)
            slider.SetValue(defaultValue)
            UserSliderVideoUpdateNew(slider)
        valTxtCtrl.Bind(wx.EVT_LEFT_DOWN, OnTextLeftDown)
        leftCtrl = wxButtons.GenBitmapButton(parent, wx.ID_ANY, self.bmpLeftTriangle, size=tuplePPI(16,16))
        leftCtrl.SetBezelWidth(intPPI(1))
        leftCtrl.SetUseFocusIndicator(False)
        def OnLeftTimer(event):
            directly = (self.currentScript.previewFilterIdx == slider.prevFilterIdx) and self.options['autosliderupdatedirectly']
            newvalue = slider.Decrement()
            valTxtCtrl.SetLabel(strTemplate % newvalue)
            if directly:
                UserSliderVideoUpdateNew(slider)
            event.Skip()
        leftTimer = wx.Timer(leftCtrl)
        leftCtrl.Bind(wx.EVT_TIMER, OnLeftTimer)
        def OnButtonDecLeftDown(event):
            newvalue = slider.Decrement()
            valTxtCtrl.SetLabel(strTemplate % newvalue)
            if wx.GetKeyState(wx.WXK_CONTROL):
                self.fc = wx.CallLater(400, leftTimer.Start, 500)
            else:
                self.fc = wx.CallLater(300, leftTimer.Start, 100)
            event.Skip()
        def OnButtonDecLeftUp(event):
            if self.fc is not None:
                self.fc.Stop()
            leftTimer.Stop()
            valTxtCtrl.SetLabel(strTemplate % slider.GetValue())
            event.Skip()
            if slider.lastValue != slider.GetValue():
                UserSliderVideoUpdateNew(slider)
        leftCtrl.Bind(wx.EVT_LEFT_DOWN, OnButtonDecLeftDown)
        leftCtrl.Bind(wx.EVT_LEFT_UP, OnButtonDecLeftUp)
        leftCtrl.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)
        rightCtrl = wxButtons.GenBitmapButton(parent, wx.ID_ANY, self.bmpRightTriangle, size=tuplePPI(16,16))
        rightCtrl.SetBezelWidth(1)
        rightCtrl.SetUseFocusIndicator(False)
        def OnRightTimer(event):
            directly = (self.currentScript.previewFilterIdx == slider.prevFilterIdx) and self.options['autosliderupdatedirectly']
            newvalue = slider.Increment()
            valTxtCtrl.SetLabel(strTemplate % newvalue)
            if directly:
                slider.lastValue = slider.GetValue()
                UserSliderVideoUpdateNew(slider)
            event.Skip()
        rightTimer = wx.Timer(rightCtrl)
        rightCtrl.Bind(wx.EVT_TIMER, OnRightTimer)
        def OnButtonIncLeftDown(event):
            newvalue = slider.Increment()
            valTxtCtrl.SetLabel(strTemplate % newvalue)
            if wx.GetKeyState(wx.WXK_CONTROL):
                self.fc = wx.CallLater(400, rightTimer.Start, 500)
            else:
                self.fc = wx.CallLater(300, rightTimer.Start, 100)
            event.Skip()
        def OnButtonIncLeftUp(event):
            if self.fc is not None:
                self.fc.Stop()
            rightTimer.Stop()
            valTxtCtrl.SetLabel(strTemplate % slider.GetValue())
            event.Skip()
            if slider.lastValue != slider.GetValue():
                UserSliderVideoUpdateNew(slider)
        rightCtrl.Bind(wx.EVT_LEFT_DOWN, OnButtonIncLeftDown)
        rightCtrl.Bind(wx.EVT_LEFT_UP, OnButtonIncLeftUp)
        rightCtrl.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnMouseCaptureLost)
        # Add the elements to the sliderSizer
        sizer.Add(labelTxtCtrl, (row,0), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, int10)
        sizer.Add(minTxtCtrl, (row,1), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.ALIGN_RIGHT)
        sizer.Add(leftCtrl, (row,2), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, int5)
        sizer.Add(slider, (row,3), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.EXPAND)
        sizer.Add(rightCtrl, (row,4), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, int5)
        sizer.Add(maxTxtCtrl, (row,5), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, int10)
        sizer.Add(valTxtCtrl, (row,6), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, intPPI(2)) # litle space right
        separator.controls += [labelTxtCtrl, minTxtCtrl, leftCtrl, slider, rightCtrl, maxTxtCtrl, valTxtCtrl]
        separator.hasNumericalSlider = True

    # for custom colors changed
    def addAvsBooleanRadio(self, script, argname, value, defaultValue, row, separator, filterName, argIndex):
        parent = script.sliderWindow
        sizer = script.sliderSizerNew
        int5 = intPPI(5)
        # Create window elements
        dummy = ' ' if self.ppi_factor > 1 else '' # radiobutton system scaling is faulty if text ''
        labelTxtCtrl = self.MakeArgNameStaticText(parent, argname, filterName, script, argIndex)
        radioButtonTrue = wx.RadioButton(parent, wx.ID_ANY, dummy, style=wx.RB_GROUP, size=(-1,-1))
        radioButtonFalse = wx.RadioButton(parent, wx.ID_ANY, dummy, size=(-1,-1))
        radioButtonTrue.name = 'rbTrue'
        radioButtonFalse.name = 'rbFalse'
        if value:
            radioButtonTrue.SetValue(True)
        else:
            radioButtonFalse.SetValue(True)
        def OnRadioButton(event):
            button = event.GetEventObject()
            # Check if label clicked
            if button == labeltrue:
                button = radioButtonTrue
                if button.GetValue() == True:
                    return
                button.SetValue(True)
            elif button == labelfalse:
                button = radioButtonFalse
                if button.GetValue() == True:
                    return
                button.SetValue(True)
            if button == radioButtonTrue:
                newVal = 'true'
            else:
                newVal = 'false'
            self.SetNewAvsValue(button, newVal)
            event.Skip()
        for ctrl in (radioButtonTrue, radioButtonFalse):
            ctrl.filterName = filterName
            ctrl.argName = argname
            ctrl.script = script
            ctrl.argIndex = argIndex
            ctrl.Bind(wx.EVT_RADIOBUTTON, OnRadioButton)
        # Make labels, radio doesn't change foregroundcolor
        labeltrue = wxp.StaticText(parent, wx.ID_ANY, 'true')
        labeltrue.Bind(wx.EVT_LEFT_UP, OnRadioButton)
        labelfalse = wxp.StaticText(parent, wx.ID_ANY, 'false')
        labelfalse.Bind(wx.EVT_LEFT_UP, OnRadioButton)
        if defaultValue is not None:
            if defaultValue.lower() == 'true':
                font = labeltrue.GetFont()
                font.SetUnderlined(True)
                labeltrue.SetFont(font)
            else:
                font = labelfalse.GetFont()
                font.SetUnderlined(True)
                labelfalse.SetFont(font)

        radioSizer = wx.BoxSizer(wx.HORIZONTAL)
        radioSizer.Add(radioButtonTrue, 0, wx.TOP|wx.BOTTOM|wx.LEFT, int5)
        radioSizer.Add(labeltrue, 1, wx.TOP|wx.BOTTOM|wx.RIGHT, int5)
        radioSizer.Add(radioButtonFalse, 0, wx.TOP|wx.BOTTOM|wx.LEFT, int5)
        radioSizer.Add(labelfalse, 1, wx.TOP|wx.BOTTOM|wx.RIGHT, int5)
        # Add the elements to the slider sizer
        sizer.Add(labelTxtCtrl, (row,0), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, intPPI(10))
        sizer.Add(radioSizer, (row, 1), (1,6), wx.ALIGN_CENTER_VERTICAL)
        separator.controls += [labelTxtCtrl, radioSizer]

    def addAvsColorPicker(self, script, argname, value, defaultValue, row, separator, filterName, argIndex):
        parent = script.sliderWindow
        sizer = script.sliderSizerNew
        # Create window elements
        labelTxtCtrl = self.MakeArgNameStaticText(parent, argname, filterName, script, argIndex)
        try:
            r = int(defaultValue[0:2],16)
            g = int(defaultValue[2:4],16)
            b = int(defaultValue[4:6],16)
            defaultColor = wx.Colour(r, g, b)
        except:
            defaultColor = wx.Colour()
        try:
            r = int(value[0:2],16)
            g = int(value[2:4],16)
            b = int(value[4:6],16)
        except:
            r=g=b=0
        colorButton = wxp.ColourSelect(parent, wx.ID_ANY, colour=wx.Colour(r,g,b), size=tuplePPI(50,23), colour_data=self.colour_data)
        def OnSelectColour(event):
            self.options['colourdata'] = self.colour_data.ToString()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
            strColor = '$%02x%02x%02x' % colorButton.GetColour().Get()
            self.SetNewAvsValue(colorButton, strColor.upper())
        colorButton.Bind(colourselect.EVT_COLOURSELECT, OnSelectColour)
        def OnRightUpButtonColor(event):
            colorButton.SetColour(defaultColor)
            self.SetNewAvsValue(colorButton, '$%s' % defaultValue.upper())
        colorButton.Bind(wx.EVT_RIGHT_UP, OnRightUpButtonColor)
        colorButton.SetToolTip(wx.ToolTip(_('Left-click to select a color, right click to reset to default')+' ($%s)' % defaultValue))

        colorButton.filterName = filterName
        colorButton.argName = argname
        colorButton.script = script
        colorButton.argIndex = argIndex

        #TODO: FIX
        colorSizer = wx.BoxSizer(wx.HORIZONTAL)
        colorSizer.Add(colorButton, 0, wx.TOP|wx.BOTTOM|wx.RIGHT, intPPI(5))
        # Add the elements to the slider sizer
        sizer.Add(labelTxtCtrl, (row,0), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, intPPI(10))
        sizer.Add(colorSizer, (row, 1), (1,6), wx.ALIGN_CENTER_VERTICAL)
        separator.controls += [labelTxtCtrl, colorSizer]

    def addAvsChoice(self, script, argname, value, choices, defaultValue, guitype, row, separator, filterName, argIndex):
        parent = script.sliderWindow
        sizer = script.sliderSizerNew
        # Create window elements
        labelTxtCtrl = self.MakeArgNameStaticText(parent, argname, filterName, script, argIndex)
        if guitype == 'stringlist':
            choices2 = [s.strip('"') for s in choices]
            try:
                index = [s.lower() for s in choices2].index(defaultValue.strip('"').lower())
                choices2[index] = choices2[index] + ' *'
            except ValueError:
                pass
            choiceBox = wx.Choice(parent, wx.ID_ANY, choices=choices2)
            choiceBox.guitype = 1
            try:
                index = [s.strip('"').lower() for s in choices].index(value.strip('"').lower())
                choiceBox.SetSelection(index)
            except ValueError:
                pass
            def OnChoice(event):
                newVal = '"%s"' % choices[choiceBox.GetCurrentSelection()].strip('"')
                self.SetNewAvsValue(choiceBox, newVal)
                event.Skip()
        else:
            try:
                index = choices.index(str(defaultValue))
                choices2 = [str(i) for i in choices]
                choices2[index] = choices2[index] + ' *'
            except ValueError:
                choices2 = choices
            choiceBox = wx.Choice(parent, wx.ID_ANY, choices=choices2)
            choiceBox.guitype = 2
            try:
                choiceBox.SetSelection(choices.index(value))
            except ValueError:
                pass
            def OnChoice(event):
                newVal = choices[choiceBox.GetCurrentSelection()]
                self.SetNewAvsValue(choiceBox, newVal)
                event.Skip()
        choiceBox.filterName = filterName
        choiceBox.argName = argname
        choiceBox.script = script
        choiceBox.argIndex = argIndex
        choiceBox.Bind(wx.EVT_CHOICE, OnChoice)
        if self.currentSliderWindow.customTheme:
            choiceBox.SetBackgroundColour(self.currentSliderWindow.backTextCtrl)
            choiceBox.SetForegroundColour(self.currentSliderWindow.foreTextCtrl)
        # Add the elements to the slider sizer
        sizer.Add(labelTxtCtrl, (row,0), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, intPPI(10))
        sizer.Add(choiceBox, (row, 1), (1,6), wx.ALIGN_CENTER_VERTICAL)
        separator.controls += [labelTxtCtrl, choiceBox]

    def addAvsFilenamePicker(self, script, argname, value, extList, row, separator, filterName, argIndex):
        parent = script.sliderWindow
        sizer = script.sliderSizerNew
        # Create window elements
        extList = [s.strip() for s in extList if not s.strip().startswith('*.*')]
        labelTxtCtrl = self.MakeArgNameStaticText(parent, argname, filterName, script, argIndex)
        textCtrl = wx.TextCtrl(parent, wx.ID_ANY, value, style=wx.TE_PROCESS_ENTER|wx.BORDER_SIMPLE)
        if self.currentSliderWindow.customTheme:
            textCtrl.SetBackgroundColour(self.currentSliderWindow.backTextCtrl)
            textCtrl.SetForegroundColour(self.currentSliderWindow.foreTextCtrl)
        browseButton = wx.Button(parent, wx.ID_ANY, '...', size=(intPPI(20), -1))
        def OnTextChange(event):
            script.oldAutoSliderInfo = None
            event.Skip()
        def OnTextEnter(event):
            newVal = '"%s"' % textCtrl.GetValue().strip(' "')
            self.SetNewAvsValue(textCtrl, newVal)
            event.Skip()
        def OnBrowseButton(event):
            dirname = os.path.dirname(textCtrl.GetValue())
            if os.path.isdir(dirname):
                initial_dir = dirname
            else:
                initial_dir = self.GetProposedPath(only='dir')
            extlist = self.options['templates'].keys()
            extlist.sort()
            extlist2 = [s for s in extlist if not s.startswith('avs')]
            extlist1 = ', '.join(extlist2)
            extlist2 = ';*.'.join(extlist2)
            s1 = '%s|%s' % (', '.join(extList), ';'.join(extList))
            s2 = _('Source files') + ' (%(extlist1)s)|*.%(extlist2)s' % locals()
            s3 = _('All files') + ' (*.*)|*.*'
            if extList:
                filefilter = '%s|%s|%s' % (s1, s2, s3)
            else:
                filefilter = s3
            dlg = wx.FileDialog(self,_('Select a file'), initial_dir, '', filefilter, wx.OPEN)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                filename = dlg.GetPath()
                newVal = '"%s"' % filename
                self.SetNewAvsValue(browseButton, newVal)
                textCtrl.SetValue(filename)
                dirname = os.path.dirname(filename)
                if os.path.isdir(dirname):
                    self.options['recentdir'] = dirname
            dlg.Destroy()
            event.Skip()
        for ctrl in (textCtrl, browseButton):
            ctrl.filterName = filterName
            ctrl.argName = argname
            ctrl.script = script
            ctrl.argIndex = argIndex
        self.Bind(wx.EVT_BUTTON, OnBrowseButton, browseButton)
        textCtrl.Bind(wx.EVT_TEXT_ENTER, OnTextEnter)
        textCtrl.Bind(wx.EVT_TEXT, OnTextChange)
        browseSizer = wx.BoxSizer(wx.HORIZONTAL)
        browseSizer.Add(textCtrl, 1, wx.EXPAND|wx.RIGHT, intPPI(2))
        browseSizer.Add(browseButton, 0)#, wx.ALL, 5)
        # Add the elements to the slider sizer
        sizer.Add(labelTxtCtrl, (row,0), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, intPPI(10))
        sizer.Add(browseSizer, (row,1), (1,6), wx.ALIGN_CENTER_VERTICAL|wx.EXPAND)
        separator.controls += [labelTxtCtrl, browseSizer]

    def addAvsSnapshotPanel(self, script, separator, row):
        def OnRestoreToCurrent(event):
            idx = 0 if self.lastContextMenuWin == btnSnapshot1 else 1
            self.RestoreSnapShotToCurrent(shotIdx=idx)
        def OnRestoreToNewTab(event):
            self.snapShotIdx = 0
            Idx = 0 if self.lastContextMenuWin == btnSnapshot1 else 1
            self.NewTabFromSnapShot(shotIdx=Idx)
        def OnClearAll(event):
            self.OnMenuClearAllSnapShots()
        def OnAutoSnapshot(event):
            btn = event.GetEventObject()
            self.options['autosnapshot'] = event.IsChecked()
            if self.options['autosnapshot']:
                btnSnapshot2.SetLabel('*Make 2  Show 2')
            else: btnSnapshot2.SetLabel('Make 2  Show 2')
            btnSnapshot2.Update()
            self.UpdateMenuItem(_('Snapshot'), event.IsChecked(), 'video', [_('Auto take snapshot 2')])
        def OnCopySnapshot2To1(event):
            script = self.currentScript
            nr, bmp, txt, idx = script.snapShots['shot2']
            if bmp and txt:
                script.snapShots['shot1'] = [nr, bmp.GetSubBitmap(wx.Rect(0, 0, *bmp.Size)), txt, idx] # [-1, None, "", 0]
            else: wx.MessageBox(_('Error: Snapshot 2 is empty'))
        def OnContextMenu(event):
            self.lastContextMenuWin = event.GetEventObject()
            info = [
                (_('Restore to current'), '', OnRestoreToCurrent, ''),
                (_('Restore to new tab'), '', OnRestoreToNewTab, ''),
                (''),
                (_('Copy snapshot 2 to 1'), '', OnCopySnapshot2To1, ''),
                (_('Auto take snapshot 2'), '', OnAutoSnapshot, '', wx.ITEM_CHECK, self.options['autosnapshot']),
                (''),
                (_('Clear all'), '', OnClearAll, ''),
            ]
            popup = self.createMenu(info)

            self.PopupMenu(popup)
            popup.Destroy()

        int5, int10 = intPPI(5), intPPI(10)
        parent = script.sliderWindow
        sizer = script.sliderSizerNew
        btnSnapshot1 = wxp.StaticText(parent, wx.ID_ANY, label='Make 1  Show 1')
        if self.options['autosnapshot']:
            btnSnapshot2 = wxp.StaticText(parent, wx.ID_ANY, label='*Make 2  Show 2')
        else: btnSnapshot2 = wxp.StaticText(parent, wx.ID_ANY, label='Make 2  Show 2')
        ctrl = (btnSnapshot1,btnSnapshot2)
        font = btnSnapshot1.GetFont()
        font.SetUnderlined(True)
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        if dpi.ppi_factor == 1:
            font.SetPointSize(intPPI(font.GetPointSize()+1))
        #else: dpi.SetFontSize(font, dpi.ppi_factor)
        for item in ctrl:
            item.SetFont(font)
            item.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
            if self.currentSliderWindow.customTheme:
                item.SetForegroundColour(self.currentSliderWindow.foreExtraBtn1)
            item.Bind(wx.EVT_CONTEXT_MENU, OnContextMenu)
        def GetResponse(btn):
            try:
                label = btn.GetLabel() # I do not know. Errors rarely come C++ part is deleted
            except:
                return
            btn.SetLabel(_('Done'))
            btn.Update()
            wx.MilliSleep(500)
            btn.SetLabel(label)
            btn.Update()
        def OnBtnSnapshot1(event):
            btn = event.GetEventObject()
            x,y = event.GetPosition()
            if x < (btn.GetSize()[0] / 2) - 3:
                self.TakeSnapShot(0)
                GetResponse(btn)
            elif x > (btn.GetSize()[0] / 2) + 3:
                self.ShowSnapShot(0, showMsg=False)
        def OnBtnSnapshot2(event):
            btn = event.GetEventObject()
            x,y = event.GetPosition()
            if x < (btn.GetSize()[0] / 2) - 3:
                self.TakeSnapShot(1)
                GetResponse(btn)
            elif x > (btn.GetSize()[0] / 2) + 3:
                self.ShowSnapShot(1, showMsg=False)
        btnSnapshot1.Bind(wx.EVT_LEFT_UP, OnBtnSnapshot1)
        btnSnapshot2.Bind(wx.EVT_LEFT_UP, OnBtnSnapshot2)
        btnSizer = wx.BoxSizer(wx.HORIZONTAL)
        btnSizer.Add(btnSnapshot1, 0, wx.TOP|wx.BOTTOM|wx.LEFT, int5)
        btnSizer.AddSpacer(int10)
        btnSizer.Add(btnSnapshot2, 0, wx.TOP|wx.BOTTOM|wx.LEFT, int5)
        sizer.Add(btnSizer, (row,0), (1,7), wx.LEFT|wx.EXPAND, int5)
        separator.controls += [btnSizer]

    def addAvsGenericArg(self, script, argname, strValue, row, separator, filterName, argIndex):
        parent = script.sliderWindow
        sizer = script.sliderSizerNew
        # Create window elements
        labelTxtCtrl = self.MakeArgNameStaticText(parent, argname, filterName, script, argIndex)
        if self.currentSliderWindow.customTheme:
            textCtrl = wx.TextCtrl(parent, wx.ID_ANY, strValue, style=wx.TE_PROCESS_ENTER|wx.BORDER_SIMPLE)
            textCtrl.SetBackgroundColour(self.currentSliderWindow.backTextCtrl)
            textCtrl.SetForegroundColour(self.currentSliderWindow.foreTextCtrl)
        else:
            textCtrl = wx.TextCtrl(parent, wx.ID_ANY, strValue, style=wx.TE_PROCESS_ENTER)
        def OnTextChange(event):
            self.SetNewAvsValue(textCtrl, textCtrl.GetValue(), refreshvideo=False)
            event.Skip()
        def OnTextEnter(event):
            self.SetNewAvsValue(textCtrl, textCtrl.GetValue())
            #~ event.Skip()
        textCtrl.Bind(wx.EVT_TEXT, OnTextChange)
        textCtrl.Bind(wx.EVT_TEXT_ENTER, OnTextEnter)
        textCtrl.filterName = filterName
        textCtrl.argName = argname
        textCtrl.script = script
        textCtrl.argIndex = argIndex
        sizer.Add(labelTxtCtrl, (row,0), wx.DefaultSpan, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.LEFT, intPPI(10))
        sizer.Add(textCtrl, (row,1), (1,6), wx.ALIGN_CENTER_VERTICAL|wx.EXPAND)
        separator.controls += [labelTxtCtrl, textCtrl]

    def MakeArgNameStaticText(self, parent, labelTxt, filterName, script, argIndex, size=wx.DefaultSize):
        labelTxtCtrl = wxp.StaticText(parent, wx.ID_ANY, labelTxt, size=size)
        labelTxtCtrl.SetCursor(wx.StockCursor(wx.CURSOR_PENCIL))
        labelTxtCtrl.filterName = filterName
        labelTxtCtrl.argName = labelTxt
        labelTxtCtrl.script = script
        labelTxtCtrl.argIndex = argIndex
        def OnLeftDown(event):
            selText, selA, selB = self.GetArgTextAndPos(labelTxtCtrl)
            if selText.startswith('"') and selText.endswith('"'):
                selA += 1
                selB -= 1
            script.SetSelection(selA, selB)
            script.EnsureCaretVisible()
            script.SetFocus()
            event.Skip()
        labelTxtCtrl.Bind(wx.EVT_LEFT_DOWN, OnLeftDown)
        return labelTxtCtrl

    def SetNewAvsValue(self, control, newValue, refreshvideo=True):
        if self.playing_video:     # GPo 2020
            self.PlayPauseVideo(refreshFrame=True)

        argText, posA, posB = self.GetArgTextAndPos(control)
        if argText is None:
            return
        script = control.script
        # Create the new arg text
        script.SetTargetStart(posA)
        script.SetTargetEnd(posB)
        script.ReplaceTarget(newValue)

        if refreshvideo:
            if control.filterName.find(' - P') > 0: # preview filter
                if script.previewFilterIdx > 0:
                    self.OnMenuPreviewFilter(None, script.previewFilterIdx, updateUserSliders=False)
            else:
                if not script.chkDisableRefresh.IsChecked():
                    keep_env = script.previewFilterIdx == 0
                    script.refreshAVI = True
                    self.ShowVideoFrame(userScrolling=True, keep_env=keep_env, forceCursor=True)
                else:
                    script.Colourise(posA, posA+len(newValue)) # needed for ScriptChanged
                    self.refreshAVI = True
                    script.refreshAVI = True
        else:
            self.refreshAVI = True
            script.refreshAVI = True

    def GetArgTextAndPos(self, slider):
        # Find the filter in the text
        script = slider.script
        splitFilterName = slider.filterName.split('(', 1)
        if len(splitFilterName) == 2:
            filterName = splitFilterName[0].strip()
            iFilter = splitFilterName[1].split(')')[0]
            try:
                iFilter = int(iFilter)
            except ValueError:
                return (None, None, None)
        else:
            splitFilterName = slider.filterName.split(' - P', 1) # GPo new
            if len(splitFilterName) == 2:
                filterName = splitFilterName[0].strip()
            else: filterName = slider.filterName
            iFilter = 1
        startpos = 0
        for i in range(iFilter):
            startpos = script.FindText(startpos, script.GetTextLength(), filterName, stc.STC_FIND_WHOLEWORD)
            if startpos == -1:
                return (None, None, None)
            startpos += 1
            while script.GetStyleAt(startpos) not in script.keywordStyleList:
                startpos = script.FindText(startpos, script.GetTextLength(), filterName, stc.STC_FIND_WHOLEWORD)
                if startpos == -1:
                    return (None, None, None)
                startpos += 1
        # Find the argument in the text
        endwordpos = script.WordEndPosition(startpos, 1)
        while chr(script.GetCharAt(endwordpos)) in (' ', '\t'):
            endwordpos += 1
        posEnd = script.BraceMatch(endwordpos)
        if posEnd == -1:
            return (None, None, None)
        argIndex = slider.argIndex
        for i in xrange(argIndex):
            endwordpos = script.GetNextValidCommaPos(endwordpos+1)
            if endwordpos is None:
                return (None, None, None)
        posA = endwordpos+1
        posB = script.GetNextValidCommaPos(posA)
        if posB is None or posB > posEnd:
            posB = posEnd
        text = script.GetTextRange(posA, posB)
        posEqualSign = script.GetNextValidCommaPos(posA, checkChar='=')
        if posEqualSign is not None and posEqualSign < posB:
            posA = posEqualSign+1
        pos = posA
        while pos < posB:
            c = unichr(script.GetCharAt(pos))
            if c.strip() and c != '\\':
                posA = pos
                break
            pos += 1
        pos = posB
        while pos > posA:
            c = unichr(script.GetCharAt(pos-1))
            if c.strip() and c != '\\':
                posB = pos
                break
            pos -= 1
        return script.GetTextRange(posA, posB), posA, posB

    def OnSliderUpdate(self, event):
        wx.CallAfter(self.UpdateUserSliders, forceUpdate=True)

    def SliderAddToggleTag(self, name):
        script = self.currentScript
        scriptChanged = self.ScriptChanged(script)
        splitFilterName = name.split('(', 1)
        if len(splitFilterName) == 2:
            filterName = splitFilterName[0].strip()
            iFilter = splitFilterName[1].split(')')[0]
            try:
                iFilter = int(iFilter)
            except ValueError:
                return
        else:
            splitFilterName = name.split(' - P', 1)
            if len(splitFilterName) == 2:
                filterName = splitFilterName[0].strip()
            else: filterName = name
            iFilter = 1
        startpos = 0
        for i in range(iFilter):
            startpos = script.FindText(startpos, script.GetTextLength(), filterName, stc.STC_FIND_WHOLEWORD)
            if startpos == -1:
                return
            startpos += 1
            while script.GetStyleAt(startpos) not in script.keywordStyleList:
                startpos = script.FindText(startpos, script.GetTextLength(), filterName, stc.STC_FIND_WHOLEWORD)
                if startpos == -1:
                    return
                startpos += 1

        posA = startpos-1
        posB = script.FindText(startpos, script.GetTextLength(), ')', stc.STC_FIND_MATCHCASE)
        if posB == -1:
            wx.Bell() # function not closed
            return

        # check is filter joined at start
        # does not work for both, therefore only the end is coded also return
        # or should the whole line be switched?
        if not script.GetAviSynthLine(posA).lstrip().startswith(filterName):
            wx.Bell()
            wx.MessageBox(_('Joined or disabled filters found: filter1.filter2\n'
                            'Only the first filter can have a toggle tag'),
                            'Error Toggle tag',parent=self.currentSliderWindow)
            return

        # check for a joined filter at the end
        prefix = '#>'
        xPos = posB+1
        while chr(script.GetCharAt(xPos)) in (' ', '\t'):
            xPos += 1
        if unichr(script.GetCharAt(xPos)) == '.':
            prefix = '' # if filter is joined then no prefix
            posB = xPos+1

        # find line start
        line = script.LineFromPosition(posA)
        posA = script.PositionFromLine(line)
        # find line end
        if prefix:
            line = script.LineFromPosition(posB)
            posB = script.GetLineEndPosition(line)
            extraB = extraA = '\n'
        else:
            extraB = extraA = ''

        if iFilter > 1:
            toggleName = '%s[/%s %i]' % (prefix, filterName, iFilter)
            name = '%s %i' % (filterName, iFilter)
        else:
            toggleName = '%s[/%s]' % (prefix, filterName)
            name = filterName
        # check if toggle tag exists
        if script.FindText(posB-2, posB + len(toggleName)+2, toggleName, stc.STC_FIND_WHOLEWORD) > -1:
            wx.Bell()
            return

        script.InsertText(posB, '%s%s[/%s]' % (extraB, prefix, name))
        script.InsertText(posA, '%s[%s=1]%s' % (prefix, name, extraA))
        self.UpdateUserSliders()
        # if was not changed before, no refresh needed becourse tag and filter are enabled
        # and we can set the preview text
        if not scriptChanged:
            script.Colourise(startpos, script.GetTextLength())
            script.previewtxt = self.ScriptChanged(script, return_styledtext=True)[1]

    def SliderRenameToggleTag(self, tagName, newName, isChecked):
        script = self.currentScript
        scriptChanged = self.ScriptChanged(script)
        addedChild = False
        rep = r'[%s=1]' if isChecked else r'[%s=0]'
        newTxt = re.sub(r'\[(?!/)%s(\s*=.*?)*?\]' % tagName, rep % newName, script.GetText())
        newTxt = re.sub(r'\[/%s\]' % tagName, '[/%s]' % newName, newTxt)
        if isChecked and newName.find('>') > -1:
            splitName = newName.split('>')[1]
            newTxt = re.sub(r'\[(?!/)%s(\s*=.*?)*?\]' % splitName, '[%s=0]' % splitName, newTxt)
            addedChild = True
        pos = script.GetCurrentPos()
        script.Freeze()
        script.SetText(newTxt)
        script.GotoPos(pos)
        self.TryThaw(script)
        script.Colourise(0, script.GetTextLength())
        self.UpdateUserSliders()
        if not scriptChanged and not addedChild: # we can set the preview text
            script.previewtxt = self.ScriptChanged(script, return_styledtext=True)[1]
        else:
            scriptChanged = self.ScriptChanged(script)
            if script.previewFilterIdx > 0 or scriptChanged:
                self.SliderShowVideoFrame(userScrolling=not scriptChanged, selfrefreshAVI=scriptChanged, script=script, scriptChanged=scriptChanged)

    def SliderRemoveToggleTag(self, label, tagName=None, isChecked=None):
        script = self.currentScript
        # if checked (filter enabled) we don't need an UpdateAvi if script was not changed before
        if isChecked:
            scriptChanged = self.ScriptChanged(script)
        else: scriptChanged = False
        # then called from filter separator context menu  ( but menu removed, no check if checked posible )
        if not tagName:
            splitFilterName = label.split('(', 1)
            if len(splitFilterName) == 2:
                filterName = splitFilterName[0].strip()
                iFilter = splitFilterName[1].split(')')[0]
                try:
                    x = int(iFilter)
                except ValueError:
                    return
                filterName += ' ' + iFilter
            else:
                splitFilterName = label.split(' - P', 1)
                if len(splitFilterName) == 2:
                    filterName = splitFilterName[0].strip()
                else: filterName = label
        else:
            filterName = tagName # called from tag context menu

        txt = re.sub(r'\[/?%s(\s*=.*?)*?\]' % filterName, '', script.GetText())
        txt = self.stripComment_2(txt)
        #txt = re.sub(r"(#>|\[/?%s(\s*=.*?)*?\])" % filterName, '', script.GetText()) # an empty line
        pos = script.GetCurrentPos()
        script.Freeze()
        script.SetText(txt)
        script.GotoPos(pos)
        script.Thaw()
        script.Colourise(0, script.GetTextLength()) # need new update for scriptChanged
        self.UpdateUserSliders()
        # then no update required, we can set the current text as preview text
        if isChecked and not scriptChanged:
            script.previewtxt = self.ScriptChanged(script, return_styledtext=True)[1]
        else:
            if not scriptChanged:
                scriptChanged = self.ScriptChanged(script)
            if script.previewFilterIdx > 0 or scriptChanged:
                self.SliderShowVideoFrame(userScrolling=not scriptChanged, selfrefreshAVI=scriptChanged, script=script, scriptChanged=scriptChanged)

    def OnSliderAddToggleTag(self, event):
        ctrl = self.lastContextMenuWin
        name = ctrl.GetLabel().lstrip(' -+')
        self.SliderAddToggleTag(name)

    def OnSliderRemoveToggleTag(self, event):
        ctrl = self.lastContextMenuWin
        name = ctrl.GetLabel().lstrip(' -+')
        self.SliderRemoveToggleTag(name)

    def OnSliderWindowsSameWidth(self, event):
        pos = self.videoSplitter.GetSashPosition()
        for i in range(self.scriptNotebook.GetPageCount()):
            self.scriptNotebook.GetPage(i).lastSplitSliderPos = pos

    def OnSliderWindowsSaveWidth(self, event):
        self.options['sliderwindowwidth'] = self.videoSplitter.GetSashPosition() - self.videoSplitter.GetClientSize()[0]

    def OnSliderToggleUpdateMode(self, event):
        self.options['autosliderupdatedirectly'] = not self.options['autosliderupdatedirectly']

    def OnSliderToggleExclusionsFilters(self, event):
        self.slidersShowExclusionFilters = not self.slidersShowExclusionFilters
        self.UpdateUserSliders(forceUpdate=True)

    def addAvsSliderSeparatorNew(self, script, label='', menu=None, row=None, sizer=None):
        if sizer is None:
            sizer = script.sliderSizer
        parent = script.sliderWindow
        # Add a separator
        tempsizer = wx.BoxSizer(wx.VERTICAL)
        if row == 0: border = 0 if wx.VERSION < (2, 9) else intPPI(5)
        else: border = intPPI(10)
        if label == '':
            tempsizer.Add(wx.StaticLine(parent), 0, wx.EXPAND|wx.ALIGN_BOTTOM|wx.TOP, border)
        else:
            staticText = wxp.StaticText(parent, wx.ID_ANY, ' - '+label)
            staticText.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
            def OnLeftDown(event):
                separator = event.GetEventObject()
                self.ToggleSliderFold(separator, separator.IsControlsVisible)
                event.Skip()
            staticText.Bind(wx.EVT_LEFT_DOWN, OnLeftDown)

            if menu is not None:
                staticText.contextMenu = menu
                staticText.Bind(wx.EVT_CONTEXT_MENU, self.OnSlidersContextMenu)
            font = staticText.GetFont()
            font.SetWeight(wx.FONTWEIGHT_BOLD)
            staticText.SetFont(font)
            # Set preview filter color
            if self.currentSliderWindow.customTheme and self.options['usesliderwindowprevfiltercolor'] and label.find(' - P') > 0:
                try:
                    if int(label[-1]) % 2 == 0:
                        staticText.SetForegroundColour(self.currentSliderWindow.forePrevFilter2)
                    else: staticText.SetForegroundColour(self.currentSliderWindow.forePrevFilter)
                except:
                    pass
            tempsizer.Add(staticText, 0, wx.ALIGN_BOTTOM|wx.TOP, border)
            tempsizer.Add(wx.StaticLine(parent), 0, wx.EXPAND|wx.ALIGN_BOTTOM)
        sizer.Add(tempsizer, (row,0), (1,7), wx.EXPAND)
        staticText.controls = []
        staticText.hasNumericalSlider = False
        staticText.IsControlsVisible = True
        script.sliderToggleLabels.append(staticText)
        return staticText

    def ToggleSliderFold(self, separator, fold=True, refresh=True, scroll=True):
        sizer = self.currentScript.sliderSizerNew
        parent = separator.GetParent()
        label = separator.GetLabel().strip(' -+')
        parent.Freeze()
        done = False
        """
        if fold and separator.IsControlsVisible:
            for item in separator.controls:
                sizer.Hide(item)
            separator.SetLabel('+ '+ label)
            separator.IsControlsVisible = False
        elif not separator.IsControlsVisible: # GPo new, 'not fold' and var done
            for item in separator.controls:
                sizer.Show(item)
            separator.SetLabel(' - '+ label)
            separator.IsControlsVisible = True
        """
        # GPo new
        if fold:
            if separator.IsControlsVisible:
                for item in separator.controls:
                    sizer.Hide(item)
                separator.SetLabel('+ '+ label)
                separator.IsControlsVisible = False
                done = True
        elif not separator.IsControlsVisible: # GPo new, 'not fold' and var done
            for item in separator.controls:
                sizer.Show(item)
            separator.SetLabel(' - '+ label)
            separator.IsControlsVisible = True
            done = True
        self.currentScript.SliderFoldsBackup[label] = int(separator.IsControlsVisible)
        if done and refresh:
            sizer.Layout()
            parent.FitInside()
            parent.Refresh()
            # GPo, I do not like it
            if scroll and separator.IsControlsVisible and separator.controls:
                lastitem = separator.controls[-1]
                if lastitem.GetPosition()[1]+lastitem.GetSize()[1] > parent.GetSize()[1]:
                    xscrollpixels, yscrollpixels = parent.GetScrollPixelsPerUnit()
                    pos = parent.CalcUnscrolledPosition(separator.GetPosition())
                    parent.Scroll(-1, (pos[1]-10)/yscrollpixels)
        self.TryThaw(parent)


    # GPo 2021 changed, add context menu
    def createToggleTagCheckboxes(self, script):

        def OnToogleTagContextMenu(event):
            def OnChildSelection(event):
                if ctrlName.find('>') > -1:
                    return
                item = popup.FindItemById(event.GetId())
                label = item.GetLabel()
                if label.find('>') > -1:
                    return
                label = ctrlName + '>' + label
                self.SliderRenameToggleTag(ctrlName, label, ctrl.GetValue())
            def OnRemove(event):
                self.SliderRemoveToggleTag(label='', tagName=ctrlName, isChecked=ctrl.GetValue())
            def OnRemoveChild(event):
                if ctrlName.find('>') < 0:
                    return
                newName = ctrlName.split('>')[0]
                self.SliderRenameToggleTag(ctrlName, newName, ctrl.GetValue())
            def OnRename(event):
                dlg = wx.TextEntryDialog(self, _('Enter new name'), _('Rename toggle tag'), ctrlName)
                ID = dlg.ShowModal()
                if ID == wx.ID_OK:
                    label = dlg.GetValue()
                    if label != '':
                        self.SliderRenameToggleTag(ctrlName, label, ctrl.GetValue())
                dlg.Destroy()
            # get the checkbox
            ctrl = event.GetEventObject()
            ctrlName = ctrl.GetName()
            # create the popup
            popup = wx.Menu()
            id = wx.NewId()
            popup.Append(id, _('Remove'), kind=wx.ITEM_NORMAL)
            self.Bind(wx.EVT_MENU, OnRemove, id=id)
            # create the submenu and add the available tags for child selection
            hasChild = ctrlName.find('>') >= 0
            childMenu = wx.Menu()
            if not hasChild:
                for tag in toggleTags:
                    if ctrlName != tag[0] and tag[0].find('>') < 0:
                        id = wx.NewId()
                        childMenu.Append(id, tag[0], kind=wx.ITEM_NORMAL)
                        self.Bind(wx.EVT_MENU, OnChildSelection, id=id)
            popup.AppendSubMenu(childMenu, _('Add child'))
            id = wx.NewId()
            popup.Append(id, _('Remove child'), kind=wx.ITEM_NORMAL)
            if hasChild: self.Bind(wx.EVT_MENU, OnRemoveChild, id=id)
            else: popup.Enable(id, False)
            popup.AppendSeparator()
            id = wx.NewId()
            popup.Append(id, _('Rename'), kind=wx.ITEM_NORMAL)
            self.Bind(wx.EVT_MENU, OnRename, id=id)
            self.PopupMenu(popup)
            popup.Destroy()

        toggleTags = script.toggleTags
        # First remove all old checkboxes
        script.toggleTagSizer.Clear(deleteWindows=True)
        labels = []
        # Then add the new checkboxes
        for tag in toggleTags:
            label, boolCheck = tag
            if label not in labels:
                checkbox = wx.CheckBox(script.sliderWindow, wx.ID_ANY, _('Toggle "%(label)s" section') % locals(), name=label)
                checkbox.SetValue(boolCheck)
                checkbox.Bind(wx.EVT_CHECKBOX, self.OnToggleTagChecked)
                if not self.options['sliderhidetagmenu']:
                    checkbox.Bind(wx.EVT_CONTEXT_MENU, OnToogleTagContextMenu)
                script.toggleTagSizer.Add(checkbox, 0, wx.BOTTOM, intPPI(12))
                labels.append(label)

    def OnSliderLabelToggleAllFolds(self, event):
        # GPo 2022 changed, use selected as reference
        script = self.currentScript
        ctrl = self.lastContextMenuWin
        label = ctrl.GetLabel().lstrip()
        if label and label[0:1] in ['+','-']:
            self.foldAllSliders = label.startswith('-')
        script.sliderWindow.Freeze()
        for item in script.sliderToggleLabels:
            self.ToggleSliderFold(item, fold=self.foldAllSliders, refresh=False)
        script.sliderSizerNew.Layout()
        script.sliderWindow.FitInside()
        self.TryThaw(script.sliderWindow)
        self.foldAllSliders = not self.foldAllSliders

    def OnSliderLabelEditDatabase(self, event):
        script = self.currentScript
        ctrl = self.lastContextMenuWin
        name = ctrl.GetLabel().lstrip(' -+').split()[0]
        lowername = name.lower()
        is_short = script.avsfilterdict[lowername][3]
        if is_short:
            lowername = is_short
            name = script.avsfilterdict[lowername][2]
        calltip = script.avsfilterdict[lowername][0]
        dlg = AvsFilterAutoSliderInfo(self, self, name, calltip)
        ID = dlg.ShowModal()
        # Set the data
        if ID == wx.ID_OK:
            newCalltip = dlg.GetNewFilterInfo()
            if newCalltip == calltip:
                    return
            if lowername in self.options['filteroverrides']:
                ftype = self.options['filteroverrides'][lowername][2]
            elif lowername in self.optionsFilters:
                ftype = self.optionsFilters[lowername][2]
            else: # add a new user function definition for functions defined in the current script
                ftype = 3
            self.options['filteroverrides'][lowername] = (name, newCalltip, ftype)
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
            self.defineScriptFilterInfo()
            for i in xrange(self.scriptNotebook.GetPageCount()):
                self.scriptNotebook.GetPage(i).Colourise(0, 0)
        dlg.Destroy()

    def OnSliderLabelSettings(self, event):
        self.ShowOptions(startPageIndex=4)

    def GetAutoSliderInfo(self, script, scripttxt=None):
        script.OnStyleNeeded(None, forceAll=True)
        autoSliderInfo = []
        if script.AVI.IsErrorClip() or not self.options['autoslideron']:
            script.autoSliderInfo = []
            return
        nameDict = {}
        posA = posB = 0
        lastpos = script.GetTextLength()
        prevFilter = ''
        prevFilterIdx = 0
        while posB < lastpos:
            posB = script.WordEndPosition(posA, 1)
            word = script.GetTextRange(posA, posB)
            #~ if word.lower() in script.keywords:
            # GPo new
            if prevFilterIdx < 5:
                if prevFilter and script.GetLine(script.LineFromPosition(posA)).lstrip().startswith('**/'):
                    prevFilter = ''
                elif word[:11] == 'avsp_filter' and script.GetLine(script.LineFromPosition(posA)).startswith('/**avsp_filter'):
                    prevFilterIdx += 1
                    prevFilter = ' - P'+ str(prevFilterIdx)

            if script.GetStyleAt(posA) in script.keywordStyleList:
                filterInfo = self.GetFilterArgMatchedInfo(script, posA)
                if filterInfo is not None:
                    wordlower = word.lower()
                    if not wordlower in nameDict:
                        nameDict[wordlower] = 1
                        filterName = word
                    else:
                        nameDict[wordlower] += 1
                        filterName = '%s (%i)' % (word, nameDict[wordlower])
                    if filterInfo:
                        autoSliderInfo.append((filterName,filterInfo,prevFilter))
            posA = posB+1
        script.autoSliderInfo = autoSliderInfo

    def GetFilterArgMatchedInfo(self, script, startwordpos):
        filterMatchedArgs = script.GetFilterMatchedArgs(startwordpos)
        returnInfo = []
        for index, info in enumerate(filterMatchedArgs):
            calltipIndex, calltipArgEntry, argname, argvalue = info
            if argvalue.count(self.sliderOpenString) > 0:
                continue
            if not calltipArgEntry:
                return []
            if not argname:
                argname = None
            returnInfo.append((calltipArgEntry, argname, argvalue, index))
        return returnInfo

    def GetScriptSliderProperties(self, scripttxt, stripComments=True):
        # First strip out comments from scripttxt
        if stripComments:
            scripttxt = re.sub(r'#.*?\n', r'\n', '%s\n' % scripttxt)
        # Then strip out toggle tags
        scripttxt = self.cleanToggleTags(scripttxt)
        # Then find any user sliders
        sliderTexts = self.regexp.findall(scripttxt)
        sliderProperties = []
        for text in sliderTexts:
            items = [s.strip() for s in text.lstrip(self.sliderOpenString).rstrip(self.sliderCloseString).split(',')]
            if len(items) == 4:
                info = (items[0], items[1], items[2])
            else:
                info = None
            sliderProperties.append(info)
        return sliderTexts, sliderProperties

    def GetScriptToggleTagProperties(self, scripttxt, stripComments=True):
        # First strip out comments from scripttxt
        if stripComments:
            #~scripttxt = re.sub(r'#.*?\n', r'\n', '%s\n' % scripttxt)
            scripttxt = re.sub(r'#(?!>).*?\n', r'\n', '%s\n' % scripttxt) # GPo, exclude comment if # followed by >  (#>)
        # Then find any toggle tags
        toggleTags = []
        for endtag in re.findall('\[/.*?\]', scripttxt):
            tagname = endtag[2:-1]
            expr = re.compile('\[%s.*?\].*?\[/%s\]' % (tagname, tagname), re.IGNORECASE|re.DOTALL)
            try:
                txt = expr.findall(scripttxt)[0]
                toggleTags.append((tagname, self.boolToggleTag(txt)))
            except IndexError:
                pass
        return toggleTags

    def stripComment_2(self, txt):
        newTxt = ''
        for line in txt.split('\n'):
            if line.strip() == '#>':
                continue
            newTxt += line + '\n'
        return newTxt.rstrip()

    def MakePreviewScriptFile(self, script):
        txt = self.getCleanText(script.GetText())
        txt = self.GetEncodedText(txt, bom=True)
        txt = self.stripComment_2(txt)
        # Construct the filename of the temporary avisynth script
        dirname = self.GetProposedPath(only='dir')
        if os.path.isdir(dirname):
            altdir_tried = False
        else:
            dirname = self.programdir
            altdir_tried = True
        while True: # os.access doesn't work properly on Windows, let's just try
            previewname = os.path.join(dirname, 'preview.avs')
            i = 1
            while os.path.exists(previewname):
                previewname = os.path.join(dirname, 'preview%i.avs' % i)
                i = i+1
            try:
                with open(previewname, 'wb') as f:
                    f.write(txt)
                    f.close()
            except IOErroras as err: # errno 13 -> permission denied
                if err.errno != 13 or altdir_tried:
                    raise
                dirname = self.programdir
                altdir_tried = True
            else:
                return previewname

    def GetFitWindowSize(self):
        wA, hA = self.videoWindow.GetSize()
        #wc, hc = self.videoWindow.GetClientSize()
        w, h = wA - 2 * self.xo, hA - 2 * self.yo
        #sbarH = self.videoWindow.HasScrollbar(wx.HORIZONTAL)

        if not self.separatevideowindow:
            if self.zoomwindow and not self.previewWindowVisible:
                w = h = None
            else:
                if self.previewWindowVisible:
                    if self.zoomwindowfill: # try do elemenate the gap if scrollbar bottom not visible
                        if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
                            splitpos = (self.mainSplitter.GetSashPosition() - self.mainSplitter.GetClientSize()[1])
                            h = abs(splitpos) - (2 * self.yo  + 5 + self.mainSplitter.GetSashSize()/2)
                            if not self.options['hidescrollbars']:
                                if not self.splitView and self.currentScript.AVI:
                                    factor = float(float(self.currentScript.AVI.DisplayHeight) / h)
                                    if self.currentScript.AVI.DisplayWidth / factor > wA - \
                                            (self.toggleSliderWindowButton.GetSize()[0] + 4):
                                        h -= wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) - 2
                                else:
                                    h -= wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) - 2
                        elif not self.options['hidescrollbars']:
                            h -= wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) - 2
                        if h < 4: h = None
                        if w < 4: w = None
                        return (w, h)
                    else:
                        splitpos = self.mainSplitter.GetSashPosition() - self.mainSplitter.GetClientSize() \
                                   [self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL]

                # can be wrong if not preview visible
                elif self.currentScript.lastSplitVideoPos is not None:
                    splitpos = self.currentScript.lastSplitVideoPos
                elif isinstance(self.oldLastSplitVideoPos, int): #is not None:
                    splitpos = self.oldLastSplitVideoPos
                else:
                    splitpos = self.GetMainSplitterNegativePosition()

                if self.mainSplitter.GetSplitMode() == wx.SPLIT_HORIZONTAL:
                    h = abs(splitpos) - (2 * self.yo + 5 + self.mainSplitter.GetSashSize()/2)
                else:
                    w = abs(splitpos) - (2 * self.xo + 5 + self.mainSplitter.GetSashSize()/2 +
                                         self.toggleSliderWindowButton.GetSize()[0])

        elif self.zoomwindowfill: # seperate video window
            if not self.options['hidescrollbars']:
                if not self.splitView and self.currentScript.AVI:
                    factor = float(float(self.currentScript.AVI.DisplayHeight) / h)
                    if self.currentScript.AVI.DisplayWidth / factor > wA - \
                            (self.toggleSliderWindowButton.GetSize()[0] + 4):
                        h -= wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) - 2
                else:
                    h -= wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) - 2

        if h < 4: h = None
        if w < 4: w = None
        return (w, h)

    def ErrorMessage_GetFrame(self, script, frame_nr):
        if script.AVI is None:
            return
        if not isinstance(frame_nr, int) or frame_nr < 0:
            frame_nr = 0
        err = script.AVI.clip.get_error()
        if not err:
            err = 'Clip error unknown'
        wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=frame_nr),
                           err)), _('Error'), style=wx.OK|wx.ICON_ERROR)

    # make a snapshot of the video window and paint it on thread progress dialog (wx.GetApp().SaveYieldFor)
    def GetVideoWindowBitmap(self):
        if not self.previewWindowVisible or not self.UseAviThread or self.options['threadprogressopt'] < 1:
            return False
        #if self.paintedScript is not self.lastUpdateScript:
            #return
        # then on open file and tab change currentScript.AVI is None and Update forces RepaintAVIFrame, also no client picture.
        #self.videoWindow.Update()
        try:
            clientDC = wx.ClientDC(self.videoWindow)
            w,h = clientDC.GetSize()
            mdc = wx.MemoryDC()
            self.bmpVideo = wx.EmptyBitmap(w,h)
            mdc.SelectObject(self.bmpVideo)
            mdc.Blit(0,0,w,h,clientDC,0,0)
            #img = self.bmpVideo.ConvertToImage()
            #img.SaveFile('E:\\Temp\\bmpvideo.bmp', wx.BITMAP_TYPE_BMP) # testing the area
        except:
            return False
        return True

    def PaintAVIFrame(self, inputdc, script, frame, shift=True, isPaintEvent=False):
        if script.AVI is None:
            if isPaintEvent:
                if self.options['use_customvideobackground']:
                    backgroundcolor = self.options['videobackground']
                else:
                    backgroundcolor = self.videoWindow.GetBackgroundColour()

                dc = wx.ClientDC(self.videoWindow)
                dc.SetBrush(wx.Brush(backgroundcolor))
                dc.DrawRectangle(0,0, self.videoWindow.GetSize()[0], self.videoWindow.GetSize()[1])
                dc.SetFont(wx.Font(intPPI(48), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))
                if backgroundcolor != wx.BLACK:
                    dc.SetTextForeground(wx.BLACK)
                else:
                    dc.SetTextForeground(wx.Colour(160,160,160))
                dc.DrawLabel('Loading in progress...', self.videoWindow.GetClientRect(), wx.ALIGN_CENTER)
                if __debug__:
                    print>>sys.stderr, 'Error in PaintAVIFrame: script is None'
            return

        if self.zoomwindow or self.zoomfactor != 1 or self.flip:
            self.videoWindow.DoPrepareDC(inputdc)
            if (self.zoomwindow or self.zoomfactor != 1) and self.flip:
                inputdc.SetBrush(wx.RED_BRUSH)
            elif self.flip:
                inputdc.SetBrush(wx.CYAN_BRUSH)
            inputdc.DrawPolygon([wx.Point(0,0), wx.Point(8,0), wx.Point(0,8)])
        if shift:
            inputdc.SetDeviceOrigin(self.xo, self.yo)
        else:
            inputdc.SetDeviceOrigin(0, 0)
        if self.zoomfactor == 1 and not self.flip and not self.zoomwindow: # and not self.playing_video:
            if self.cropDialog.IsShown() or self.trimDialog.IsShown():
                w = script.AVI.DisplayWidth
                h = script.AVI.DisplayHeight
                dc = wx.MemoryDC()
                bmp = wx.EmptyBitmap(w,h)
                dc.SelectObject(bmp)
                if not script.AVI.DrawFrame(frame, dc):
                    self.ErrorMessage_GetFrame(script, frame)
                    return
                self.PaintCropRectangles(dc, script)
                self.PaintTrimSelectionMark(dc, script, frame)
                # DoPrepareDC causes NameError in wx2.9.1 and fixed in wx2.9.2
                self.videoWindow.DoPrepareDC(inputdc)
                inputdc.Blit(0, 0, w, h, dc, 0, 0)
            elif self.splitView:
                if not self.PaintSplitView(inputdc, frame, isPaintEvent):
                    return
            elif self.snapShotIdx > 0:
                self.PaintSnapShot(inputdc, script)
            else:
                self.videoWindow.DoPrepareDC(inputdc)
                if not script.AVI.DrawFrame(frame, inputdc):
                    self.ErrorMessage_GetFrame(script, frame)
                    return
        elif self.splitView:
            if not self.PaintSplitView(inputdc, frame, isPaintEvent):
                return
        elif self.snapShotIdx > 0:
            self.PaintSnapShot(inputdc, script)
        else:
            dc = wx.MemoryDC()
            dc.Clear()
            w = script.AVI.DisplayWidth
            h = script.AVI.DisplayHeight
            if isPaintEvent and self.bmpVideo:
                dc.SelectObject(self.bmpVideo)
            else:
                bmp = wx.EmptyBitmap(w,h)
                dc.SelectObject(bmp)
                if not script.AVI.DrawFrame(frame, dc):
                    self.ErrorMessage_GetFrame(script, frame)
                    return
                if self.flip:
                    img = bmp.ConvertToImage()
                    if 'flipvertical' in self.flip:
                        img = img.Mirror(False)
                    if 'fliphorizontal' in self.flip:
                        img = img.Mirror()
                    bmp = wx.BitmapFromImage(img)
                    dc.SelectObject(bmp)
                self.PaintTrimSelectionMark(dc, script, frame)
                if self.cropDialog.IsShown():
                    self.zoom_antialias = False
                    self.PaintCropRectangles(dc, script)
                self.bmpVideo = bmp
            """
            # GPo, do not antialias if playback or frame step or mouse move, or zoom settings changed
            # only if isPaintEvent and self.zoom_antialias not disabled
            # in ShowVideoFrame() IdleCall.append(videoWindow.Refresh) fires OnIdle the antialias refresh
            """
            if (self.zoomfactor != 1 or self.zoomwindow) and (self.zoom_antialias and isPaintEvent):
                inputdc = wx.GCDC(inputdc)
            # DoPrepareDC causes NameError in wx2.9.1 and fixed in wx2.9.2
            self.videoWindow.DoPrepareDC(inputdc)
            inputdc.SetUserScale(self.zoomfactor, self.zoomfactor)
            inputdc.Blit(0, 0, w, h, dc, 0, 0)

            """ I think it's anymore needed since the zoom is calculated after the layout
            if self.firstToggled and isPaintEvent and self.zoomwindow:
                self.firstToggled = False
                wx.CallAfter(self.ShowVideoFrame, forceLayout=True)
            """
        self.paintedframe = frame
        return True

    def PaintTrimSelectionMark(self, dc, script, frame):
        if self.trimDialog.IsShown() and self.markFrameInOut:
            boolInside = self.ValueInSliderSelection(frame)
            if boolInside is not None:
                dc.SetLogicalFunction(wx.COPY)
                dc.SetPen(wx.Pen(wx.BLACK, 2))
                if boolInside:
                    dc.SetBrush(wx.GREEN_BRUSH)
                    dc.DrawCircle(25, 25, 20)
                else:
                    dc.SetBrush(wx.RED_BRUSH)
                    dc.DrawCircle(25, 25, 20)

    def PaintCropRectangles(self, dc, script):
        '''Paint the crop editor's rectangles'''
        w = script.AVI.Width
        h = script.AVI.Height
        left = self.cropValues['left']
        top = self.cropValues['top']
        mright = self.cropValues['-right']
        mbottom = self.cropValues['-bottom']
        dc.SetLogicalFunction(wx.INVERT)
        if 'flipvertical' in self.flip:
            top, mbottom = mbottom, top
        if 'fliphorizontal' in self.flip:
            left, mright = mright, left
        if top > 0:
            dc.DrawRectangle(0, -1, w, top+1)
        if mbottom > 0:
            dc.DrawRectangle(0, h - mbottom, w, h)
        if left > 0:
            dc.DrawRectangle(-1, top, left+1, h - mbottom - top)
        if mright > 0:
            dc.DrawRectangle(w - mright, top, w, h - mbottom - top)
        self.oldCropValues = self.cropValues

    # GPo 2020
    def PaintSplitView(self, inputdc, frame, isPaintEvent):
        def Error():
            self.splitView = False
            self.snapShotIdx = 0
            self.refreshAVI = True
            if self.currentScript.AVI.IsErrorClip():
                self.zoomfactor = 1
            if wx.IsBusy():
                wx.EndBusyCursor()
            self.ShowVideoFrame(forceLayout=True)

        if self.splitView_next:           # next script as second script
            script = self.currentScript   # self.currentscript should have no errors, no check needed
            if script.AVI is None:
                Error()
                return

            script2, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() + 1)
            if script2 is None or script2.AVI is None:
                Error()
                return
            nextScript = script2
        else:                             # prevouse script as second script
            script2 = self.currentScript
            if script2.AVI is None:
                Error()
                return

            script, index = self.getScriptAtIndex(self.scriptNotebook.GetSelection() - 1)
            if script is None or script.AVI is None:
                Error()
                return
            nextScript = script

        self.splitView_nextScript = nextScript
        frame2 = curframe = frame

        # freeze frame ( -1 must check > pyavs > _GetFrame > if self.current_frame == frame: )
        #if (self.splitView_freeze or wx.GetKeyState(wx.WXK_ALT)) and (nextScript.AVI.current_frame > -1):
        if self.splitView_freeze and (nextScript.AVI.current_frame > -1):
            if self.splitView_next: # So split view partner is to the right
                #frame2 = nextScript.lastFramenum
                frame2 = nextScript.AVI.current_frame
                nextScript.group_frame = frame2
                self.currentScript.group_frame = frame

                nextScript.lastFramenum = frame2
                self.currentScript.lastFramenum = frame
            else:
                frame = nextScript.AVI.current_frame
                nextScript.group_frame = frame
                self.currentScript.group_frame = frame2

                nextScript.lastFramenum = frame
                self.currentScript.lastFramenum = frame2

        else:
            nextScript.lastFramenum = frame
            self.currentScript.lastFramenum = frame
            # groups
            if self.currentScript.group is not None and self.currentScript.group == nextScript.group:
                if self.options['applygroupoffsets'] or self.splitView_freeze:
                    offset = nextScript.group_frame - self.currentScript.group_frame
                    if self.splitView_next:
                        frame2 = max(0, frame + offset)
                    else:
                        frame = max(0, frame + offset)
            elif self.splitView_freeze:
                offset = nextScript.group_frame - self.currentScript.group_frame
                if self.splitView_next:
                    frame2 = max(0, frame + offset)
                else:
                    frame = max(0, frame + offset)

        if not isPaintEvent: # check only once on new frame

            if self.currentScript.AVI.current_frame != curframe: # only thread if frame != curr
                #print('getFrame')
                if not self.GetAviDisplayFrame(self.currentScript, curframe, showWarn=True, srcFrame=True):
                    Error()
                    return
            if self.currentScript.AVI.display_clip.get_error():
                Error()
                return

            filterInfo = None

            if script.resizeFilter[0] != script2.resizeFilter[0]: # this happens if resize zoom turned off with normal zoom (menu or shortcut)
                uscript = script if script.resizeFilter[0] else script2
                self.DisableResizeFilter(uscript) # also self.UpdateScriptAVI

            nextScript.refreshAVI = True # now check the second script on each frame, if was only checked on splitView enabled
            if self.UpdateScriptAVI(script=nextScript, forceRefresh=False, prompt=False, resizeFilterInfo=filterInfo, showCursor=True) is None:
                Error()
                return

            if self.splitView_next:
                """
                if nextScript.AVI.current_frame != frame2:
                    print('getNextScriptFrame\ncurrFrame=%i\ngetFrame=%i' % (nextScript.AVI.current_frame, frame2))
                if nextScript is not script2:
                    print('wrong script2')
                """
                if not self.GetAviDisplayFrame(nextScript, frame2, showWarn=True, srcFrame=True): # get the frame in thread is thread enabled
                    Error()
                    return
            else:
                """
                if nextScript.AVI.current_frame != frame:
                    print('getNextScriptFrame\ncurrFrame=%i\ngetFrame=%i' % (nextScript.AVI.current_frame, frame))
                if nextScript is not script:
                    print('wrong script')
                """
                if not self.GetAviDisplayFrame(nextScript, frame, showWarn=True, srcFrame=True): # get the frame in thread is thread enabled
                    Error()
                    return

            if nextScript.AVI.display_clip.get_error():
                Error()
                return

            # Check same size (height can be differ, but not a nice view)
            w = script.AVI.DisplayWidth
            h = script.AVI.DisplayHeight
            if script2.AVI.DisplayWidth != w or script2.AVI.DisplayHeight != h:
                wx.MessageBox(_('Both videos must have the same width and height.') + '\nvideo1: %ix%i, video2: %ix%i' %
                    (w,h,script2.AVI.DisplayWidth, script2.AVI.DisplayHeight),'Split View Error',parent=self)
                Error()
                return

        else:
            w = script.AVI.DisplayWidth
            h = script.AVI.DisplayHeight

        x,y = self.videoWindow.GetViewStart()  # source x start point, must recalc on zoom

        # wx.ViewStart None if it 0... Why?
        if not x: x = 0
        if not y: y = 0
        cx,cy = inputdc.GetSize()
        if not self.splitViewEx:
            xx,yy = x,y
            if xx != 0:
                xx = max(int(xx/self.zoomfactor) - self.xo*2, 0)

            xxx = min(round(xx + cx/2.0/self.zoomfactor),w)  # recalc the target offset

            # bitmap width for both script's
            self.extended_width = (w*2) if w*2*self.zoomfactor <= cx else w + int(cx/2.0/self.zoomfactor)
        else:
            self.extended_width = w
            int5 = intPPI(5)
            if self.splitViewEx_posx is None:
                self.splitViewEx_posx = min(cx//2, w//2*self.zoomfactor)
            self.splitViewEx_posx = max(min((w*self.zoomfactor)-int5, self.splitViewEx_posx), int5)
            xxx = int(float(self.splitViewEx_posx/self.zoomfactor) + float(x/self.zoomfactor))

        # draw the first script or snapshot bitmap
        dc = wx.MemoryDC()
        dc.Clear()
        bmp = wx.EmptyBitmap(self.extended_width, h)
        dc.SelectObject(bmp)

        # locking for snapshot
        isShot = 0
        if self.snapShotIdx > 0:
            if self.snapShotIdx == 1:
                sbmp = self.currentScript.snapShots['shot1'][1]
            elif self.snapShotIdx == 2:
                sbmp = self.currentScript.snapShots['shot2'][1]
            try:
                if sbmp and (sbmp.GetWidth() == w and sbmp.GetHeight() == h):
                    isShot = 1 if script == self.currentScript else 2
            except:
                pass

        if not self.splitViewEx:
            # I don't know if it faster... 3 extra calls and calculation
            _x = max(int(x/self.zoomfactor)-int(10/self.zoomfactor),0)
            _y = max(int(y/self.zoomfactor)-int(10/self.zoomfactor),0)
            dc.DestroyClippingRegion()
            dc.SetClippingRegion(_x-self.xo,_y-self.yo,xxx+30+self.xo-_x,(h+10)+self.xo-_y)

        if isShot == 1: # if snapshot and currentScript the first drawing
            dc.DrawBitmap(sbmp, 0, 0)
        else:
            #~if not script.AVI.DrawFrame(frame, dc):
            if not script.AVI.DrawFrame(frame, dc, size=wx.Size(xxx,h)): # Hm.. faster?
                self.splitView = False
                self.HidePreviewWindow()
                self.ErrorMessage_GetFrame(script, frame)
                return

        if self.splitViewEx:
            if isShot == 2: # if snapshot and currentScript the second drawing we must draw with offset... bad we need extra memory
                dc2 = wx.MemoryDC()
                dc2.Clear()
                dc2.SelectObject(sbmp)
                dc.Blit(xxx, 0, xxx, h, dc2, xxx, 0)
            else:
                if not script2.AVI.DrawFrame(frame2, dc, offset=wx.Point(xxx,0), srcXY=wx.Point(xxx, 0)):
                    self.splitView = False
                    self.HidePreviewWindow()
                    self.ErrorMessage_GetFrame(script2, frame2)
                    return
            # if zoom 1, it's faster and flicker free we draw the line on the dc here
            # but if zoom != 1 the line will also zoom, so we need we draw the line later
            if self.zoomfactor == 1:
                dc.SetPen(wx.Pen(wx.BLACK, intPPI(4)))
                dc.DrawLine(self.splitViewEx_posx+x, y, self.splitViewEx_posx+x, min(y+cy,y+(h*self.zoomfactor)))
                self.OnEraseBackground()
        else:
            dc.DestroyClippingRegion()

            # draw with offset the second script or snapshot over the first bitmap
            if isShot == 2: # if snapshot and currentScript the second drawing we must draw with offset... bad we need extra memory
                dc2 = wx.MemoryDC()
                dc2.Clear()
                dc2.SelectObject(sbmp)
                dc.Blit(xxx, 0, w-xx, h, dc2, xx, 0)
            else:
                dc.SetClippingRegion((xxx-_x)-20,_y-20,self.extended_width+30-(xxx-_x) ,(h+20)-_y)
                if not script2.AVI.DrawFrame(frame2, dc ,offset=wx.Point(xxx,0), srcXY=wx.Point(xx,0)):
                    self.splitView = False
                    self.HidePreviewWindow()
                    self.ErrorMessage_GetFrame(script2, frame2)
                    return
                dc.DestroyClippingRegion()

        # now set zoom and virtual size and blit the output
        try:
            self.videoWindow.DoPrepareDC(inputdc)
        except:
            self.videoWindow.PrepareDC(inputdc)

        if self.zoomfactor != 1 or self.zoomwindow:
            vsx = int(self.extended_width*self.zoomfactor) + self.xo * 2
            if self.zoomwindowfit:
                self.videoWindow.SetVirtualSize((0, 0))
            elif self.zoomwindowfill:
                self.videoWindow.SetVirtualSize((vsx, 0))
            else:
                self.videoWindow.SetVirtualSize((vsx, int(h*self.zoomfactor) + self.yo * 2))
            if self.zoom_antialias and isPaintEvent:
                inputdc = wx.GCDC(inputdc)
            inputdc.SetUserScale(self.zoomfactor, self.zoomfactor)
        else:
            vsx = self.extended_width + (self.xo * 2)
            if self.videoWindow.GetVirtualSize()[0] != vsx:
                self.videoWindow.SetVirtualSize((vsx, h + self.yo * 2))

        inputdc.Blit(0, 0, self.extended_width, h, dc, 0, 0)

        if self.splitViewEx and self.zoomfactor != 1: # draw the line now
            inputdc.SetUserScale(1, 1)
            inputdc.SetPen(wx.Pen(wx.BLACK, intPPI(4)))
            inputdc.DrawLine(self.splitViewEx_posx+x, y, self.splitViewEx_posx+x, min(y+cy,y+(h*self.zoomfactor)))
            self.OnEraseBackground()

        if isShot > 0:
            if self.zoomfactor != 1:
                inputdc.SetUserScale(1, 1)
            inputdc.SetFont(wx.Font(pointSize=intPPI(12), family=wx.FONTFAMILY_DEFAULT, style=wx.FONTSTYLE_NORMAL, weight=wx.FONTWEIGHT_BOLD))
            #fw,fh = inputdc.GetTextExtent('Snapshot 2') # when draw label filled
            inputdc.SetTextForeground(wx.YELLOW)
            if isShot == 1:
                #inputdc.DrawLabel("Snapshot " + str(self.snapShotIdx),(x+2,y+2,x+fh+4,y+fw+4))
                inputdc.DrawText("Snapshot " + str(self.snapShotIdx), x+2, y+2)
            else:
                #inputdc.DrawLabel("Snapshot " + str(self.snapShotIdx),(int(xxx*self.zoomfactor)+2,y+2,int(xxx*self.zoomfactor)+fh+4,y+fw+4))
                inputdc.DrawText("Snapshot " + str(self.snapShotIdx),int(xxx*self.zoomfactor)+2,y+2)
        return True

    def PaintSnapShot(self, inputdc, script):
        if self.snapShotIdx == 1: #~and script.snapShots['shot1'][1]:
            bmp = script.snapShots['shot1'][1]
        elif self.snapShotIdx == 2: #~and script.snapShots['shot2'][1]:
            bmp = script.snapShots['shot2'][1]
        else:
            bmp = None
        w = script.AVI.DisplayWidth
        h = script.AVI.DisplayHeight
        if not bmp or (bmp.GetWidth() != w or bmp.GetHeight() != h):
            self.snapShotIdx = 0
            if bmp and bmp.GetWidth() != w or bmp.GetHeight() != h:
                wx.MessageBox(_('Snapshot dimensions different: %ix%i') % (bmp.GetWidth(), bmp.GetHeight()))
            else:
                wx.Bell()
            self.videoWindow.Refresh()
            return
        dc = wx.MemoryDC()
        """ Flicker free but CPU usage higher and memory doubled
        if self.zoomfactor == 1:
            dc.SelectObject(bmp.GetSubBitmap(wx.Rect(0, 0, *bmp.Size)))
        else:
        """
        dc.SelectObject(bmp)
        try:
            self.videoWindow.DoPrepareDC(inputdc)
        except:
            self.videoWindow.PrepareDC(inputdc)

        x,y = self.videoWindow.GetViewStart()
        if self.zoomfactor != 1:
            if self.zoom_antialias:
                inputdc = wx.GCDC(inputdc)
            inputdc.SetUserScale(self.zoomfactor, self.zoomfactor)
            inputdc.Blit(0, 0, w, h, dc, 0, 0)
            if self.zoom_antialias == '': # wait for ResetZoomAntialias
                return
            inputdc.SetUserScale(1, 1)
            inputdc.SetFont(wx.Font(pointSize=12, family=wx.FONTFAMILY_DEFAULT, style=wx.FONTSTYLE_NORMAL, weight=wx.FONTWEIGHT_BOLD))
            inputdc.SetTextForeground(wx.YELLOW)
            #inputdc.SetTextBackground(wx.BLACK)
            #inputdc.SetBackgroundMode(wx.BRUSHSTYLE_SOLID)
            inputdc.DrawLabel("Snapshot " + str(self.snapShotIdx),(x+2,y+2,x+52,y+102))
        else:
            #dc.SetFont(wx.Font(pointSize=12, family=wx.FONTFAMILY_DEFAULT, style=wx.FONTSTYLE_NORMAL, weight=wx.FONTWEIGHT_BOLD))
            #dc.SetTextForeground(wx.YELLOW)
            #dc.DrawLabel("Snapshot " + str(self.snapShotIdx),(x+2,y+2,x+52,y+102))
            inputdc.SetFont(wx.Font(pointSize=12, family=wx.FONTFAMILY_DEFAULT, style=wx.FONTSTYLE_NORMAL, weight=wx.FONTWEIGHT_BOLD))
            inputdc.SetTextForeground(wx.YELLOW)
            #inputdc.SetTextBackground(wx.BLACK)
            #inputdc.SetBackgroundMode(wx.BRUSHSTYLE_SOLID)
            inputdc.Blit(0, 0, w, h, dc, 0, 0)
            inputdc.DrawLabel("Snapshot " + str(self.snapShotIdx),(x+2,y+2,x+52,y+102))

    """ # Not used
    def DrawFrameProps(self, script, inputdc):
        inputdc.SetFont(wx.Font(pointSize=9, family=wx.FONTFAMILY_DEFAULT, style=wx.FONTSTYLE_NORMAL, weight=wx.FONTWEIGHT_BOLD))
        inputdc.SetTextForeground(wx.YELLOW)
        inputdc.SetTextBackground(wx.BLACK)
        inputdc.SetBackgroundMode(wx.BRUSHSTYLE_SOLID)
        inputdc.DrawLabel(script.AVI.properties,(10,10,1000,1000))
    """
    def PaintCropWarnings(self, spinCtrl=None):
        script = self.currentScript
        keys = ('left', 'top', '-right', '-bottom')
        if spinCtrl is not None:
            keys = [key for key in keys if self.cropDialog.ctrls[key] == spinCtrl]
        self.cropDialog.boolInvalidCrop = False
        for key in keys:
            labelCtrl = self.cropDialog.ctrls[key+'Label']
            textCtrl = self.cropDialog.ctrls[key]
            value = textCtrl.GetValue()
            colorspace = script.AVI.Colorspace.lower()
            if (colorspace in ('yuy2', 'yv16') and key in ('left', '-right') and value % 2 or
                colorspace == 'yv411' and key in ('left', '-right') and value % 4 or
                colorspace == 'yv12' and value % 2):
                    labelCtrl.SetForegroundColour('red')
                    self.cropDialog.boolInvalidCrop = True
            else:
                labelCtrl.SetForegroundColour(wx.NullColour)
            labelCtrl.Refresh()

    # Use it after first join failed
    def TH_WaitForFrame(self, script, th, nr):
        '''
        Use this before you call this routine
        # th = threading.Thread(target=GetFrame, args=(script, framenum,))
        # th.daemon = True
        # script.AviThread = th
        # th.start()
        # th.join(10)
        # TH_WaitForFrame()
        '''
        if th.isAlive():
            disabler = wx.WindowDisabler()
            if self.progressShown:
                wx.GetApp().ProcessIdle() # close clip progress dialog
            i = 0
            msgShown = False
            if self.ClipRefreshPainter:
                #evtloop = wx.EventLoop()
                #ea = wx.EventLoopActivator(evtloop)
                self.videoWindow.SetDoubleBuffered(True)
                if self.IsIconized():
                    sash = self.mainSplitter.GetSashPosition()
                    self.Iconize(False)
                    self.mainSplitter.SetSashPosition(sash)
                    try:
                        wx.GetApp().SafeYieldFor(self.videoWindow, wx.wxEVT_PAINT)
                    except:
                        pass
            msg = utils.resource_str_threadwait
            msg_1 = msg if self.WinVersion < 7 else ''

            if self.ClipRefreshPainter and (self.options['threadprogressopt'] == 2 and not self.progressShown):
                progress = None
            else:
                progress = wx.ProgressDialog(_('Waiting for frame {0}'.format(nr)),msg_1,10, self,
                            style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
            try:
                while th.isAlive():
                    if not progress and i % 3 == 0 and wx.GetKeyState(wx.WXK_CONTROL):
                        progress = wx.ProgressDialog(_('Waiting for frame {0}'.format(nr)),msg_1,10,self,
                                    style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                    if progress:
                        c,s = progress.Pulse()
                        if not c:             # user abort
                            if i > 10: break
                            else:
                                msgShown = True
                                progress.Pulse(msg)
                        if not msgShown and i > 10: # show msg
                            msgShown = True
                            progress.Pulse(msg)
                    i += 1
                    if self.ClipRefreshPainter and i % 5 == 0:
                        if wx.GetApp().Pending():
                            pass
                        #if evtloop.Pending():
                            #pass
                    th.join(0.5)
            finally:
                del disabler
                if self.ClipRefreshPainter:
                    #del ea
                    wx.GetApp().SafeYieldFor(self, wx.wxEVT_TIMER)
                    self.videoWindow.SetDoubleBuffered(False)
                    self.ClipRefreshPainter = False
                if progress:
                    progress.Destroy()
                if th.isAlive():
                    self.Thread_List.append((th, None))
                    return False
        script.AviThread = None
        return True

    # If srcFrame then the frames is given from display clip and the source clip,
    # then also the frame properties are read when reading is switched on
    # If not srcFrame then the AVI.current_frame is not updatet !
    def GetAviDisplayFrame(self, script, nr, showWarn=True, srcFrame=False):
        def GetFrame(script, nr, srcFrame):
            try:
                if not srcFrame:
                    script.AVI.display_clip.get_frame(nr)
                else:
                    script.AVI._GetFrame(nr)
            except:
                pass

        # return false if AVI thread running
        if self.AviThread_Running(script, prompt=showWarn):
            return False

        # single frame thread for each script (with events and lock)
        if self.UseNewFrameThread:
            return self.GetAviDisplayFrame2(script, nr, showWarn, False, srcFrame)

        if not self.UseAviThread:
            if not srcFrame:
                script.AVI.display_clip.get_frame(nr)
            else:
                script.AVI._GetFrame(nr)
            return True

        # new thread for each frame (the first version)
        th = threading.Thread(target=GetFrame, args=(script, nr, srcFrame,))
        th.daemon = True
        script.AviThread = th
        th.start()
        _t = time.time() + 2.0
        wx.MilliSleep(1)
        while th.isAlive() and time.time() <= _t: # its faster as join
            wx.MilliSleep(1)

        if th.isAlive():
            if self.ClipRefreshPainter: # it's only on first frame after creating a clip
                self.videoWindow.SetDoubleBuffered(True)
                disabler = wx.WindowDisabler()
                #evtloop = wx.EventLoop()
                #ea = wx.EventLoopActivator(evtloop)
                try:
                    _t = time.time() + self.progressDelayTime
                    i = 0
                    while th.isAlive() and time.time() <= _t:
                        if i % 300 == 0:
                            i = 0
                            if wx.GetApp().Pending(): # the request is enough
                                pass
                            #if evtloop.Pending():
                                #pass
                        wx.MilliSleep(10) # On the first frame after creating a clip we can sleep more time
                finally:
                    del disabler
                    if not th.isAlive():
                        wx.GetApp().SafeYieldFor(self, wx.wxEVT_TIMER)
                        self.ClipRefreshPainter = False
                    #del ea
                    self.videoWindow.SetDoubleBuffered(False)
                    return self.TH_WaitForFrame(script, th, nr)
            else:
                th.join(self.progressDelayTime)
                return self.TH_WaitForFrame(script, th, nr)

        script.AviThread = None
        return True

    # Thread handle with events, (advanced frame thread) a bit faster on my system
    def WaitForFrameThread(self, script, th, nr):
        if th.IsRunning():
            disabler = wx.WindowDisabler()
            if self.progressShown:
                wx.GetApp().ProcessIdle() # close clip progress dialog
            i = 0
            msgShown = False
            msg = utils.resource_str_threadwait
            msg_1 = msg if self.WinVersion < 7 else ''

            if self.ClipRefreshPainter:
                #evtloop = wx.EventLoop()
                #ea = wx.EventLoopActivator(evtloop)
                self.videoWindow.SetDoubleBuffered(True)
                if self.IsIconized():
                    sash = self.mainSplitter.GetSashPosition()
                    self.Iconize(False)
                    self.mainSplitter.SetSashPosition(sash)
                    try:
                        wx.GetApp().SafeYieldFor(self.videoWindow, wx.wxEVT_PAINT)
                    except:
                        pass

            if self.ClipRefreshPainter and (self.options['threadprogressopt'] == 2 and not self.progressShown):
                progress = None
            else:
                progress = wx.ProgressDialog(_('Waiting for frame {0}'.format(nr)),msg_1,10, self,
                            style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
            try:
                while th.isAlive() and th.IsRunning():
                    if not progress and i % 3 == 0 and wx.GetKeyState(wx.WXK_CONTROL):
                        progress = wx.ProgressDialog(_('Waiting for frame {0}'.format(nr)),msg_1,10,self,
                                    style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_APP_MODAL)
                    if progress:
                        c,s = progress.Pulse()
                        if not c:             # user abort
                            if i > 10: break
                            else:
                                msgShown = True
                                progress.Pulse(msg)
                        if not msgShown and i > 10: # show msg
                            msgShown = True
                            progress.Pulse(msg)
                    i += 1
                    if self.ClipRefreshPainter and i % 5 == 0:
                        if wx.GetApp().Pending():
                            pass
                        #if evtloop.Pending():
                            #pass
                    th.join(0.5)
            finally:
                del disabler
                if self.ClipRefreshPainter:
                    #del ea
                    wx.GetApp().SafeYieldFor(self, wx.wxEVT_TIMER) # process (delete) all events
                    self.ClipRefreshPainter = False
                    self.videoWindow.SetDoubleBuffered(False)
                if progress:
                    progress.Destroy()
                if th.IsRunning():
                    self.Thread_List.append((th, None))
                    return False
        else:
            self.ClipRefreshPainter = False
            self.videoWindow.SetDoubleBuffered(False)
        re = not th.IsError()
        th.Reset()
        return re

    # Single frame Thread for each script (advanced frame thread)
    def GetAviDisplayFrame2(self, script, nr, showWarn=True, checkClipThread=True, srcFrame=False):
        # return false if AVI thread running
        if checkClipThread and self.AviThread_Running(script, prompt=showWarn, checkFrameThread=False):
            return False

        if not self.UseAviThread:
            if self.FrameThread_Running(script, showWarn):
                return False
            script.AVI.display_clip.get_frame(nr)
            return True

        if script.FrameThread is None:# or not script.FrameThread.isAlive(): # HM...
            script.FrameThread = self.FrameThread(script)

        th = script.FrameThread
        if th.IsRunning(): # a bit faster when check running here
            _t = time.time() + 2.0
            while th.isAlive() and th.IsRunning() and time.time() <= _t:
                wx.MilliSleep(2)
            if self.FrameThread_Running(script, showWarn):
                return False

        th.Start(nr, srcFrame)
        _t = time.time() + self.progressDelayTime

        # Is True only after a clip has been created and the preview was visible (UpdateScriptAvi)
        # and the first frame for that clip is requested.
        if self.ClipRefreshPainter:
            self.videoWindow.SetDoubleBuffered(True)
            disabler = wx.WindowDisabler()
            #evtloop = wx.EventLoop()
            #ea = wx.EventLoopActivator(evtloop)
            try:
                i = 0
                while th.isAlive() and th.IsRunning() and time.time() <= _t:
                    i += 1
                    if i % 300 == 0:
                        i = 0
                        if wx.GetApp().Pending(): # the request is enough
                            pass
                        #if evtloop.Pending():
                            #pass
                    wx.MilliSleep(10) # on first frame we can sleep longer
            finally:
                del disabler
                if th.IsRunning():
                    #del ea
                    return self.WaitForFrameThread(script, th, nr)
                else:
                    #del ea
                    wx.GetApp().SafeYieldFor(self, wx.wxEVT_TIMER)
                    self.ClipRefreshPainter = False
                    self.videoWindow.SetDoubleBuffered(False)
                    re = not th.IsError()
                    if not re:
                        th.Reset()
                    return re
        else:
            while th.isAlive() and th.IsRunning() and time.time() <= _t: # It's faster as Event.wait()
                wx.MilliSleep(1)
            if th.IsRunning():
                return self.WaitForFrameThread(script, th, nr)
            else:
                re = not th.IsError()
                if not re:
                    th.Reset()
                return re

    # Single frame thread for each script, (advanced frame thread) not mutch faster as creating a thread for each frame
    class FrameThread(threading.Thread):
        def __init__(self, script):
            threading.Thread.__init__(self)
            self.setDaemon(True)
            self.script = script
            self.exitEvent = threading.Event()
            self.startEvent = threading.Event()
            self.Lock = threading.RLock()
            self.isRunning = False
            self.isError = False
            self.start()
        def Start(self, nr, srcFrame):
            self.nr = nr
            self.srcFrame = srcFrame
            self.isRunning = True
            self.startEvent.set()
        def Reset(self):
            self.Lock.acquire()
            self.isError = False
            self.Lock.release()
        def Exit(self):
            self.exitEvent.set()
            self.startEvent.set()
        def IsRunning(self, timeout=0):
            if timeout > 0:
                t = time.time() + timeout
                while t < time.time():
                    self.Lock.acquire() # with lock not slower
                    re = self.isRunning
                    self.Lock.release()
                    if not re:
                        return False
                    wx.MilliSleep(1)
            self.Lock.acquire() # with lock not slower
            re = self.isRunning
            self.Lock.release()
            return re
        def IsError(self):
            self.Lock.acquire()
            re = self.isError
            self.Lock.release()
            return re
        def run(self):
            while not self.exitEvent.isSet():
                self.startEvent.wait()
                if not self.exitEvent.isSet():
                    try:
                        if not self.srcFrame:
                            self.script.AVI.display_clip.get_frame(self.nr)
                        else:
                            self.script.AVI._GetFrame(self.nr)
                    except:
                        self.Lock.acquire()
                        self.isError = True
                        self.Lock.release()
                    self.startEvent.clear()
                    self.Lock.acquire()
                    self.isRunning = False
                    self.Lock.release()

    def SaveCallYield(self):
        self.Lock.acquire()
        #wx.GetApp().Yield()
        wx.Yield()
        self.Lock.release()

    def PlayPauseVideo(self, debug_stats=False, refreshFrame=True):
        """Play/pause the preview clip"""
        if self.playing_video:
            if os.name == 'nt':
                if self.timeKillEvent:
                    self.timeKillEvent(self.play_timer_id)
                    self.timeEndPeriod(self.play_timer_resolution)
            else:
                self.play_timer.Stop()

            script = self.currentScript
            self.playing_video = False # set to false bevor self.ShowVideoFrameFast
            script.PlayThreadId = 0
            self.zoom_antialias = self.options['zoom_antialias']

            self.play_button.SetBitmapLabel(self.bmpPlay)
            self.play_button.Refresh()
            if self.separatevideowindow:
                self.play_button2.SetBitmapLabel(self.bmpPlay)
                self.play_button2.Refresh()

            try: # must wait for thread finish or the thread paint the frame after ShowVideoFrame
                if self.PlayThread_Running(script, prompt=False):
                    th = script.PlayThread
                    t = time.time() + 5.0
                    while th.isAlive() and time.time() <= t:
                        # threads enters the main thread (AsyncCall) so we cannot block the main thread
                        # while waiting for play thread termination
                        if wx.GetApp().HasPendingEvents():
                            wx.GetApp().ProcessPendingEvents()
                        th.join(0.1)

                if self.AviThread_Running(script, prompt=False, checkFrameThread=False):
                    script.AviThread.join(5.0)

                if self.FrameThread_Running(script, prompt=False):
                    th = script.FrameThread
                    t = time.time() + 5.0
                    while th.isAlive() and th.IsRunning() and time.time() <= t:
                        wx.MilliSleep(20)
            except:
                pass

            if refreshFrame:
                if self.previewOK():
                    self.ShowVideoFrame(self.currentframenum, forceLayout=True)
                #self.ShowVideoFrameFast(self.currentframenum)  # GPo 2020, leave it call fast, fast checks errors
            if self.readFrameProps:
                script.AVI.SetReadFrameProps(True)

        else:
            script = self.currentScript
            threaded = self.options['playbackthread'] or self.UseAviThread
            script.PlayThreadId = 0
            # Befor start the playback check the threads
            if self.AviThread_Running(script, prompt=True, checkFrameThread=True) or \
                self.PlayThread_Running(script, prompt=True):
                    return
            # check and set the defaults
            if not self.ShowVideoFrame(self.GetFrameNumber(), focus=False, forceLayout=True, forceCursor=self.ScriptChanged(self.currentScript)) \
                or self.currentScript.AVI.IsErrorClip():
                    return
            # calc play loop
            self.loop_start = self.loop_end = -1
            if self.options['playloop'] and not self.trimDialog.IsShown() and script.AVI.Framecount > 5:
                prev = self.ValueInSliderSelection(self.currentframenum)
                if prev is None:
                    prev = False
                start, stop = self.GetNextSliderSelection(self.currentframenum, True, prev) # returns None if slider offset
                if start is not None:
                    if script.AVI.Framecount -3 > start: # else out of visible range
                        self.loop_end = min(stop, self.videoSlider.GetVirtualMax())
                        self.loop_start = min(start, self.loop_end -3)

            if self.currentframenum == script.AVI.Framecount - 1:
                # GPo 2020, continue playing from loop_start or frame 0
                fr = self.loop_start if self.loop_start > -1 else self.videoSlider.startOffset
                if not self.ShowVideoFrame(framenum=fr, focus=False, forceLayout=True, forceCursor=self.ScriptChanged(script)) \
                    or self.currentScript.AVI.IsErrorClip():
                    return
            if script.AVI.readFrameProps:
                script.AVI.SetReadFrameProps(False)
            self.playing_video = True
            self.zoom_antialias = False
            self.play_button.SetBitmapLabel(self.bmpPause)
            self.play_button.Refresh()
            self.frameTextCtrl.SetForegroundColour(wx.BLACK) # GPo, for fast func
            if self.separatevideowindow:
                self.play_button2.SetBitmapLabel(self.bmpPause)
                self.play_button2.Refresh()
                self.frameTextCtrl2.SetForegroundColour(wx.BLACK) # GPo, for fast func

            #GPo testing, seems good.
            if self.play_speed_factor == 'max':
                interval = 1.0   # use a timer anyway to avoid GUI refreshing issues
                self.interval = 0.0
            else:
                interval = 1000.0 / (script.AVI.Framerate * self.play_speed_factor)
                self.interval = float(interval/1000.0)

            # GPo new, set the drop count out of the play routine make a int, it's faster
            if self.play_drop == True:
                self.drop_count = 1
            elif self.play_drop > 1:
                self.drop_count = self.play_drop
            else:
                self.drop_count = 0

            if os.name == 'nt': # default Windows resolution is ~10 ms, ( out of date )
                def playback_timer2(id, reserved, factor, reserved1, reserved2):
                    """"needed for playthread speed boost"""
                    pass
                # only for playback without threads
                def playback_timer(id, reserved, factor, reserved1, reserved2):
                    """"Callback for a Windows Multimedia timer"""
                    if not self.playing_video:
                        self.zoom_antialias = self.options['zoom_antialias']
                        self.timeKillEvent(self.play_timer_id)
                        self.timeEndPeriod(self.play_timer_resolution)
                        return

                    # GPo 2020, for fps
                    startTime = time.time()
                    """
                    if debug_stats:
                        sfps = 'debug '
                        current_time = time.time()
                        debug_stats_str = str((current_time - self.previous_time) * 1000)
                        self.previous_time = current_time
                    """
                    fps = float(self.currentframenum - self.play_initial_frame)  / (startTime - self.play_initial_time)
                    sfps = 'fps %4.2f ' % fps

                    if (self.drop_count == 1) and self.play_speed_factor != 'max':
                        frame = self.play_initial_frame
                        increment = int(round(1000 * (time.time() - self.play_initial_time) / interval)) * factor
                        """
                        if debug_stats:
                            debug_stats_str += ' dropped: ' + str(increment - self.increment - 1)
                            self.increment = increment
                        """
                    else:
                        frame = self.currentframenum + self.drop_count
                        increment = 1
                        if self.loop_start > -1:  # GPo 2020. play loop, changes not needed if slider offset (selections then None)
                            if (frame + 1 >= self.loop_end) or (frame + 1 < self.loop_start):
                                # check for next selection
                                start, stop = self.GetNextSliderSelection(frame+1, True, False)
                                if start is not None:
                                    if script.AVI.Framecount -3 > start:
                                        self.loop_end = min(stop, script.AVI.Framecount -1)
                                        self.loop_start = min(start, self.loop_end -3)
                                        frame = self.loop_start -1
                                        self.play_initial_frame = frame
                                        self.play_initial_time = time.time()
                                    else:
                                        self.loop_start = self.loop_end = -1
                                else:
                                    self.loop_start = self.loop_end = -1

                    #~if debug_stats:
                        #~print (debug_stats_str)

                    # GPo 2020, use fast func
                    if threaded:
                        if not self.ShowVideoFrameFast(frame + increment, sfps, threaded=True):
                            if self.playing_video: self.PlayPauseVideo()
                            return
                    elif not AsyncCall(self.ShowVideoFrameFast, frame + increment, sfps, threaded=False).Wait():
                        if self.playing_video: self.PlayPauseVideo()
                        return

                    maxFrame = self.videoSlider.GetVirtualMax() #script.AVI.Framecount - 1 if self.videoSlider.endOffset == 0 else self.videoSlider.GetVirtualMax()
                    if self.currentframenum >= maxFrame:
                        # GPo 2020, play loop
                        if (self.loop_start > -1) and (self.loop_start < maxFrame - 3)\
                            and (self.loop_end <= maxFrame): # continue, new lop_start is in the next run set
                            pass
                        else:                               # then trimDialog not shown
                            if self.options['playloop'] and self.videoSlider.selmode == 0 and \
                                (self.videoSlider.maxValue - self.videoSlider.minValue > 3): # play also loop
                                self.PlayPauseVideo(refreshFrame=False)
                                if self.ShowVideoFrame(self.videoSlider.startOffset):
                                    wx.CallAfter(self.PlayPauseVideo)
                                return
                            else:
                                if self.videoSlider.offsetSet and self.timelineAutoScroll: # check for timeline range
                                    if self.currentframenum < script.AVI.Framecount-1:
                                        self.playing_video = False
                                        self.OnMenuSetTimeLineRange(frange=self.timelineRange)
                                        self.playing_video = True
                                        if self.currentframenum < self.videoSlider.GetVirtualMax():
                                            return
                                self.PlayPauseVideo() # stop playback
                                return
                    self.SaveCallYield()


                def WindowsTimer(interval, callback, periodic=True):
                    """High precision timer (1 ms) using Windows Multimedia"""

                    self.timeGetDevCaps = ctypes.windll.winmm.timeGetDevCaps
                    self.timeBeginPeriod = ctypes.windll.winmm.timeBeginPeriod
                    self.timeEndPeriod = ctypes.windll.winmm.timeEndPeriod
                    self.timeSetEvent = ctypes.windll.winmm.timeSetEvent
                    self.timeKillEvent = ctypes.windll.winmm.timeKillEvent

                    callback_prototype = ctypes.WINFUNCTYPE(None, ctypes.c_uint,
                        ctypes.c_uint, ctypes.c_ulong, ctypes.c_ulong, ctypes.c_ulong)
                    self.timeSetEvent.argtypes = [ctypes.c_uint, ctypes.c_uint,
                        callback_prototype, ctypes.c_ulong, ctypes.c_uint]

                    class TIMECAPS(ctypes.Structure):
                        _fields_ = [("wPeriodMin", ctypes.c_uint),
                                    ("wPeriodMax", ctypes.c_uint)]

                    caps = TIMECAPS()
                    self.timeGetDevCaps(ctypes.byref(caps), ctypes.sizeof(caps))
                    self.play_timer_resolution = max(1, caps.wPeriodMin)
                    self.timeBeginPeriod(self.play_timer_resolution)

                    interval0 = interval
                    factor = max(1, int(round(self.play_timer_resolution / interval)))
                    interval = int(round(interval * factor))
                    self.callback_c = callback_prototype(callback)
                    self.play_initial_frame = self.currentframenum
                    self.play_initial_time = time.time() - 0.0001
                    if debug_stats:
                        print ('speed_factor: {0}, required_interval: {1} '\
                              'interval: {2} interval_factor: {3}'.format(
                              self.play_speed_factor, interval0, interval, factor))
                        self.increment = 0
                        self.previous_time = self.play_initial_time

                    self.play_timer_id = self.timeSetEvent(interval,
                        self.play_timer_resolution, self.callback_c, factor, periodic)

                if not threaded:
                    WindowsTimer(interval, playback_timer)
                    return

                ################################################################
                ##
                ##  GPo 2021, Play Thread
                ##
                ################################################################

                #self.timeKillEvent = None
                WindowsTimer(interval, playback_timer2)
                self.play_timer_resolution = 1
                factor = max(1, int(round(self.play_timer_resolution / interval)))
                interval = int(round(interval * factor))

                def FrameError(idx, script, errmsg, framenum):
                    if self.playing_video:
                        self.PlayPauseVideo(refreshFrame=False)
                    self.HidePreviewWindow()  # stop also playback
                    if idx == 1:
                        self.videoSlider.SetValue(framenum)
                        self.frameTextCtrl.ChangeValue(str(framenum))
                        self.frameTextCtrl.Update()
                        if self.separatevideowindow:
                            self.videoSlider2.SetValue(framenum)
                            self.frameTextCtrl.ChangeValue(str(framenum))
                            self.frameTextCtrl.Update()
                        wx.MessageBox(u'\n\n'.join((_('Error requesting frame {number}').format(number=framenum),
                                 errmsg)), _('Error'), style=wx.OK|wx.ICON_ERROR)
                    elif idx == 2:
                        wx.Bell()
                        lines = errmsg.lower().split('\n')
                        items = lines[-1].split()
                        try:
                            index = items.index('line') + 1
                            if index < len(items):
                                try:
                                    linenum = int(items[index].strip('),')) - 1
                                    if linenum < script.GetLineCount():
                                        posA = script.PositionFromLine(linenum)
                                        posB = script.GetLineEndPosition(linenum)
                                        script.SetSelection(posA, posB)
                                        doFocusScript = True
                                except ValueError:
                                    pass
                        except ValueError:
                            pass
                        script.SetFocus()
                        script.EnsureCaretVisible()
                    elif idx == 3:
                        wx.MessageBox(u'\n\n'.join((_('Error playing frame {number}').format(number=framenum),
                                 errmsg)), _('Error'), style=wx.OK|wx.ICON_ERROR)

                def Replay():
                    self.playing_video = True
                    self.PlayPauseVideo(refreshFrame=False)
                    if self.ShowVideoFrame(self.videoSlider.startOffset):
                        self.PlayPauseVideo()

                def PaintFrame(script, frame):
                    re = False
                    try:
                        dc = wx.ClientDC(self.videoWindow)
                        re = self.PaintAVIFrame(dc, script, frame)
                    except:
                        return False
                    return re

                def UpdateCtrls(frame, fps):
                    try:
                        self.videoSlider.SetValue(frame)
                        self.frameTextCtrl.ChangeValue(str(frame))
                        self.frameTextCtrl.Update()
                        if self.separatevideowindow:
                            self.videoSlider2.SetValue(frame)
                            self.frameTextCtrl2.ChangeValue(str(frame))
                            self.frameTextCtrl2.Update()
                        self.SetVideoStatusText(frame, primary=True, addon0=fps)
                    except:
                        pass

                def th_Update(frame, fps):
                    AsyncCall(UpdateCtrls, frame, fps).Wait()
                ### test
                def th_get_frame(script, frame, reEvt):
                    script.AVI.display_clip.get_frame(frame)
                    reEvt.set()
                def th_paint_frame(script, frame, reQu):
                    re = AsyncCall(PaintFrame, script, frame).Wait()
                    reQu.put_nowait(re) # important _nowait()

                def play(frame, interval, factor):
                    script = self.currentScript
                    play_speed_factor = self.play_speed_factor
                    drop_count = self.drop_count
                    play_initial_frame = frame
                    play_initial_time = time.time() - 0.00001
                    self_interval = self.interval
                    self_id = script.PlayThreadId
                    startTime = time.time()
                    updateTh = None
                    ### test
                    paintFrameTh = None
                    #paintFrame = frame
                    #getFrameTh = None
                    #reQu = queue.LifoQueue()
                    #~reQu = queue.Queue()
                    #reEvent = threading.Event()
                    #_next_frame = -1
                    ### test end
                    while self.playing_video and self_id == script.PlayThreadId:
                        try:
                            fps = float(self.currentframenum - play_initial_frame)  / (time.time() - play_initial_time)
                        except:
                            fps = 0.00
                        sfps = 'fps %4.2f ' % fps

                        if (drop_count == 1) and play_speed_factor != 'max':
                            frame = play_initial_frame
                            increment = int(round(1000 * (time.time() - play_initial_time) / interval)) * factor
                        else:
                            frame = self.currentframenum + drop_count
                            increment = 1
                            if self.loop_start > -1:  # GPo 2020. play loop, changes not needed if slider offset (selections then None)
                                if (frame + 1 >= self.loop_end) or (frame + 1 < self.loop_start):
                                    # check for next selection
                                    start, stop = self.GetNextSliderSelection(frame+1, True, False)
                                    if start is not None:
                                        if script.AVI.Framecount -3 > start:
                                            self.loop_end = min(stop, script.AVI.Framecount -1)
                                            self.loop_start = min(start, self.loop_end -3)
                                            frame = self.loop_start -1
                                            play_initial_frame = frame
                                            play_initial_time = time.time() - 0.00001
                                        else:
                                            self.loop_start = self.loop_end = -1
                                    else:
                                        self.loop_start = self.loop_end = -1

                        ### test for get frame test
                        #nextFrame = frame + increment + 1
                        ### test end
                        frame += increment
                        self.currentframenum = frame

                        """
                        ### get frame test with 3 active threads, but not faster, avisynth input is single threaded
                        if getFrameTh and _next_frame == frame:
                            if reEvent.wait(6.0) is True:
                                reEvent.clear()
                                _next_frame = nextFrame
                                getFrameTh = threading.Thread(target=th_get_frame, args=(script, nextFrame, reEvent))
                                getFrameTh.daemon = True
                                getFrameTh.start()
                            else:
                                errmsg = 'Play thread error wait for frame'
                                wx.CallAfter(FrameError, 1, script, errmsg, frame)
                                return
                        else:
                            # get first the important frame !!
                            script.AVI.display_clip.get_frame(frame)
                            #script.AVI._GetFrame(frame)
                            if not getFrameTh or (getFrameTh and not getFrameTh.isAlive()):
                                reEvent.clear()
                                _next_frame = nextFrame
                                getFrameTh = threading.Thread(target=th_get_frame, args=(script, nextFrame, reEvent))
                                getFrameTh.daemon = True
                                getFrameTh.start()
                        ### test end
                        """

                        """ test, get both frames in thread (source, display) but no improvments
                        re = script.AVI._GetFrame(frame)
                        if not re or script.AVI.error_message:
                            wx.CallAfter(FrameError, 1, script, script.AVI.error_message, frame)
                            break
                        """

                        script.AVI.display_clip.get_frame(frame)
                        errmsg = script.AVI.display_clip.get_error()
                        if errmsg is not None:
                            wx.CallAfter(FrameError, 1, script, errmsg, frame)
                            break

                        if self_interval > 0:
                            time.sleep(max((startTime+self_interval)-time.time(), 0))
                        startTime = time.time()

                        """ interresant
                        dc = wx.ClientDC(self.videoWindow)
                        self.videoWindow.DoPrepareDC(dc)
                        if not script.AVI.DrawFrame(frame, dc):
                            wx.CallAfter(self.ErrorMessage_GetFrame, script, frame)
                            break
                        """

                        """
                        # faster without filter but more jerky with filter
                        # wait vor the frame paint result
                        if paintFrameTh and self.playing_video:
                            try:
                                qre = reQu.get(True, 0.5)
                            except:
                                re = qre = False
                                _t = time.time() + 4.0
                                while not re and self.playing_video and _t < time.time():
                                    try:
                                        qre = reQu.get(True, 0.2)
                                        re = True
                                    except:
                                        continue
                                    if re:
                                        break
                            if not qre:
                                errmsg = 'Play thread paint frame error'
                                wx.CallAfter(FrameError, 3, script, errmsg, paintFrame)
                                break

                        if not self.playing_video:
                            break
                        # paint the frame in separate thread
                        reQu = queue.Queue()
                        paintFrame = frame
                        paintFrameTh = threading.Thread(target=th_paint_frame, args=(script, frame, reQu))
                        paintFrameTh.daemon = True
                        paintFrameTh.start()

                        """
                        # paint frame the original, smoother with filter
                        if not AsyncCall(PaintFrame, script, frame).Wait():
                            errmsg = 'Play thread unknown paint frame error'
                            wx.CallAfter(FrameError, 3, script, errmsg, frame)
                            break

                        # update the controls with a separate thread, it's not so important, so no wait is needed
                        if updateTh and updateTh.isAlive():
                            pass
                        else:
                            updateTh = threading.Thread(target=th_Update, args=(frame, sfps,))
                            updateTh.daemon = True
                            updateTh.start()

                        errmsg = script.AVI.error_message
                        if errmsg is not None:
                            wx.CallAfter(FrameError, 2, script, errmsg, frame)
                            break

                        script.lastFramenum = frame
                        if not self.playing_video:
                            break

                        maxFrame = self.videoSlider.GetVirtualMax() #script.AVI.Framecount - 1 if self.videoSlider.endOffset == 0 else self.videoSlider.GetVirtualMax()
                        if self.currentframenum >= maxFrame:
                            # play loop
                            if (self.loop_start > -1) and (self.loop_start < maxFrame - 3)\
                                and (self.loop_end <= maxFrame): # continue, new lop_start is in the next run set
                                continue
                            else:                               # then trimDialog not shown
                                if self.options['playloop'] and self.videoSlider.selmode == 0 and \
                                    (self.videoSlider.maxValue - self.videoSlider.minValue > 3): # play also loop
                                    wx.CallAfter(Replay)
                                    break
                                else:
                                    if self.videoSlider.offsetSet and self.timelineAutoScroll: # check for timeline range
                                        if self.currentframenum < script.AVI.Framecount-1:
                                            self.playing_video = False
                                            #self.OnMenuSetTimeLineRange(frange=self.timelineRange)
                                            AsyncCall(self.OnMenuSetTimeLineRange, frange=self.timelineRange).Wait()
                                            self.playing_video = True
                                            if self.currentframenum < self.videoSlider.GetVirtualMax():
                                                continue
                                    wx.CallAfter(self.PlayPauseVideo) # stop playback
                                    break

                    # on thread termination wait for the other threads
                    if updateTh and updateTh.isAlive():
                        updateTh.join(5)
                    if paintFrameTh and paintFrameTh.isAlive():
                        paintFrameTh.join(5)
                    if (updateTh and updateTh.isAlive()) or (paintFrameTh and paintFrameTh.isAlive()):
                        errmsg = "Play thread hangs, it's important that you save the scripts and restart the program!"
                        wx.CallAfter(FrameError, 3, script, errmsg, frame)
                    # additional indicator and break, thread finished
                    self.currentScript.PlayThreadId = -1

                # run the playback
                th = threading.Thread(target=play, args=(self.currentframenum, interval, factor,))
                th.daemon = True
                script.PlayThread = th
                script.PlayThreadId = time.time()
                th.start()

            else: # wx.Timer on *nix.  There's some pending events issues
                # TODO: fix/replace wx.Timer

                # signal module causes segmentation fault on high fps
                # similar issues using librt with ctypes
                '''
                global signal
                import signal

                def playback_timer(signum, frame):
                    """"SIGALRM handler"""
                    if not self.playing_video:
                        return
                    if debug_stats:
                        current_time = time.time()
                        debug_stats_str = str((current_time - self.previous_time) * 1000)
                        self.previous_time = current_time
                    if self.play_drop and self.play_speed_factor != 'max':
                        frame = self.play_initial_frame
                        increment = int(round((time.time() - self.play_initial_time) / interval)) * factor
                        if debug_stats:
                            debug_stats_str += ' dropped: ' + str(increment - self.increment - 1)
                            self.increment = increment
                    else:
                        frame = self.currentframenum
                        increment = 1
                    if debug_stats:
                        print (debug_stats_str)
                    if not AsyncCall(self.ShowVideoFrame, frame + increment,
                                     check_playing=True, focus=False).Wait():
                        return
                    if self.currentframenum == script.AVI.Framecount - 1:
                        self.PlayPauseVideo()
                    elif not wx.GetApp().Yield(True):
                        self.parent.PlayPauseVideo()

                interval0 = interval
                factor = max(1, int(round(1 / interval)))
                interval = interval * factor / 1000
                self.previous_signal_handler = signal.signal(signal.SIGALRM, playback_timer)
                self.play_initial_frame = self.currentframenum
                self.play_initial_time = time.time()
                if debug_stats:
                    print ('speed_factor: {0}, required_interval: {1} '\
                          'interval: {2} interval_factor: {3}'.format(
                          self.play_speed_factor, interval0, interval * 1000, factor))
                    self.increment = 0
                    self.previous_time = self.play_initial_time
                signal.setitimer(signal.ITIMER_REAL, interval, interval)

                return
                '''

                class RunVideoTimer(wx.Timer):
                    def __init__(self, parent, factor=1):
                        wx.Timer.__init__(self)
                        self.parent = parent
                        self.factor = factor
                        self.play_initial_frame = self.parent.currentframenum
                        self.play_initial_time = time.time()
                        self.Yield = wx.GetApp().Yield
                        if debug_stats:
                            self.increment = 0
                            self.previous_time = self.play_initial_time
                    def Notify(self):
                        if not self.parent.playing_video:
                            self.parent.PlayPauseVideo()
                            return
                        if debug_stats:
                            current_time = time.time()
                            debug_stats_str = str((current_time - self.previous_time) * 1000)
                            self.previous_time = current_time
                        if self.parent.play_drop and self.parent.play_speed_factor != 'max':
                            frame = self.play_initial_frame
                            increment = int(round(1000 * (time.time() - self.play_initial_time) / self.GetInterval())) * self.factor
                            if debug_stats:
                                debug_stats_str += ' dropped: ' + str(increment - self.increment - 1)
                                self.increment = increment
                        else:
                            frame = self.parent.currentframenum
                            increment = 1
                        if debug_stats:
                            print (debug_stats_str)

                        # GPo 2020, use fast func
                        """
                        if self.parent.play_fastFunc:
                            if not self.parent.ShowVideoFrameFast(frame + increment):
                                return
                        else:
                        """
                        if not self.parent.ShowVideoFrame(frame + increment, check_playing=True, focus=False):
                            return

                        if self.parent.currentframenum == script.AVI.Framecount - 1:
                            self.parent.PlayPauseVideo()
                        elif not self.Yield(True):
                            self.parent.PlayPauseVideo()

                interval0 = interval
                factor = max(1, int(round(1 / interval)))
                interval = int(round(interval * factor))
                self.play_timer = RunVideoTimer(self, factor)
                if debug_stats:
                    print ('speed_factor: {0}, required_interval: {1} '\
                          'interval: {2} interval_factor: {3}'.format(
                          self.play_speed_factor, interval0, interval, factor))
                self.play_timer.Start(interval)

    def RunExternalPlayer(self, path=None, script=None, args=None, prompt=True):
        if script is None:
            script = self.currentScript
        index = self.scriptNotebook.GetSelection()
        tabTitle = self.scriptNotebook.GetPageText(index)
        # GPo new
        # option save toggle tags in script, self.options['savetoggletags']
        # whe can save the toggle tags in the script #>[sharp=0], so check the toggled filters here
        isClean = self.cleanToggleTags(script.GetText()) == script.GetText()

        if not script.GetModify() and isClean and os.path.isfile(script.filename):
            # Always use original script if there are no unsaved changes
            previewname = script.filename
            boolTemp = False
        elif self.options['previewunsavedchanges'] or not os.path.isfile(script.filename):
            previewname = self.MakePreviewScriptFile(script)
            boolTemp = True
        else:
            if self.options['promptwhenpreview']:
                if script.GetModify():
                    dlg = wx.MessageDialog(self, _('Save changes before previewing?'),
                        tabTitle, wx.YES_NO|wx.CANCEL)
                    ID = dlg.ShowModal()
                    dlg.Destroy()
                    if ID == wx.ID_YES:
                        self.SaveScript(script.filename, index)
                    elif ID == wx.ID_CANCEL:
                        pass
            if isClean:
                previewname = script.filename
                boolTemp = False
            else: # GPo new, enable/disable the filters
                previewname = self.MakePreviewScriptFile(script)
                boolTemp = True
            ##

        if path is None:
            path = self.options['externalplayer']
        if args is None:
            args = self.options['externalplayerargs']
        path = self.ExpandVars(path)
        if not os.path.isfile(path):
            if not prompt:
                return False
            filefilter = (_('Executable files') + ' (*.exe)|*.exe|' if os.name == 'nt' else '') + _('All files') + ' (*.*)|*.*'
            dlg = wx.FileDialog(self, _('Select an external player'), '', '', filefilter, wx.OPEN)
            ID = dlg.ShowModal()
            if ID == wx.ID_OK:
                path = dlg.GetPath()
            else:
                path = ''
            dlg.Destroy()
        if not os.path.isfile(path):
            if path != '':
                wx.MessageBox(_('A program must be specified to use this feature!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return
        self.options['externalplayer'] = self.ExpandVars(path, False)
        # Run the process
        process = wx.Process(self)
        def OnEndProcess(event):
            try:
                os.remove(previewname)
            except OSError:
                pass
        if boolTemp:
            process.Bind(wx.EVT_END_PROCESS, OnEndProcess)
        self.pid = wx.Execute('%s "%s" %s' % (path, previewname, args), wx.EXEC_ASYNC, process)
        return True

    # GPo 2020
    def RunExternalTool(self, args):
        path = self.options['externaltool']
        if not os.path.isfile(path):
            wx.MessageBox(_('Program not found. Must be specified to use this feature!'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            self.ShowOptions(0)
            return

        script = self.currentScript
        if args.find('%fn') > -1:
            if not script.filename or script.GetModify():
                self.SaveScript(script.filename)
                if not script.filename:
                    return
            args = args.replace('%fn', '"' + script.filename + '"')

        wx.Execute('%s %s' % (path, args))

    def SetExternalToolMenuLabel(self):
        txt1 = self.options['externaltoolarg1']
        txt2 = self.options['externaltoolarg2']
        if not txt1 and not txt2:
            return
        name1 = ''
        name2 = ''
        pos = txt1.find('|')
        if pos > 1:
            name1 = txt1[:pos]
        pos = txt2.find('|')
        if pos > 1:
            name2 = txt2[:pos]
        # start index for first External Tool menu, must change if tools submenu changed
        # real python shit
        idx = 5
        if name1 or name2:
            vidmenus = [self.videoWindow.contextMenu, self.GetMenuBar().GetMenu(2)]
            for vidmenu in vidmenus:
                id = vidmenu.FindItem(_('Tools'))
                menuTools = vidmenu.FindItemById(id).GetSubMenu()
                if name1:
                    menu = menuTools.FindItemByPosition(idx)
                    if menu:
                        menu.SetItemLabel(name1)
                if name2:
                    menu = menuTools.FindItemByPosition(idx+1)
                    if menu:
                        menu.SetItemLabel(name2)

    def re_replace(self, mo):
        items = mo.group().lstrip(self.sliderOpenString).rstrip(self.sliderCloseString).split(',')
        if len(items) == 4:
            return items[3].strip()
        elif len(items) == 1 and 'separator' in items[0]:
            return ''
        else:
            return mo.group()

    # removes also the filters from script
    def re_replace2(self, mo):
        txt = mo.group()
        if self.boolToggleTag(txt):
            posA = txt.find(']') + 1
            posB = txt.rfind('[')
            return txt[posA:posB]
        else:
            return ''

    # GPo, do not remove the filters, comment the lines out
    def re_replace3(self, mo):
        txt = mo.group()
        if self.boolToggleTag(txt):
            posA = txt.find(']') + 1
            posB = txt.rfind('[')
            return txt[posA:posB]
        else:
            posA = txt.find(']') + 1
            posB = txt.rfind('[')
            newTxt = ''
            for line in txt[posA:posB].split('\n'):
                ls = line.strip()
                if ls and not ls.startswith('#'):
                    newTxt += '#' + ls + '\n'
                else: newTxt += ls + '\n'
            return newTxt[:-1]

    def boolToggleTag(self, txt):
        starttag = txt[1:txt.find(']')]
        boolKeep = True
        try:
            name, value = starttag.split('=')
            try:
                boolKeep = bool(int(value))
            except ValueError:
                pass
        except ValueError:
            pass
        return boolKeep

    def ParseCalltipArgInfo(self, info, strValue=None):
        # TODO: handle repeating args [, ...]
        info = re.sub(r'\[.*\]', '', info)
        if info.startswith('#'): # GPo, new
            return (None, None, None, None, None)
        argtypename = info.split('=', 1)[0].strip()
        splitargtypename = argtypename.split()
        if len(splitargtypename) != 2:
            if len(splitargtypename) == 1:
                return (argtypename.lower(), None, None, None, None)
            else:
                return (None, None, None, None, None)
        argtype, argname = splitargtypename
        argtype = argtype.lower()
        if info.count('=') > 0:
            argInfo = info.split('=', 1)[1].strip()
            splitargtypename = argtypename.split()
            if argtype in ('float', 'int'):
                defaultValue = minValue = maxValue = nDecimal = mod = None
                strDefaultValue = strMinValue = strMaxValue = strStepSize = ''
                splitargInfo = argInfo.split('(',1)
                if len(splitargInfo) == 1:
                    strDefaultValue = argInfo
                    if strDefaultValue.startswith('$'):
                        try:
                            hexstring = strDefaultValue.split('$', 1)[1]
                            int(hexstring, 16)
                            return (argtype, argname, 'color', hexstring, None)
                        except ValueError:
                            return (argtype, argname, 'error', strDefaultValue, None)
                    else:
                        if argtype == 'int':
                            try:
                                defaultValue = int(strDefaultValue)
                                nDecimal = 0
                            except ValueError:
                                defaultValue = strDefaultValue
                        elif argtype == 'float':
                            try:
                                defaultValue = float(strDefaultValue)
                                splitStrvalue = strDefaultValue.split('.')
                                if len(splitStrvalue) == 2:
                                    nDecimal = len(splitStrvalue[1].strip())
                                else:
                                    nDecimal = 0
                            except ValueError:
                                defaultValue = strDefaultValue
                        return (argtype, argname, 'error', defaultValue, (minValue, maxValue, nDecimal, mod))
                elif len(splitargInfo) == 2:
                    strDefaultValue, rest = splitargInfo
                    strDefaultValue = strDefaultValue.strip()
                    boolValueError = False
                    try:
                        defaultValue = float(strDefaultValue)
                    except ValueError:
                        if strDefaultValue.startswith('$'):
                            try:
                                hexstring = strDefaultValue.split('$', 1)[1]
                                int(hexstring, 16)
                                return (argtype, argname, 'color', hexstring, None)
                            except ValueError:
                                return (argtype, argname, 'error', None, None)
                        else:
                            try:
                                defaultValue = float(strValue)
                                strDefaultValue = strValue
                            except:
                                defaultValue = None
                                #~ strDefaultValue = ''
                    splitrest = rest.split(')', 1)
                    if len(splitrest) == 2:
                        rangeInfo, extra = splitrest
                    else:
                        rangeInfo = rest
                        extra = ''
                    splitrangeInfo = rangeInfo.split(' to ')
                    if len(splitrangeInfo) == 2:
                        strMinValue, restRangeInfo = [s.strip() for s in splitrangeInfo]
                        try:
                            minValue = float(strMinValue)
                        except ValueError:
                            boolValueError = True
                        splitrestRangeInfo = restRangeInfo.split(' by ')
                        if len(splitrestRangeInfo) == 2:
                            strMaxValue, strStepSize = [s.strip() for s in splitrestRangeInfo]
                        else:
                            strMaxValue = restRangeInfo.strip()
                            strStepSize = None
                        try:
                            maxValue = float(strMaxValue)
                        except ValueError:
                            boolValueError = True
                        if argtype == 'int':
                            nDecimal = 0
                        if strStepSize is None and not boolValueError:
                            strStepSize = ''
                            # Get the step size from the strDefaultValue, strMinValue, strMaxValue
                            nDecimals = []
                            for eachValue in (strDefaultValue, strMinValue, strMaxValue):
                                splitStrvalue = eachValue.split('.')
                                if len(splitStrvalue) == 2:
                                    nDecimal = len(splitStrvalue[1].strip())
                                else:
                                    nDecimal = 0
                                nDecimals.append(nDecimal)
                            nDecimal = max(nDecimals)
                        elif not boolValueError:
                            try:
                                stepSize = float(strStepSize)
                                if stepSize > 1.0:
                                    nDecimal = 0
                                    mod = int(stepSize)
                                else:
                                    try:
                                        nDecimal = len(strStepSize.split('.')[1].strip())
                                    except IndexError:
                                        nDecimal = 0
                                        mod = None
                            except ValueError:
                                boolValueError = True
                    else:
                        choices = rangeInfo.split('/')
                        if len(choices) > 1: # list of integers
                            try:
                                defaultValue = int(defaultValue)
                            except TypeError:
                                defaultValue = strDefaultValue
                            choices = [choice.strip() for choice in choices]
                            return (argtype, argname, 'intlist', defaultValue, choices)
                    if boolValueError:
                        return (argtype, argname, 'error', strDefaultValue, (strMinValue, strMaxValue, 0, strStepSize))
                errType, errMsg, sliderValues = self.ValidateAvsSliderInputs(strDefaultValue, strMinValue, strMaxValue, strStepSize)
                if errType is not None:
                    return (argtype, argname, 'error', strDefaultValue, (strMinValue, strMaxValue, 0, strStepSize))
                if None in (defaultValue, minValue, maxValue, nDecimal):
                    return (argtype, argname, 'error', strDefaultValue, (strMinValue, strMaxValue, 0, strStepSize))
                if argtype == 'int':
                    defaultValue = int(defaultValue)
                    minValue = int(minValue)
                    maxValue = int(maxValue)
                return (argtype, argname, 'slider', defaultValue, (minValue, maxValue, nDecimal, mod))
            elif argtype == 'bool':
                defaultValue = argInfo.strip()
                if defaultValue.lower() in ('true', 'false'):
                    return (argtype, argname, 'boolradio', defaultValue, None)
                else:
                    return (argtype, argname, 'error', defaultValue, None)
            elif argtype == 'string' or argtype == 'c_string':
                splitargInfo = argInfo.split('(',1)
                defaultValue = None
                if len(splitargInfo) == 2:
                    strDefaultValue, rest = splitargInfo
                    defaultValue = strDefaultValue.strip()
                    if defaultValue:
                        defaultValue = '"%s"' % defaultValue.strip('"')
                    # GPo, new replace short colorspace to full colorspace
                    if argtype == 'c_string':
                        argtype = 'string'
                        rest = rest.replace('"avsRGBP"', utils.avsRGBP, 1).\
                            replace('"avsY"', utils.avsY, 1).\
                                replace('"avsYUV"', utils.avsYUV, 1)
                    ###
                    choices = ['"%s"' % s.strip(' "') for s in rest.split(')')[0].split('/')]
                else:
                    return (argtype, argname, 'error', argInfo.strip(), None)

                if '/'.join(choices).count('*.') > 0:
                    # Filename selector
                    extList = [s.strip('"') for s in choices if s.strip('"').startswith('*.')]
                    return (argtype, argname, 'stringfilename', defaultValue, extList)
                else:
                    return (argtype, argname, 'stringlist', defaultValue, choices)
            else:
                return (argtype, argname, 'clip', None, None)
        else:
            # No database info
            if argtype == 'bool':
                return (argtype, argname, 'boolradio', None, None)
            return (argtype, argname, 'undocumented', None, None)

    def SetScriptTabname(self, name, script=None, index=None):
        if index is not None:
            self.scriptNotebook.SetPageText(index, name)
            if index == self.scriptNotebook.GetSelection():
                self.UpdateProgramTitle()
            return
        if script == self.scriptNotebook.GetCurrentPage():
            index = self.scriptNotebook.GetSelection()
            self.scriptNotebook.SetPageText(index, name)
            self.UpdateProgramTitle()
        else:
            for index in xrange(self.scriptNotebook.GetPageCount()):
                if script == self.scriptNotebook.GetPage(index):
                    self.scriptNotebook.SetPageText(index, name)
                    return

    def UpdateScriptTabname(self, script=None, index=None, allTabs=False):
        if allTabs:
            for index in xrange(self.scriptNotebook.GetPageCount()):
                self.scriptNotebook.UpdatePageText(index)
            self.UpdateProgramTitle()
            return
        if index is not None:
            self.scriptNotebook.UpdatePageText(index)
            if index == self.scriptNotebook.GetSelection():
                self.UpdateProgramTitle()
            return
        if script == self.scriptNotebook.GetCurrentPage():
            index = self.scriptNotebook.GetSelection()
            self.scriptNotebook.UpdatePageText(index)
            self.UpdateProgramTitle()
        else:
            for index in xrange(self.scriptNotebook.GetPageCount()):
                if script == self.scriptNotebook.GetPage(index):
                    self.scriptNotebook.UpdatePageText(index)
                    return

    def UpdateProgramTitle(self, title=None):
        if title is None:
            title = self.GetProgramTitle()
        self.SetTitle('%s - %s' % (title, self.name))
        if self.separatevideowindow:
            self.videoDialog.SetTitle('%s - [%s]' % (title, self.name))

    def GetProgramTitle(self, allowfull=True):
        script = self.currentScript
        filename = script.filename
        #~ if allowfull and self.options['showfullname'] and filename:
        if allowfull and filename:
            tabname = filename
            if script.group is not None:
                tabname = u'[{0}] {1}'.format(script.group, tabname)
            pOK = self.previewOK(script)
            if script.GetModify():
                tabname = '* ' + tabname if pOK else '>* ' + tabname
            elif not pOK:
                tabname = '>' + tabname
        else:
            index = self.scriptNotebook.GetSelection()
            tabname = self.scriptNotebook.GetPageText(index, full=True)
        return tabname

    def UpdateTabImages(self):
        if self.options['usetabimages']:
            if self.options['multilinetab']:
                rows = self.scriptNotebook.GetRowCount()
            if (self.FindFocus() == self.videoWindow) or self.separatevideowindow:
                for i in xrange(min(self.scriptNotebook.GetPageCount(), 10)):
                    self.scriptNotebook.SetPageImage(i, i)
            else:
                for i in xrange(self.scriptNotebook.GetPageCount()):
                    self.scriptNotebook.SetPageImage(i, -1)
            if self.options['multilinetab']:
                if rows != self.scriptNotebook.GetRowCount():
                    w, h = self.scriptNotebook.GetSize()
                    self.scriptNotebook.SetSize((w, h-1))
                    self.scriptNotebook.SetSize((w, h))
        # Test it again, multiline flickers if this not used
        elif self.options['multilinetab']:
            rows = self.scriptNotebook.GetRowCount()
            if rows != self.scriptNotebook.GetRowCount():
                w, h = self.scriptNotebook.GetSize()
                self.scriptNotebook.SetSize((w, h-1))
                self.scriptNotebook.SetSize((w, h))

    def ShowWarningOnBadNaming(self, baddllnameList, isFunc=False):
        int10 = intPPI(10)
        wx.Bell()
        dlg = wx.Dialog(self, wx.ID_ANY, _('Warning'))
        bmp = wx.StaticBitmap(dlg, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_WARNING))
        baddllnameList.append('\n')
        if not isFunc:
            message = wx.StaticText(dlg, wx.ID_ANY, '.{0}\n'.format('dll' if os.name == 'nt' else 'so').join(baddllnameList) +\
                                                    _('Above plugin names contain undesirable symbols.\n'
                                                      'Rename them to only use alphanumeric or underscores,\n'
                                                      'or make sure to use them in short name style only.'))
        else:
            message = wx.StaticText(dlg, wx.ID_ANY, '\n'.join(baddllnameList) +\
                                                    _('This function is beta!\nFound more then one function with the same name.\n'
                                                      'You should clean up your plugins.'))
        msgsizer = wx.BoxSizer(wx.HORIZONTAL)
        msgsizer.Add(bmp)
        msgsizer.Add(message, 0, wx.LEFT, int10)

        checkbox = wx.CheckBox(dlg, wx.ID_ANY, _("Don't show me this again"))
        btnsizer = dlg.CreateStdDialogButtonSizer(wx.OK)

        dlgsizer = wx.BoxSizer(wx.VERTICAL)
        dlgsizer.Add(msgsizer, 0, wx.ALL, int10)
        dlgsizer.Add(checkbox, 0, wx.LEFT, int10)
        dlgsizer.Add(btnsizer, 0, wx.ALL|wx.ALIGN_CENTER, int10)
        dlg.SetSizerAndFit(dlgsizer)
        dlg.ShowModal()
        if isFunc:
            self.options['doublefuncnamewarning'] = not checkbox.IsChecked()
        else:
            self.options['dllnamewarning'] = not checkbox.IsChecked()
        dlg.Destroy()

    # GPo 2022, separate dialog for DPI settings
    def ShowDpiOptions(self, event=None):
        info = self.getOptionsDpiDlgInfo()
        parent = self.dummyObject if isinstance(self.dummyObject,wxp.OptionsDialog) else self
        dlg = wxp.OptionsDialog(parent, info, self.options, 'Font DPI Settings', starText=False, canResize=False)
        ID = dlg.ShowModal()
        try:
            if ID == wx.ID_OK:
                if isinstance(self.dummyObject, wxp.OptionsDialog):
                    # self.optionsDlg cann also chancel the changes
                    self.dummyObject.options.update(dlg.GetDict())
                else:
                    # if external called save directly
                    self.options.update(dlg.GetDict())
                    with open(self.optionsfilename, mode='wb') as f:
                        cPickle.dump(self.options, f, protocol=0)
        finally:
            dlg.Destroy()

    def ShowOptions(self, startPageIndex=0): # PPI set on wxp
        '''Show the program settings dialog, save them, apply them if necessary and save to file'''
        dlg = wxp.OptionsDialog(self, self.optionsDlgInfo, self.options,
                                startPageIndex=startPageIndex,
                                invert_scroll=self.options['invertscrolling'], dlgsize=self.options['optionsdlgsize'])
        self.dummyObject = dlg
        self.options['exitstatus'] = 1  # GPo 2020, set default
        sliderwindowcustomtheme = self.options['sliderwindowcustomtheme']
        sliderWindowShown = self.videoSplitter.IsSplit()
        script = self.currentScript
        #self.HideSliderWindow(script)
        ID = dlg.ShowModal()
        self.dummyObject = None
        self.optionsLastPageIndex = dlg.GetPageIndex()
        # Set the data
        if ID == wx.ID_OK:
            old_plugins_directory = self.ExpandVars(self.options['pluginsdir'])
            old_prefer_functions = self.options['syntaxhighlight_preferfunctions']
            old_style_triple_quotes = self.options['syntaxhighlight_styleinsidetriplequotes']
            old_use_custom_video_background = self.options['use_customvideobackground']
            old_custom_video_background = self.options['customvideobackground']
            self.options.update(dlg.GetDict())
            self.options['optionsdlgsize'] = dlg.GetSize()
            # GPo, reset it if the user clears the plugins path. Invalid path is already checked
            # do not use default values, that can be wrong.
            if not self.options['pluginsdir']:
                self.options['pluginsdir'] = old_plugins_directory
            elif self.options['plugindirregister']:
                if self.options['pluginsdir'] != old_plugins_directory:
                    self.SetPluginsDirectory(old_plugins_directory)
            self.options['plugindirregister'] = False
            self.progressDelayTime = self.options['progressdelaytime']

            for key in ['altdir', 'workdir', 'pluginsdir', 'avisynthhelpfile',
                        'externalplayer', 'docsearchpaths']:
                self.options[key] = self.ExpandVars(self.options[key], False, '%' + key + '%')
            self.options['colourdata'] = self.colour_data.ToString()
            with open(self.optionsfilename, mode='wb') as f:
                cPickle.dump(self.options, f, protocol=0)
            if self.options['useworkdir'] and self.options['workdir']:
                os.chdir(self.ExpandVars(self.options['workdir']))
            else:
                os.chdir(self.initialworkdir)
            for i in xrange(self.scriptNotebook.GetPageCount()):
                script = self.scriptNotebook.GetPage(i)
                if (self.options['syntaxhighlight_preferfunctions'] != old_prefer_functions or
                    self.options['syntaxhighlight_styleinsidetriplequotes'] != old_style_triple_quotes):
                        script.styling_refresh_needed = True
                script.SetUserOptions()
                if not self.options['usetabimages']:
                    self.scriptNotebook.SetPageImage(i, -1)
            self.UpdateScriptTabname(script)
            style = wx.NO_BORDER
            if self.options['multilinetab']:
                style |= wx.NB_MULTILINE
            if self.options['fixedwidthtab']:
                style |= wx.NB_FIXEDWIDTH
            self.scriptNotebook.SetWindowStyleFlag(style)
            # a workaroud for multiline notebook issue
            w, h = self.scriptNotebook.GetSize()
            self.scriptNotebook.SetSize((w, h-1))
            self.scriptNotebook.SetSize((w, h))
            self.SetMinimumScriptPaneSize()
            for slider in self.GetVideoSliderList():
                slider.numDivisor = self.options['timelinenumdivisor']
                if slider.offsetSet:
                    slider.SetValue(slider.GetValue())
            if self.options['periodicbackup']:
                self.backupTimer.Start(self.options['periodicbackup'] * 60000)
            elif self.backupTimer.IsRunning():
                self.backupTimer.Stop()
            if (old_use_custom_video_background != self.options['use_customvideobackground'] or
                self.options['use_customvideobackground'] and
                old_custom_video_background != self.options['customvideobackground']):
                    self.OnEraseBackground()
            self.SetExternalToolMenuLabel()
            dlg.Destroy()

            if self.options['exitstatus'] == 2:  # GPo
                self.ExitProgram(restart=True)
            else: # GPo, disable the update for preview filters, clear the resources
                if not self.options['autoslideron']:
                    self.HideSliderWindow(script)
                    self.toggleSliderWindowButton.Disable()
                    self.SlidersContextMenu = None
                    for i in range(self.scriptNotebook.GetPageCount()):
                        script = self.scriptNotebook.GetPage(i)
                        script.toggleTags = []
                        script.oldToogleTags = []
                        script.sliderProperties = []
                        script.sliderTexts = []
                        script.oldSliderTexts = []
                        script.autoSliderInfo = []
                        script.oldAutoSliderInfo = []
                        script.sliderToggleLabels = []
                        script.SliderFoldsBackup = {}
                        script.toggleTagSizer.Clear(deleteWindows=True)
                        script.sliderSizerNew.Clear(deleteWindows=True)
                    return
                elif sliderwindowcustomtheme != self.options['sliderwindowcustomtheme']:
                    for i in range(self.scriptNotebook.GetPageCount()):
                        script = self.scriptNotebook.GetPage(i)
                        if self.options['sliderwindowcustomtheme']:
                            script.sliderWindow.SetThemeColors()
                        else:
                            script.sliderWindow.SetSystemColors()
                        script.chkDisableRefresh.SetForegroundColour(script.sliderWindow.GetForegroundColour())
                        script.chkPreviewFilter.SetForegroundColour(script.sliderWindow.GetForegroundColour())
                    self.OnSliderUpdate(None)
        else:
            dlg.Destroy()
        #if sliderWindowShown:
            #self.ShowSliderWindow(script)

    # GPo, changed
    def SetPluginsDirectory(self, oldpluginsdirectory):
        '''Set the plugins autoload directory

        AviSynth: write to registry (admin rights needed)
        AvxSynth: set an environment variable

        ##### This is the wormy part ;) if Avisynth path is not found, 'defaultpluginsdir' is faulty and all go wrong.
        if not self.options['pluginsdir']:
            self.options['pluginsdir'] = self.defaultpluginsdir
        ################
        '''

        pluginsdir_exp = self.ExpandVars(self.options['pluginsdir'])
        if not os.path.isdir(pluginsdir_exp):
            self.options['pluginsdir'] = old_plugins_directory
            return
        if os.name == 'nt':
            s1 = (_("Changing the plugins directory writes to the Windows registry.\n") +
                  _("Writing to: HKLM\Software\Avisynth\plugindir2_5\n")+
                  _(" Admin rights are needed."))
            s2 = _("Do you wish to continue?")
            ret = wx.MessageBox('%s\n\n%s' % (s1, s2), _('Warning'), wx.YES_NO|wx.ICON_EXCLAMATION)
            if ret == wx.YES:
                f = tempfile.NamedTemporaryFile(delete=False)
                txt = textwrap.dedent(u'''\
                HKLM\\Software\\Avisynth
                'plugindir2_5'= "{dir}"
                ''').format(dir=pluginsdir_exp)
                f.write(txt.encode('utf16'))
                f.close()
                if ctypes.windll.shell32.ShellExecuteW(None, u'runas', u'cmd',
                        u'/k "regini "{f}" & del "{f}""'.format(f=f.name), None, 0) > 32:
                    self.options['customplugindir'] = False
                    return
                else:
                    wx.MessageBox(_('Plugins dir registration failed'), _('Error'), wx.OK|wx.ICON_ERROR)
            self.options['pluginsdir'] = oldpluginsdirectory
        else:
            os.environ['AVXSYNTH_RUNTIME_PLUGIN_PATH'] = pluginsdir_exp
            shell = os.environ.get('SHELL') # write to the shell's rc file
            if shell:
                rc = os.path.expandvars(os.path.join('$HOME', '.{0}rc'.format(
                                        os.path.basename(shell))))
                if os.path.isfile(rc):
                    warning = _("You're changing the plugins autoload directory.\n"
                                'Do you wish to change it for all applications? This will\n'
                                'require writing to {0}'
                               ).format(rc)
                    ret = wx.MessageBox(warning, _('Warning'), wx.YES_NO|wx.ICON_EXCLAMATION)
                    if ret == wx.YES:
                        export = u'export AVXSYNTH_RUNTIME_PLUGIN_PATH="{0}"'.format(pluginsdir_exp)
                        with open(rc, 'r+') as f:
                            lines = f.readlines()
                            for i, line in enumerate(lines):
                                if 'AVXSYNTH_RUNTIME_PLUGIN_PATH' in line:
                                    lines[i] = export
                                    f.seek(0)
                                    f.truncate()
                                    f.writelines(lines)
                                    break
                            else:
                                f.write(export)
                        self.options['customplugindir'] = False

    def getMacrosLabelFromFile(self, filename):
        f = open(filename)
        text = f.readline().strip('#').strip()
        f.close()
        return text

    def ExpandVars(self, text, expand=True, blacklist=''):
        '''Expand and unexpand program variables

        Variables: %programdir%, %avisynthdir%, %pluginsdir%

        '''
        vars_ = [('%pluginsdir%', self.options['pluginsdir']),
                 ('%avisynthdir%', self.avisynthdir),
                 ('%programdir%', self.programdir)]
        blacklist = blacklist.split(';')
        if expand:
            index = 0, 1
            text = os.path.expandvars(text)
        else:
            index = 1, 0
            if '%altdir%' in blacklist:
                blacklist.append('%avisynthdir%')
        vars_ = filter(lambda x:x[0] not in blacklist, vars_)
        for var in [var for var in vars_ if var[1]]:
            text = text.replace(var[index[0]], var[index[1]])
        return text

    def FormatTime(self, s):
        '''Format seconds (int/float) to hours, minutes and seconds (str)'''
        m, s = divmod(s, 60)
        h, m = divmod(m, 60)
        try:                                          # GPo x64 error s = NaN
            #return '%02i:%02i:%06.3f' % (h , m, s)
            # GPo, (hello_hello) second's trunc float, display the same as avisynth's showTime()
            return '%02i:%02i:%06.3f' % (h , m, int(s * 1000)/1000.0)
        except:
            return '00:00:00.nan'

    # Macro-related functions
    @AsyncCallWrapper
    def MacroIsMenuChecked(self, text):
        r'''IsMenuChecked(text)

        Retrieve the state of a menu item under Macros menu. The parameter 'text' has
        the same meaning as that one of ExecuteMenuCommand function.

        '''
        if text.count('->') > 0:
            # text is the menu command name
            index = 0
        else:
            # text is the menu command shortcut string
            index = 1
        # Search through self.optionsShortcuts for a match
        if text == '':
            return False
        if self.macrosStack:
            menuItem = self.GetMenuBar().GetMenu(self.macroMenuPos).FindItemById(self.macrosStack[-1])
            menu = menuItem.GetMenu()
        else:
            menu = None
        for item in self.options['shortcuts']:
            if text.lower() == item[index].lower():
                id = item[2]
                menuItem = self.GetMenuBar().FindItemById(id)
                if menuItem.IsCheckable():
                    return menuItem.IsChecked()
                return False
            # assume using a incomplete text, search under the menu of the current running macro
            elif menu and item[0].lower().endswith(text.lower()):
                id = item[2]
                menuItem = menu.FindItemById(id)
                if menuItem:
                    if menuItem.IsCheckable():
                        return menuItem.IsChecked()
                    return False
        return False

    @AsyncCallWrapper
    def MacroExecuteMenuCommand(self, text, callafter=False):
        r'''ExecuteMenuCommand(text, callafter=False)

        Executes one of AvsP's menu commands as specified by the input 'text', which
        can either be the name of the menu command or the keyboard shortcut.

        For example, you can create a new tab in a macro by using either
        "avsp.ExecuteMenuCommand('File -> New Tab')" or by using
        "avsp.ExecuteMenuCommand('Ctrl+N')".  In this manner all menu commands are
        available to AvsP's macro language.  The input text is not case sensitive,
        but must be spelled precisely in order to work (a complete list of all the
        commands and shortcuts with precise spelling can be found in the
        "Options -> Configure shortcuts..." dialog).  If callafter=True, the menu
        command will run after the current macro has exited.

        Returns True if successful, False otherwise.

        '''
        if text.count('->') > 0:
            # text is the menu command name
            index = 0
        else:
            # text is the menu command shortcut string
            index = 1
        # Search through self.optionsShortcuts for a match
        if text == '':
            return False
        if self.macrosStack:
            menuItem = self.GetMenuBar().GetMenu(self.macroMenuPos).FindItemById(self.macrosStack[-1])
            menu = menuItem.GetMenu()
        else:
            menu = None
        for item in self.options['shortcuts']:
            if text.lower() == item[index].lower():
                id = item[2]
                event = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, id)
                if callafter:
                    self.GetEventHandler().AddPendingEvent(event)
                else:
                    self.GetEventHandler().ProcessEvent(event)
                return True
            # assume using a incomplete text, search under the menu of the current running macro
            elif menu and item[0].lower().endswith(text.lower()):
                id = item[2]
                menuItem = menu.FindItemById(id)
                if menuItem:
                    event = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, id)
                    if callafter:
                        self.GetEventHandler().AddPendingEvent(event)
                    else:
                        self.GetEventHandler().ProcessEvent(event)
                    return True
        return False

    @AsyncCallWrapper
    def MacroSaveScript(self, filename='', index=None, default=''):
        r'''SaveScript(filename='', index=None, default='')

        Saves all the unsaved changes of the script in the tab located at the integer
        'index'.  If 'index' is None, the script in the currently selected tab is used.

        The function will prompt the user with a dialog box for the location to save
        the file if the string 'filename' is not provided and the script does not
        already exist on the hard drive, using 'default' as the default filename;
        it can be just a directory or basename.

        If a file with the same name as 'filename' already exists, it is overwritten
        without any prompting.  The function returns the filename of the saved file.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return ''
        if filename == '':
            filename = script.filename
        self.SaveScript(filename, index, default=default)
        return script.filename

    @AsyncCallWrapper
    def MacroIsScriptSaved(self, index=None):
        r'''IsScriptSaved(index=None)

        Returns a boolean indicating whether the script in the tab located at the
        integer 'index' has any unsaved changes.  If 'index' is None, the script in
        the currently selected tab is used.  Returns False if there are any unsaved
        changes, True otherwise.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        return (not script.GetModify())

    @AsyncCallWrapper
    def MacroGetScriptFilename(self, index=None, propose=None, only=None):
        r'''GetScriptFilename(index=None, propose=None, only=None)

        Returns the name of the script at the tab located at the integer 'index',
        where an index of 0 indicates the first tab.  If 'index' is None, the
        currently selected tab is used.  The returned name is the filename of the
        script on the hard drive.  If the script has never been saved to the hard
        drive, the returned name is an empty string.

        If 'propose' is set, return a proposed save filepath for the script based
        on its filename, tab's title, first source in the script and user preferences.
        This path can be useful to open/save other files.  Posible 'propose' values:
        'general', 'image'.  If 'only' is set to 'dir' or 'base', return only the
        directory or basename respectively.
        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return None
        if propose:
            return self.GetProposedPath(index, type_=propose, only=only)
        if only:
            dir, base = os.path.split(script.filename)
            if only == 'dir':
                return dir
            if only == 'base':
                return base
        return script.filename

    @AsyncCallWrapper
    def MacroShowVideoFrame(self, framenum=None, index=None, forceRefresh=False):
        r'''ShowVideoFrame(framenum=None, index=None, forceRefresh=False)

        This function refreshes the video preview (unhiding it if it is hidden) using
        the frame specified by the integer 'framenum', using the script of the tab
        located at the integer 'index'.  The function also automatically selects the
        tab located at 'index'.

        If 'framenum' is None, it uses the current frame number from the video preview
        slider.  If 'index' is None, the frame of the currently selected tab is shown.
        If the input 'forceRefresh' equals True, then the script is reloaded before
        showing the video frame (normally the script is reloaded only when the text
        has changed).

        '''
        # Get the desired script
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.ShowVideoFrame(framenum, forceRefresh=forceRefresh, script=script)
        self.SelectTab(index)
        self.Refresh()
        self.Update()
        if script.AVI.IsErrorClip():
            return False
        return True

    @AsyncCallWrapper
    def MacroShowVideoOffset(self, offset=0, units='frames', index=None):
        r'''ShowVideoOffset(offset=0, units='frames', index=None)

        Similar to ShowVideoFrame(), except the user specifies an offset instead of
        the direct frame.  Offset can be positive or negative (for backwards jumping).
        The string argument 'units' specifies the units of the offset, and can be either
        'frames', 'seconds', 'minutes', or 'hours'.

        '''
        # Get the desired script
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.ShowVideoOffset(offset=offset, units=units)
        self.SelectTab(index)
        self.Update()

    @AsyncCallWrapper
    def MacroUpdateVideo(self, index=None):
        r'''UpdateVideo(index=None)

        This function is similar to ShowVideoFrame(), but does not force the video
        preview to be shown if it is hidden.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False

        # GPO 2020, do not update if not needed
        if script == self.currentScript:
            if self.previewWindowVisible:
                self.ShowVideoFrame(forceRefresh=self.ScriptChanged(script), script=script)
            else:
                self.UpdateScriptAVI(script, forceRefresh=self.ScriptChanged(script))
        else:
            if self.previewWindowVisible:
                self.ShowVideoFrame(forceRefresh=True, script=script)
            else:
                self.UpdateScriptAVI(script, forceRefresh=True)

        if script.AVI is None or script.AVI.IsErrorClip():
            return False
        return True

    @AsyncCallWrapper
    def MacroWriteToScrap(self, txt, pos=-1, clear=False):
        r'''WriteToScrap(txt, pos=-1)

        This function is identical to InsertText, except that instead of writing to
        one of the existing tabs, it writes to a scrap window (which is always on top,
        making it useful to keep track of the text as it changes).  Any inserted text
        is highlighted temporarily.

        '''
        if not self.scrapWindow.IsShown():
            win = self.FindFocus()
            if win is None:
                win = self.currentScript
            self.scrapWindow.Show()
            win.SetFocus()
        if clear:
            self.scrapWindow.textCtrl.ClearAll()
        if self.InsertText(txt, pos, index=-1):
            scrap = self.scrapWindow.textCtrl
            txtLength = len(txt)
            txtPos = scrap.GetCurrentPos() - txtLength
            scrap.StartStyling(txtPos, 31)
            scrap.SetStyling(txtLength, stc.STC_P_WORD)
            scrap.nInserted += 1
            scrap.Refresh()
            scrap.Update()
            def UndoStyling(scrap):
                if scrap.nInserted > 0:
                    scrap.nInserted -= 1
                if scrap.nInserted == 0:
                    scrap.StartStyling(0, 31)
                    scrap.SetStyling(scrap.GetTextLength(), stc.STC_STYLE_DEFAULT)
            wx.FutureCall(1000, UndoStyling, scrap)
            return True
        else:
            return False

    @AsyncCallWrapper
    def MacroGetScrapText(self):
        r'''GetScrapText()

        Identical to the GetText function, except that it retrieves all text from the
        scrap window.

        '''
        return self.scrapWindow.GetText()

    @AsyncCallWrapper
    def MacroReplaceText(self, old, new):
        script = self.currentScript
        txt = script.GetText().replace(old, new)
        script.SetText(txt)
        script.GotoPos(script.GetLength())

    @AsyncCallWrapper
    def MacroSetText(self, txt, index=None):
        r'''SetText(txt, index=None)

        Similar to InsertText, but replaces all the text in the script of the tab
        located at the zero-based integer 'index' with the string 'txt'.  If the
        input 'index' is None, the text is inserted into the script of the currently
        selected tab.  Returns False if the operation failed, True otherwise.

        '''
        # Get the desired script
        script, index = self.getScriptAtIndex(index)
        if script is None or not isinstance(txt, basestring):
            return False
        # Replace the script's text
        script.SetText(txt)
        return True

    @AsyncCallWrapper
    def MacroGetText(self, index=None, clean=False):
        r'''GetText(index=None, clean=False)

        Returns the string containing all the text in the script of the tab located
        at the zero-based integer 'index'.  If the input 'index' is None, the text
        is retrieved from the script of the currently selected tab.  If 'clean' is
        True, strip sliders and tags from the returned text.  Returns False
        if the operation failed.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        txt = script.GetText()
        if clean:
            txt = self.getCleanText(txt)
        return txt

    @AsyncCallWrapper
    def MacroGetSelectedText(self, index=None):
        r'''GetSelectedText(index=None)

        Similar to GetText(), but returns only the selected text.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        return script.GetSelectedText()

    @AsyncCallWrapper
    def MacroGetFilename(self, title=_('Open a script or source'), filefilter=None, default=''):
        r'''GetFilename(title='Open a script or source', filefilter=None, default='')

        Displays an open file dialog box, returning the filename of the selected file
        if the user clicked "OK", returning an empty string otherwise.  filefilter=None
        means to apply those extensions defined at "Options|Extension templates".
        'default' is the default filename set in the dialog box; it can be just a
        directory or basename.

        '''
        default_dir, default_base = (default, '') if os.path.isdir(default) else os.path.split(default)
        initial_dir = default_dir if os.path.isdir(default_dir) else self.GetProposedPath(only='dir')
        if filefilter is None:
            extlist = self.options['templates'].keys()
            extlist.sort()
            extlist1 = ', '.join(extlist)
            extlist2 = ';*.'.join(extlist)
            filefilter = (_('Source files') + ' (%(extlist1)s)|*.%(extlist2)s|' +
                          _('All files') + ' (*.*)|*.*') %  locals()
        dlg = wx.FileDialog(self, title, initial_dir, default_base, filefilter,
                            wx.OPEN|wx.FILE_MUST_EXIST)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            filename = dlg.GetPath()
            dirname = os.path.dirname(filename)
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname
        else:
            filename = ''
        dlg.Destroy()
        return filename

    @AsyncCallWrapper
    def MacroGetSaveFilename(self, title=_('Save as'), filefilter = _('All files') + ' (*.*)|*.*', default=''):
        r'''GetSaveFilename(title='Save as', filefilter=_('All files') + ' (*.*)|*.*', default='')

        Displays an save file dialog box, returning the entered filename if the user
        clicked "OK", returning an empty string otherwise.  'default' is the default
        filename set in the dialog box; it can be just a directory or basename.

        '''
        default_dir, default_base = (default, '') if os.path.isdir(default) else os.path.split(default)
        initial_dir = default_dir if os.path.isdir(default_dir) else self.GetProposedPath(only='dir')
        dlg = wx.FileDialog(self, title, initial_dir, default_base, filefilter,
                            wx.SAVE|wx.OVERWRITE_PROMPT)
        ID = dlg.ShowModal()
        if ID == wx.ID_OK:
            filename = dlg.GetPath()
            dirname = os.path.dirname(filename)
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname
        else:
            filename = ''
        dlg.Destroy()
        return filename

    @AsyncCallWrapper
    def MacroGetDirectory(self, title=_('Select a directory'), default=''):
        r'''GetDirectory(title='Select a directory')

        Displays a dialog box to select a directory, returning the name of the
        selected directory if the user clicked "OK", returning an empty string
        otherwise.  'default' is the dialog's starting directory.

        '''
        initial_dir = default if os.path.isdir(default) else self.GetProposedPath(only='dir')
        dlg = wx.DirDialog(self, title, initial_dir)
        ID = dlg.ShowModal()
        if ID==wx.ID_OK:
            dirname = dlg.GetPath()
            if os.path.isdir(dirname):
                self.options['recentdir'] = dirname
        else:
            dirname = ''
        dlg.Destroy()
        return dirname

    @AsyncCallWrapper
    def MacroGetTextEntry(self, message=[''], default=[''], title=_('Enter information'), types=[''], width=400):
        r'''GetTextEntry(message='', default='', title='Enter information', types='text', width=400)

        Multiple entry dialog box.  In its more simple form displays a dialog box with
        the string 'message' along with a field for text entry, initially filled with
        the string 'default', returning the string from the text entry field if the
        user clicked "OK", an empty string otherwise.

        title: title of the dialog box.

        The 'message', 'default' and 'types' parameters are list of lists.  If a list
        were to contain only one component then it's not mandatory to wrap it as list.

        message: list of the lines of the dialog box, in which every component is a
        list of the corresponding text strings to the entries in that line.  There must
        be as many strings as desired entries.

        default: list of lists holding tuples with the default values for each entry.
        In the same way as lists, if a tuple were to contain only one element then
        it's not necessary to wrap it.  Each tuple and the whole parameter are optional
        except for list entry type.

        types: list of lists containing the types of each entry.  Each value and the
        whole parameter are optional.  Every omitted entry type defaults to a regular
        text field.

        Types available:

        - 'text': regular text field.
          'default' values: 1-tuple with the initial field text.

        - 'file_open': text field with additional browse for file button ("open"
              dialog).
          'default' values: 1-tuple or 2-tuple, with the initial field text and an
              optional file wildcard with this syntax:
              "BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"

        - 'file_save': same as 'file_open', but with a "save" dialog.

        - 'dir': text field with additional browse for directory button.
          'default' values: 1-tuple with the initial field text.

        - 'list_read_only': drop-down list.  The 'default' tuple is mandatory.
          'default' values: n+1 tuple, where the first n elements are the strings
              than compose the list and the last one is the entry selected by default.

        - 'list_writable': same as above but with the text field direcly writable, so
              the return value is not limited to a selection from the list.

        - 'check': simple check box, returning True if checked.
          'default' values: 1-tuple with the predetermined boolean value, False as
              default.

        - 'spin': numeric entry, with arrows to increment and decrement the value.
          'default' values: up-to-5-tuple, containing the default, minimum, maximum,
              decimal digits shown and increment when using the arrows. With zero
              decimal digits returns int, float otherwise.
              Default: (0, None, None, 0, 1)

        - 'slider_h': horizontal slider. Similar to 'spin', but with a draggable handle.
          'default' values: up-to-4-tuple containing the default, minimum, maximum and
              space between ticks marks that can be displayed alongside the slider.
              Default: (50, 0, 100, no ticks)

        - 'slider_v': vertical slider, same as above.

        - 'sep': separator formed by a text string and a horizontal line.
          'default' values: 1-tuple with an optional fixed line length (by default
              it extends through all the dialog's width).  Set it to -1 to auto-adjust
              to the text length.  Note that an invisible separator can be created by
              setting 'message' to '' and 'default' to 0 or -1.  To include the 'default'
              parameter but don't give a fixed length (e.g. there's more entries
              following that one) set the tuple to None or any not-convertible-to-int
              value, like ''.

        A not recognized type string, including '', defaults to 'text' type.

        width: minimal horizontal length of the dialog box.  The width is distributed
        uniformly between the entries in each line.

        Return values: list of entered values if the user clicks "OK", empty list
        otherwise.

        '''
        # Complete the 'default' and 'types' lists
        optionsDlgInfo = [['']]
        options = dict()
        key = 0
        if not isinstance(message, collections.MutableSequence): message = [message]
        if not isinstance(default, collections.MutableSequence): default = [default]
        if not isinstance(types, collections.MutableSequence): types = [types]
        default += [''] * (len(message) - len(default))
        types +=  [''] * (len(message) - len(types))
        for eachMessageLine, eachDefaultLine, eachTypeLine in zip(message, default, types):
            if not isinstance(eachMessageLine, collections.MutableSequence): eachMessageLine = [eachMessageLine]
            if not isinstance(eachDefaultLine, collections.MutableSequence): eachDefaultLine = [eachDefaultLine]
            if not isinstance(eachTypeLine, collections.MutableSequence): eachTypeLine = [eachTypeLine]
            lineLen=len(eachMessageLine)
            eachDefaultLine += [''] * (lineLen - len(eachDefaultLine))
            eachTypeLine +=  [''] * (lineLen - len(eachTypeLine))
            rowOptions = []
            for eachMessage, eachDefault, eachType in zip(eachMessageLine, eachDefaultLine, eachTypeLine):
                if not isinstance(eachDefault, collections.Sequence) or isinstance(eachDefault, basestring):
                    eachDefault = (eachDefault,)

                #  Set 'optionsDlgInfo' and 'options' from the kind of more user friendly 'message', 'default' and 'types'

                if eachType in ('file_open', 'file_save'):
                    key += 1
                    flag = (wxp.OPT_ELEM_FILE_OPEN if eachType == 'file_open'
                            else wxp.OPT_ELEM_FILE_SAVE )
                    startDirectory = eachDefault[0] if os.path.isdir(eachDefault[0]) else os.path.dirname(eachDefault[0])
                    if not os.path.isdir(startDirectory):
                        startDirectory = self.GetProposedPath(only='dir')
                    misc = dict(width=width / lineLen,
                        fileMask=eachDefault[1] if len(eachDefault) > 1 else '*.*',
                        startDirectory=startDirectory,
                        buttonText='...', buttonWidth=intPPI(30), label_position=wx.VERTICAL,
                        expand=True)
                    colOptions = [eachMessage, flag, key, '', misc]
                    options[key] = eachDefault[0]

                elif eachType == 'dir':
                    key += 1
                    flag = wxp.OPT_ELEM_DIR
                    startDirectory = eachDefault[0] if os.path.isdir(eachDefault[0]) else self.GetProposedPath(only='dir')
                    misc = dict(width=width / lineLen,
                        startDirectory=startDirectory,
                        buttonText='...', buttonWidth=intPPI(30), label_position=wx.VERTICAL,
                        expand=True)
                    colOptions = [eachMessage, flag, key, '', misc]
                    options[key] = eachDefault[0]

                elif eachType in ('list_writable', 'list_read_only'):
                    key += 1
                    flag = wxp.OPT_ELEM_LIST
                    misc = dict(width=width / lineLen, choices=eachDefault[:-1],
                        writable=True if eachType == 'list_writable' else False,
                        label_position=wx.VERTICAL, expand=True)
                    colOptions = [eachMessage, flag, key, '', misc]
                    options[key] = eachDefault[-1]

                elif eachType == 'check':
                    key += 1
                    flag = wxp.OPT_ELEM_CHECK
                    misc = dict(width=width / lineLen)
                    colOptions = [eachMessage, flag, key, '', misc]
                    options[key] = eachDefault[0] if eachDefault[0] else False

                elif eachType == 'spin':
                    key += 1
                    flag = wxp.OPT_ELEM_SPIN
                    misc = dict(width=width / lineLen, label_position=wx.VERTICAL,
                                expand=True)
                    params = ('min_val', 'max_val', 'digits', 'increment')
                    for i, param in enumerate(eachDefault[1:]):
                        if isinstance(param, basestring):
                            try:
                                misc[params[i]] = int(param)
                            except:
                                misc[params[i]] = float(param)
                        else:
                            misc[params[i]] = param
                    colOptions = [eachMessage, flag, key, '', misc]
                    options[key] = float(eachDefault[0]) if eachDefault[0] else 0

                elif eachType in ('slider_h', 'slider_v'):
                    key += 1
                    flag = wxp.OPT_ELEM_SLIDER
                    if eachType == 'slider_v':
                        orientation = wx.VERTICAL
                        width = intPPI(150)
                    else:
                        orientation = wx.HORIZONTAL
                        width = width / lineLen
                    misc = dict(width=width, label_position=wx.VERTICAL,
                                orientation=orientation, expand=True)
                    params = ('minValue', 'maxValue', 'TickFreq')
                    for i, param in enumerate(eachDefault[1:]):
                        misc[params[i]] = int(param)
                    colOptions = [eachMessage, flag, key, '', misc]
                    options[key] = int(eachDefault[0]) if eachDefault[0] != '' else 50

                elif eachType == 'sep':
                    flag = wxp.OPT_ELEM_SEP
                    try:
                        sep_width = int(eachDefault[0])
                    except:
                        misc = dict()
                    else:
                        misc = dict(expand=False)
                        if sep_width == -1:
                            misc['adjust_width'] = True
                        else:
                            misc['width'] = sep_width
                    colOptions = [eachMessage, flag, 'mgte_sep', '', misc]

                else:
                    key += 1
                    flag = ''
                    misc = dict(width=width / lineLen, label_position=wx.VERTICAL)
                    colOptions = [eachMessage, flag, key, '', misc]
                    options[key] = str(eachDefault[0])

                rowOptions.append(colOptions)
            optionsDlgInfo[0].append(rowOptions)

        # Open the dialog box and get the values
        dlg = wxp.OptionsDialog(self, optionsDlgInfo, options, title, starText=False,
                                invert_scroll=self.options['invertscrolling'])
        ID = dlg.ShowModal()
        values = []
        if ID == wx.ID_OK:
            values_dic = dlg.GetDict()
            for key in range(1, len(options.keys()) + 1):
                values.append(values_dic[key])
        dlg.Destroy()
        if len(message) == 1:
            if values:
                return values[0]
            return ''
        return values

    @AsyncCallWrapper
    def MacroMsgBox(self, message, title='', cancel=False):
        r'''MsgBox(message, title='', cancel=False)

        Displays a simple dialog box with the text string 'message' and title 'title',
        and an additional cancel button if 'cancel' is True.  Returns True if the user
        presses 'OK' and the cancel button is present, or always True if it's not.

        '''
        style = wx.OK
        if title == _('Error'):
            style |= wx.ICON_ERROR
        elif title == _('Warning'):
            style |= wx.ICON_EXCLAMATION
        if cancel:
            style |= wx.CANCEL
        action = wx.MessageBox(message, title, style)
        return True if action == wx.OK else False

    @AsyncCallWrapper
    def MacroProgressBox(self, max=100, message='', title=_('Progress')):
        r'''ProgressBox(max=100, message='', title='Progress')

        Returns a wxPython dialog control which displays the progress of any given
        task as a fraction of the input integer 'max'.

        In order to display the dialog, use its method Update(value, message), which
        takes in the new progress value and optionally a new message.  The method
        Update returns a tuple where its first component is False if the user clicked
        on the Cancel button, True otherwise.  Wrap this method with SafeCall if it's
        called within a thread.

        IMPORTANT: You must use the Destroy() method to destroy the dialog after you
        are done with it.

        '''
        return wx.ProgressDialog(
            title, message, max,
            style=wx.PD_CAN_ABORT|wx.PD_ELAPSED_TIME|wx.PD_REMAINING_TIME
        )

    @AsyncCallWrapper
    def MacroGetScriptCount(self):
        r'''GetTabCount()

        Returns the number of scripts currently open.

        '''
        return self.scriptNotebook.GetPageCount()

    @AsyncCallWrapper
    def MacroGetCurrentIndex(self):
        r'''GetCurrentTabIndex()

        Returns the zero-based index of the currently selected tab.

        '''
        return self.scriptNotebook.GetSelection()
    """
    def _x_MacroGetTabFilename(self, index=None):
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        return script.filename
    """
    @AsyncCallWrapper
    def MacroSaveImage(self, filename='', framenum=None, index=None, default='', quality=None, depth=None):
        r'''SaveImage(filename='', framenum=None, index=None, default='', quality=None, depth=8)

        Saves the video frame specified by the integer 'framenum' as a file specified
        by the string 'filename', where the video corresponds with the script at the
        tab integer 'index'.

        If 'filename' is an empty string, then the user is prompted with a dialog box
        with 'default' as the default filename; it can be just a directory or basename.
        If 'index' is None, then the currently selected tab is used.

        A quality level (0-100) can be specified for JPEG output. If the quality is
        not specified, it gets prompted from a dialog window.

        The image can be saved as RGB48 if 'depth' is 16 and the ouptut format PNG.
        In this case it's assumed that the script returns a fake clip double the real
        height.

        Returns the choosen filename if the image was saved, None otherwise.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.refreshAVI = True
        self.MacroShowVideoFrame(framenum, index)
        if self.UpdateScriptAVI(script) is None:
            wx.MessageBox(_('Error loading the script'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return
        return self.SaveImage(filename, index=index, default=default, quality=quality, depth=depth)

    @AsyncCallWrapper
    def MacroGetVideoWidth(self, index=None):
        r'''GetVideoWidth(index=None)

        Returns the width of the video of the script at the tab integer 'index'.  If
        'index' is None, then the currently selected tab is used.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.refreshAVI = True
        #~ self.MacroShowVideoFrame(None, index)
        if self.UpdateScriptAVI(script) is None:
            wx.MessageBox(_('Error loading the script'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        return script.AVI.Width

    @AsyncCallWrapper
    def MacroGetVideoHeight(self, index=None):
        r'''GetVideoHeight(index=None)

        Returns the height of the video of the script at the tab integer 'index'.  If
        'index' is None, then the currently selected tab is used.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.refreshAVI = True
        if self.UpdateScriptAVI(script) is None:
            wx.MessageBox(_('Error loading the script'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        return script.AVI.Height

    @AsyncCallWrapper
    def MacroGetVideoFramerate(self, index=None):
        r'''GetVideoFramerate(index=None)

        Returns the framerate of the video of the script at the tab integer 'index'.
        If 'index' is None, then the currently selected tab is used.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.refreshAVI = True
        if self.UpdateScriptAVI(script) is None:
            wx.MessageBox(_('Error loading the script'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        return script.AVI.Framerate

    @AsyncCallWrapper
    def MacroGetVideoFramecount(self, index=None):
        r'''GetVideoFramecount(index=None)

        Returns the framecount of the video of the script at the tab integer 'index'.
        If 'index' is None, then the currently selected tab is used.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.refreshAVI = True
        if self.UpdateScriptAVI(script) is None:
            wx.MessageBox(_('Error loading the script'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        return script.AVI.Framecount

    @AsyncCallWrapper
    def MacroGetPixelInfo(self, color='hex', wait=False, lines=False, waitTimeout=5):
        r'''GetPixelInfo(color='hex', wait=False, lines=False, waitTimeout=5)

        Waits for the user to left-click in a position of the video preview, showing
        it if hidden, and returns a tuple with the position and colour of the clicked
        pixel.  The colour representation can be specified with the 'color' parameter.
        Valid values: 'xy', 'hex', 'rgb', 'rgba', 'yuv', None.  If None
        or xy only returns the position.

        The position is counted from the top left corner.  If the user clicks on a
        part of the preview outside the video, the returned coordinates are set to
        the nearest video pixel and the colour to None.

        If the user doesn't click the video within the waitTimeout seconds after the
        preview is refreshed, returns None.

        If 'wait' is True waits for multiple clicks for waitTimeout seconds between
        each one and returns a list with the pixel data, empty list if not pixel was
        clicked.  Lines are marked over the video preview if 'lines' is True.
        Valide range for waitTimeout 5 to 30 seconds.

        If a get pixel info operation has already started, and you call the macro again
        with waitTimeout=-1, the macro will break the wait and returns.
        When the video window is closed the waiting time is also ended.

        '''
        if self.getPixelInfo or waitTimeout < 0:
            if waitTimeout < 0:
                if self.getPixelInfo:
                    wx.MessageBox(_('Get pixel info operation breaks'),
                             _('Information'), style=wx.OK|wx.ICON_INFORMATION)
                self.getPixelInfo = None
            else:
                wx.MessageBox(_('A get pixel info operation has already started'),
                                 _('Error'), style=wx.OK|wx.ICON_ERROR)
            return

        script = self.currentScript
        if not self.previewOK():
            return
        if script.AVI.DisplayWidth != script.AVI.Width or script.AVI.DisplayHeight != script.AVI.Height:
            wx.MessageBox(_('Display clip and source clip dimensions different'),
                             _('Error'), style=wx.OK|wx.ICON_ERROR)
            return
        if not self.MacroShowVideoFrame():
            return
        # GPo changed and added some things
        # added waitTimeout and you can break it with self.getPixelInfo = None (realized OnHidePreview)
        colors = ('xy', 'hex', 'rgb', 'rgba', 'yuv', 'yuva')
        try:
            i = colors.index(color.lower())
        except:
            i = 0
        waitTimeout = min(max(5, waitTimeout), 60) # range 5 to 30 seconds
        if wait:
            pixelInfo_list = []
            pixelColor_list = []
            starting_script = self.currentScript
            oldzoomfactor = self.zoomfactor
            old_flip_h = 'fliphorizontal' in self.flip
            old_flip_v = 'flipvertical' in self.flip
            dc = wx.ClientDC(self.videoWindow)
            dc.SetLogicalFunction(wx.INVERT) # TODO: delete old pen color code
            dc.SetDeviceOrigin(self.xo, self.yo)
            dc.SetUserScale(self.zoomfactor, self.zoomfactor)
            pen_width = 1.0 if lines else 3.0
            self.getPixelInfo = True
            while True and self.getPixelInfo is not None:
                start = time.time()
                if self.getPixelInfo is not None:
                    self.getPixelInfo = True
                while self.getPixelInfo:
                    time.sleep(0.05)
                    if (oldzoomfactor != self.zoomfactor or old_flip_h != ('fliphorizontal' in self.flip) or
                            old_flip_v != ('flipvertical' in self.flip)):
                        pixelScrolledXY_list = []
                        dc.SetUserScale(self.zoomfactor, self.zoomfactor)
                        oldzoomfactor = self.zoomfactor
                        old_flip_h = 'fliphorizontal' in self.flip
                        old_flip_v = 'flipvertical' in self.flip
                        for xy in pixelInfo_list:
                            pen_color = None
                            for color in reversed(pixelColor_list):
                                if color:
                                    pen_color = color
                                    break
                            if pen_color:
                                x, y = xy[0] if isinstance(xy[0], tuple) else xy
                                dc.SetPen(wx.Pen(wx.Colour(*((component + 128) % 256 for component in pen_color)),
                                                 round(pen_width / self.zoomfactor)))
                                if old_flip_h:
                                    x = self.currentScript.AVI.DisplayWidth - 1 - x
                                if old_flip_v:
                                    y = self.currentScript.AVI.DisplayHeight - 1 - y
                                x = dc.LogicalToDeviceX(x) - self.xo
                                y = dc.LogicalToDeviceY(y) - self.yo
                                p2 = [float(c) / self.zoomfactor for c in self.videoWindow.CalcScrolledPosition(x, y)]
                                pixelScrolledXY_list.append(p2)
                                p1 = pixelScrolledXY_list[-2] if lines and len(pixelScrolledXY_list) > 1 else p2
                                dc.DrawLinePoint(p1, p2)
                    if time.time() - start >= waitTimeout:
                        break
                    #wx.Yield()
                    self.SaveCallYield()
                else:
                    if self.getPixelInfo is None:
                        break
                    if i:
                        pixelInfo_list.append((self.pixelInfo[0], self.pixelInfo[i]))
                    else:
                        pixelInfo_list.append(self.pixelInfo[0])
                    pixelColor_list.append(self.pixelInfo[2])
                    pen_color = None
                    for color in reversed(pixelColor_list):
                        if color:
                            pen_color = color
                            break
                    if pen_color:
                        x, y = self.pixelInfo[0]
                        dc.SetPen(wx.Pen(wx.Colour(*((component + 128) % 256 for component in pen_color)),
                                         round(pen_width / self.zoomfactor)))
                        if old_flip_h:
                            x = self.currentScript.AVI.DisplayWidth - 1 - x
                        if old_flip_v:
                            y = self.currentScript.AVI.DisplayHeight - 1 - y
                        x = dc.LogicalToDeviceX(x) - self.xo
                        y = dc.LogicalToDeviceY(y) - self.yo
                        p2 = [float(c) / self.zoomfactor for c in self.videoWindow.CalcScrolledPosition(x, y)]
                        if lines and len(pixelInfo_list) > 1:
                            x0, y0 = pixelInfo_list[-2][0] if i else pixelInfo_list[-2]
                            if old_flip_h:
                                x0 = self.currentScript.AVI.DisplayWidth - 1 - x0
                            if old_flip_v:
                                y0 = self.currentScript.AVI.DisplayHeight - 1 - y0
                            x0 = dc.LogicalToDeviceX(x0) - self.xo
                            y0 = dc.LogicalToDeviceY(y0) - self.yo
                            p1 = [float(c) / self.zoomfactor for c in self.videoWindow.CalcScrolledPosition(x0, y0)]
                        else:
                            p1 = p2
                        dc.DrawLinePoint(p1, p2)
                    continue
                self.getPixelInfo = False
                break
            if starting_script == self.currentScript:
                self.PaintAVIFrame(dc, self.currentScript, self.currentframenum)
            return pixelInfo_list
        else:
            start = time.time()
            self.getPixelInfo = True
            while self.getPixelInfo:
                time.sleep(0.05)
                if time.time() - start >= waitTimeout:
                    break
                #wx.Yield()
                self.SaveCallYield()
            else:
                if i:
                    return self.pixelInfo[0], self.pixelInfo[i]
                else:
                    return self.pixelInfo[0]
            self.getPixelInfo = False

    @AsyncCallWrapper
    def MacroGetVar(self, var, index=None, forceRefresh=False):
        r'''GetVar(var, index=None)

        Returns the content of the avisynth variable 'var' at the tab integer 'index'.
        If 'index' is None, then the currently selected tab is used.  Returns None if
        the specified variable is not defined.

        Warning: If the variable is frame-dependent the returned value may be unreliable.
        Two conditions must be met to ensure that is correct:
        - Avisynth frame cache must be disabled, e.g. SetMemoryMax(1)
        - No filters that request multiple frames can be used in the script.

        '''
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        self.refreshAVI = True
        if self.UpdateScriptAVI(script, forceRefresh=forceRefresh) is None:
            wx.MessageBox(_('Error loading the script'), _('Error'), style=wx.OK|wx.ICON_ERROR)
            return False
        try:
            return script.AVI.env.get_var(var)
        except avisynth.AvisynthError as err:
            if str(err) != "NotFound":
                raise
            return

    @AsyncCallWrapper
    def MacroRunExternalPlayer(self, executable=None, args='', index=None):
        r'''RunExternalPlayer(executable=None, args='', index=None)

        Runs the external program specified by the string argument 'executable'.

        The first argument passed to the program is the filename of the preview script
        generated from the script located at the tab integer 'index'.  If 'index' is
        None, then the currently selected tab is used.  Additional arguments can be
        passed to the external program using the string parameter 'args'.

        If the specified executable does not exist, then the function returns False,
        otherwise it runs the executable program with the appropriate arguments and
        returns True.

        '''
        if executable is None:
            executable = self.options['externalplayer']
        script, index = self.getScriptAtIndex(index)
        if script is None:
            return False
        if not self.RunExternalPlayer(executable, script, args, prompt=False):
            return False
        return True

    # Don't use decorator on this one
    def MacroPipe(self, cmd, text=None, frames=None, y4m=False, reorder_rgb=False, wait=False, callback=None, stdout=None, stderr=None):
        r"""Pipe(cmd, text=None, frames=None, y4m=False, reorder_rgb=False, wait=False, callback=None, stdout=None, stderr=None)

        Pipe raw frame data to an external application (video only)

        cmd: right side of the pipe (Unicode string). Accepts several variables:
             {height}, {width}, {fps}, {frame_count}.
        text : script evaluated.  Defaults to the script in the current tab.  It
               can also be a path to an AviSynth script.
        frames: sequence of frames to send.  Defaults to the complete frame range
                of the evaluated text.
        y4m: add a yuv4mpeg2 header.  It can be a logical value or optionally a
             dict with some of the following keys:
             - colorspace: overrides the clip colorspace.
             - depth: for >8 bits per channel. It's appended to 'colorspace'.
             - width, height: may be necessary when piping fake data. It can be
               either an int or a modifier '[x*/]\d+', e.g. 'width':'/2' will
               signal half the width of the evaluated clip.
             - sar: 'X:Y' string.
             - X_stream, X_frame.
        reorder_rgb: convert BGR to RGB and BGRA to RGBA before piping.
        wait: wait for the process to finish.  If False, return the Popen object.
              If True, return a tuple (Popen object, return code).  The return code
              is 1 if the user cancels.
        callback: user function called before each frame is sent and after all frames
                  are piped.  It receives three arguments, number of the current frame
                  in the sequence, number of the current frame in the clip and total
                  frame count, and must return True to keep piping, False to cancel.
        stdout: file object where redirect stdout.  Defaults to sys.stdout on __debug__,
                nowhere otherwise.
        stderr: file object where redirect stderr.  Defaults to stdout.

        """

        # Evaluate text
        workdir_exp = self.ExpandVars(self.options['workdir'])
        if (self.options['useworkdir'] and self.options['alwaysworkdir']
            and os.path.isdir(workdir_exp)):
                workdir = workdir_exp
        else:
            workdir = self.currentScript.workdir if text is None else ''
        if text is None:
            text = self.getCleanText(self.currentScript.GetText())
            filename = self.currentScript.filename
            # vpy hack, remove when VapourSynth is supported
            if os.name == 'nt' and filename.endswith('.vpy'):
                self.SaveScript(filename)
        else:
            if os.path.isfile(text):
                filename = text
                text = self.GetTextFromFile(text)[0]
            else:
                filename = 'AVS script'
        clip = pyavs.AvsClip(text, filename, workdir, display_clip=False,
                             reorder_rgb=reorder_rgb, interlaced=self.interlaced)
        if not clip.initialized or clip.IsErrorClip():
            self.MacroMsgBox(u'\n\n'.join((_('Error loading the script'), clip.error_message)),
                             _('Error'))
            return
        if not frames:
            frames = range(clip.Framecount)
            total_frames = clip.Framecount
        elif callback:
            total_frames = len(frames)

        # Create pipe
        cmd = cmd.format(height=clip.Height, width=clip.Width, fps=clip.Framerate,
                         frame_count=clip.Framecount)
        cmd = cmd.encode(encoding)
        cmd = shlex.split(cmd)
        if stdout is None:
            stdout = sys.stdout if __debug__ else subprocess.PIPE
        if stderr is None:
            stderr = subprocess.STDOUT
        if os.name == 'nt':
            info = subprocess.STARTUPINFO()
            try:
                info.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                info.wShowWindow = subprocess.SW_HIDE
            except AttributeError:
                import _subprocess
                info.dwFlags |= _subprocess.STARTF_USESHOWWINDOW
                info.wShowWindow = _subprocess.SW_HIDE
            cmd = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=stdout,
                                   stderr=stderr, startupinfo=info)
        else:
            cmd = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=stdout,
                                   stderr=stderr)

        # Pipe the data and wait for the process to finish
        try:
            if y4m:
                if isinstance(y4m, dict):
                    y4m_frame = y4m.pop('X_frame', True)
                    if 'X_stream' in y4m:
                        y4m['X'] = y4m.pop('X_stream')
                    cmd.stdin.write(clip.Y4MHeader(**y4m))
                else:
                    y4m_frame = True
                    cmd.stdin.write(clip.Y4MHeader())
            else:
                y4m_frame = False
            for i, frame in enumerate(frames):
                if not callback or callback(i, frame, total_frames):
                    buf = clip.RawFrame(frame, y4m_frame)
                    error = clip.clip.get_error()
                    if not error:
                        cmd.stdin.write(buf)
                        continue
                    else:
                        self.MacroMsgBox(u'\n\n'.join((_('Error requesting frame {number}').
                                         format(number=frame), error)), _('Error'))
                cmd.terminate()
                if wait:
                    return cmd, 1
                return cmd
            cmd.stdin.close()
            if callback and not callback(total_frames, frame, total_frames):
                cmd.terminate()
                if wait:
                    return cmd, 1
                return cmd
            if wait:
                return cmd, cmd.wait()
            return cmd
        except Exception as err:
            try:
                if cmd.poll() is None:
                    cmd.terminate()
            except: pass
            raise err

    @AsyncCallWrapper
    def MacroGetBookmarkFrameList(self, title=False):
        r'''GetBookmarkList(title=False)

        Returns a list containing the video frame bookmarks currently set by the
        user.  Note that these are the standard frame bookmarks, and do not contain
        any selection startpoints or endpoints which may exist. If 'title' is True,
        returns a list of tuple (frame, title).

        '''
        bookmarkList = [value for value, bmtype in self.GetBookmarkFrameList().items()]
        if title:
            for i in range(len(bookmarkList)):
                title = self.titleDict.get(bookmarkList[i], '')
                bookmarkList[i] = (bookmarkList[i], title)
        return bookmarkList

    @AsyncCallWrapper
    def MacroSetBookmark(self, input):
        r'''SetBookmark(input)

        Toggle 'input' as a video frame bookmark.  If 'input' is a list, toggle each
        of its values as a video frame bookmark.  Each bookmark can be a single integer
        or a tuple (frame , title).  Returns True if successful, False otherwise.

        '''
        bmtype = 0
        try:
            value = int(input)
            self.AddFrameBookmark(value, bmtype)
            return True
        except (TypeError, ValueError):
            try:
                values = []
                for item in input:
                    if isinstance(item, basestring):
                        return self.MacroSetBookmark2(input)
                    values.append(int(item))
            except (TypeError, ValueError):
                return self.MacroSetBookmark2(input)
            lastindex = len(values) - 1
            for i, value in enumerate(values):
                if i != lastindex:
                    self.AddFrameBookmark(value, bmtype, refreshProgram=False)
                else:
                    self.AddFrameBookmark(value, bmtype, refreshProgram=True)
            return True
        return False

    def MacroSetBookmark2(self, input):
        r'''Set bookmarks from tuples (frame, title)'''
        bmtype = 0
        try:
            value, title = input
            value = int(value)
            if not isinstance(title, basestring): return False
            title = title.strip()
            self.titleDict[value] = title
            if not title:
                del self.titleDict[value]
            self.AddFrameBookmark(value, bmtype)
            return True
        except (TypeError, ValueError):
            if not isinstance(input, collections.Iterable):
                return False
            try:
                items = [(int(value), title.strip()) for value, title in input
                         if isinstance(title, basestring)]
                if len(items) != len(input): return False
            except (TypeError, ValueError):
                return False
            lastindex = len(items) - 1
            for i, item in enumerate(items):
                value, title = item
                self.titleDict[value] = title
                if not title:
                    del self.titleDict[value]
                if i != lastindex:
                    self.AddFrameBookmark(value, bmtype, refreshProgram=False)
                else:
                    self.AddFrameBookmark(value, bmtype, refreshProgram=True)
            return True
        return False

    @AsyncCallWrapper
    def MacroClearBookmarks(self, start=0, end=None, clear_current=True, clear_historic=False):
        r'''ClearBookmarks(start=0, end=None, clear_current=True, clear_historic=False)

        Clear all video frame bookmarks in the range [start, end], optionally
        deleting also historic bookmarks.

        '''
        if clear_current:
            self.DeleteAllFrameBookmarks(bmtype=0, start=start, end=end)
        if clear_historic:
            self.OnMenuVideoBookmarkClearHistory(start=start, end=end)

    @AsyncCallWrapper
    def MacroGetSliderSelections(self):
        r'''GetSelectionList()

        Returns a list containing the video frame selections created by AvsP's trim
        selection editor, where each element of the list is a 2-element tuple containing
        the startpoint and the endpoint of a selection.  Note that the trim selection
        editor must be visible for any selections to exist.

        '''
        return self.GetSliderSelections(self.invertSelection)

    @AsyncCallWrapper
    def MacroGetSliderInfo(self, index=None):
        r'''GetSliderInfo(index=None)

        Returns a list containing information for each slider in the script located
        at the tab integer 'index'.  If 'index' is None, then the currently selected
        tab is used.

        The slider information consists of 4 items.  The first item is the slider text
        itself.  The second item is the slider label.  The third item is the list of
        numbers which the graphical slider represents.  The fourth item is the number
        of decimal places for the slider numbers as specified by the user.

        '''
        script, index = self.getScriptAtIndex(index)
        self.UpdateScriptTagProperties(script)
        #~ self.UpdateScriptAVI(script, forceRefresh=True)
        data = self.createUserSliders(script, parseonly=True)
        info = []
        for text, values in data:
            if values is None:
                info.append((text, values))
                continue
            label, minval, maxval, val, nDecimal, step = values

            if step is None:
                step = 1/float(10**nDecimal)
            else:
                step = float(step)
            count = int(round((maxval - minval) / step + 1))
            numlist = [minval,] + map(lambda x: step*x + minval, range(1, count)) #+ [maxval,]
            if nDecimal == 0:
                numlist = [int(x) for x in numlist]
            info.append((text, label, numlist, nDecimal))
        return info

    @staticmethod
    def FormatDocstring(method=None, docstring=None):
        '''Format docstrings, adapted from PEP 257'''
        if docstring is None:
            docstring = method.__doc__
        if not docstring:
            return ''
        # Convert tabs to spaces (following the normal Python rules)
        # and split into a list of lines:
        lines = docstring.expandtabs().splitlines()
        # Determine minimum indentation (first line doesn't count):
        indent = sys.maxint
        for line in lines[1:]:
            stripped = line.lstrip()
            if stripped:
                indent = min(indent, len(line) - len(stripped))
        # Remove indentation (first line is special):
        trimmed = [lines[0].strip()]
        if indent < sys.maxint:
            for line in lines[1:]:
                trimmed.append(line[indent:].rstrip())
        doc = '\n'.join(trimmed).split('\n', 1)
        return doc[0] + '\n' + '='*len(doc[0]) + '\n' + doc[1] + '\n'


    class AvsP_functions(object):

        def __init__(self, parent):
            self.__doc__ = parent.FormatDocstring(docstring='''AVSPMOD MACRO API

                    AvsP allows you to define your own macros using the Python programming
                language.  In order to use this functionality, simply write your own Python
                code in a text file and save it in the "macros" directory with the extension
                ".py".  The next time you start AvsP.exe, your macro will appear in the
                "Macros" menu (the macros are sorted alphabetically).  The extension and
                any initial open-close brackets are removed in the displayed name - the file
                "[001] My Macro.py" shows up in the menu as "My Macro", in order to help
                order the macros in the menu.  If the striped name is empty, the first line
                from the script is used as the display name, removing '#' if present.
                Separators can be inserted in the menu by creating empty macro files with
                name "[001] ---.py".  To help further organize your macros, you can put
                macros in any subdirectories you create in the "macros" folder, which will
                automatically create submenus in the "Macros" menu.

                    Macro files can also be used to add options to the macro menu that can
                be read by any macro through the IsMenuChecked macro function.  To include
                a check option, create an empty macro and prefix its name with "ccc", e.g.
                "[001] ccc option name.py".  To add exclusive choices, create a macro for
                each option with the prefix "rrr".

                    Macros can optionally run in its own thread if the script includes a
                commentary line like "# run macro in new thread" (without quotes).  This
                makes possible to wait for the end of external commands started from the
                macro without locking AvsPmod.

                    You need to have a pretty good understanding of Python to write your own
                macros (plenty of documentation and tutorials for Python can be found on the
                web).  Several examples are provided in the "macros" directory to show basic
                usage, many more things are possible.  The following is a description of the
                functions provided in the local module avsp to give you control over the
                program itself (see the examples for appropriate usage).  This information
                can also be retrieved from the module or functions' docstring (help(avsp) or
                help(avsp.FunctionName)).\n
                ''')
            # Text setting and retrieving
            self.InsertText = parent.InsertText
            self.__doc__ += parent.FormatDocstring(self.InsertText)
            self.SetText = parent.MacroSetText
            self.__doc__ += parent.FormatDocstring(self.SetText)
            #~ ReplaceText = parent.MacroReplaceText
            self.GetText = parent.MacroGetText
            self.__doc__ += parent.FormatDocstring(self.GetText)
            self.GetSelectedText = parent.MacroGetSelectedText
            self.__doc__ += parent.FormatDocstring(self.GetSelectedText)
            self.GetSourceString = parent.GetSourceString
            self.__doc__ += parent.FormatDocstring(self.GetSourceString)
            self.GetSourceStringFromFilename = parent.GetSourceStringFromFilename
            self.__doc__ += parent.FormatDocstring(self.GetSourceStringFromFilename)
            self.GetPluginString = parent.GetPluginString
            self.__doc__ += parent.FormatDocstring(self.GetPluginString)
            self.GetFilename = parent.MacroGetFilename
            self.__doc__ += parent.FormatDocstring(self.GetFilename)
            self.GetSaveFilename = parent.MacroGetSaveFilename
            self.__doc__ += parent.FormatDocstring(self.GetSaveFilename)
            self.GetDirectory = parent.MacroGetDirectory
            self.__doc__ += parent.FormatDocstring(self.GetDirectory)
            self.GetTextEntry = parent.MacroGetTextEntry
            self.__doc__ += parent.FormatDocstring(self.GetTextEntry)
            self.WriteToScrap = parent.MacroWriteToScrap
            self.__doc__ += parent.FormatDocstring(self.WriteToScrap)
            self.GetScrapText = parent.MacroGetScrapText
            self.__doc__ += parent.FormatDocstring(self.GetScrapText)
            # Program tab control
            self.NewTab = parent.NewTab
            self.__doc__ += parent.FormatDocstring(self.NewTab)
            self.CloseTab = parent.CloseTab
            self.__doc__ += parent.FormatDocstring(self.CloseTab)
            self.SelectTab = parent.SelectTab
            self.__doc__ += parent.FormatDocstring(self.SelectTab)
            #~ GetTabFilename = parent.MacroGetTabFilename
            self.GetTabCount = parent.MacroGetScriptCount
            self.__doc__ += parent.FormatDocstring(self.GetTabCount)
            self.GetCurrentTabIndex = parent.MacroGetCurrentIndex
            self.__doc__ += parent.FormatDocstring(self.GetCurrentTabIndex)
            self.GetScriptFilename = parent.MacroGetScriptFilename
            self.__doc__ += parent.FormatDocstring(self.GetScriptFilename)
            # File opening and saving
            self.OpenFile = parent.OpenFile
            self.__doc__ += parent.FormatDocstring(self.OpenFile)
            self.SaveScript = parent.MacroSaveScript
            self.__doc__ += parent.FormatDocstring(self.SaveScript)
            self.SaveScriptAs = parent.SaveScript
            self.__doc__ += parent.FormatDocstring(self.SaveScriptAs)
            self.IsScriptSaved = parent.MacroIsScriptSaved
            self.__doc__ += parent.FormatDocstring(self.IsScriptSaved)
            self.RenameScript = parent.RenameScript
            self.__doc__ += parent.FormatDocstring(self.RenameScript)
            # Video related functions
            self.ShowVideoFrame = parent.MacroShowVideoFrame
            self.__doc__ += parent.FormatDocstring(self.ShowVideoFrame)
            self.ShowVideoOffset = parent.MacroShowVideoOffset
            self.__doc__ += parent.FormatDocstring(self.ShowVideoOffset)
            self.UpdateVideo = parent.MacroUpdateVideo
            self.__doc__ += parent.FormatDocstring(self.UpdateVideo)
            self.HideVideoWindow = parent.HidePreviewWindow
            self.__doc__ += parent.FormatDocstring(self.HideVideoWindow)
            self.GetFrameNumber = parent.GetFrameNumber
            self.__doc__ += parent.FormatDocstring(self.GetFrameNumber)
            self.GetVideoWidth = parent.MacroGetVideoWidth
            self.__doc__ += parent.FormatDocstring(self.GetVideoWidth)
            self.GetVideoHeight = parent.MacroGetVideoHeight
            self.__doc__ += parent.FormatDocstring(self.GetVideoHeight)
            self.GetVideoFramerate = parent.MacroGetVideoFramerate
            self.__doc__ += parent.FormatDocstring(self.GetVideoFramerate)
            self.GetVideoFramecount = parent.MacroGetVideoFramecount
            self.__doc__ += parent.FormatDocstring(self.GetVideoFramecount)
            self.GetPixelInfo = parent.MacroGetPixelInfo
            self.__doc__ += parent.FormatDocstring(self.GetPixelInfo)
            self.GetVar = parent.MacroGetVar
            self.__doc__ += parent.FormatDocstring(self.GetVar)
            self.RunExternalPlayer = parent.MacroRunExternalPlayer
            self.__doc__ += parent.FormatDocstring(self.RunExternalPlayer)
            self.Pipe = parent.MacroPipe
            self.__doc__ += parent.FormatDocstring(self.Pipe)
            self.SaveImage = parent.MacroSaveImage
            self.__doc__ += parent.FormatDocstring(self.SaveImage)
            # Bookmarks
            self.GetBookmarkList = parent.MacroGetBookmarkFrameList
            self.__doc__ += parent.FormatDocstring(self.GetBookmarkList)
            self.SetBookmark = parent.MacroSetBookmark
            self.__doc__ += parent.FormatDocstring(self.SetBookmark)
            self.ClearBookmarks = parent.MacroClearBookmarks
            self.__doc__ += parent.FormatDocstring(self.ClearBookmarks)
            self.GetSelectionList = parent.MacroGetSliderSelections
            self.__doc__ += parent.FormatDocstring(self.GetSelectionList)
            # Miscellaneous
            self.MsgBox = parent.MacroMsgBox
            self.__doc__ += parent.FormatDocstring(self.MsgBox)
            self.ProgressBox = parent.MacroProgressBox
            self.__doc__ += parent.FormatDocstring(self.ProgressBox)
            self.GetSliderInfo = parent.MacroGetSliderInfo
            self.__doc__ += parent.FormatDocstring(self.GetSliderInfo)
            self.ExecuteMenuCommand = parent.MacroExecuteMenuCommand
            self.__doc__ += parent.FormatDocstring(self.ExecuteMenuCommand)
            self.IsMenuChecked = parent.MacroIsMenuChecked
            self.__doc__ += parent.FormatDocstring(self.IsMenuChecked)
            def GetWindow():
                r'''GetWindow()

                Get the handler of AvsP's main window.  Don't use this except you know what
                you are doing.

                '''
                return parent
            self.GetWindow = GetWindow
            self.__doc__ += parent.FormatDocstring(self.GetWindow)
            def SafeCall(method, *args, **kwargs):
                r'''SafeCall(callable [, param1, ...])

                Run the function or method specified in a thread-safe way.  This wrapper is
                usually necessary when the code is run from a thread and the callable is not
                part of the macro API and interacts with the GUI:
                - Update method of ProgressBox
                - Resources obtained through GetWindow
                - Other wxPython resources obtained through importing wx.

                '''
                return AsyncCallWrapper(method)(*args, **kwargs)
            self.SafeCall = SafeCall
            self.__doc__ += parent.FormatDocstring(self.SafeCall)
            self.__doc__ += '\n' + '** VARIABLES **' + '\n'*3
            self.__doc__ += ('Version\n=======\n\nDictionary containing version info.  Keys:\n'
                             '[AvsP, AviSynth_string, AviSynth_number, AviSynth_interface]\n\n\n')
            self.__doc__ += ('Options\n=======\n\nThis dictionary can be used to store persistent '
                             'data.  Each macro have its \nown dictionary.\n\n\n')
            self.__doc__ += ('Last\n====\n\nThis variable contains the return value of the latest '
                             'executed macro.  It is \nuseful to create reusable macros.\n')


    def ExecuteMacro(self, macrofilename='', macroTxt='', return_env=False):

        if return_env:
            return self.AvsP_functions(self)

        def ShowException():
            if __debug__:
                raise
            match = re.match('\w+\((?:\d+,)?\s*[\'"](.*)[\'"],?\)$',
                             repr(sys.exc_info()[1]).decode('string_escape').decode(encoding))
            message = match.group(1) if match else sys.exc_info()[1]
            extra = ''
            for line in traceback.format_exc().split('\n'):
                if line.endswith('in AvsP_macro_main'):
                    try:
                        linenumber = int(line.split(',')[1].split()[1]) - 1
                        extra = ' (%s, line %i)' % (os.path.basename(macrofilename), linenumber)
                    except:
                        pass
                    break
            error_string = '%s\n\n%s%s' % (_('Error in the macro:'), message, extra)
            AsyncCall(wx.MessageBox, error_string, _('Error'), style=wx.OK|wx.ICON_ERROR).Wait()

        if os.path.isfile(macrofilename) or macroTxt:
            try:
                #~ execfile(macrofilename, {'avsp':AvsP_functions}, {})
                # Read the macro text
                if not macroTxt:
                    f = open(macrofilename)
                    #~ macroLines = f.readlines()
                    txt = f.read()
                    f.close()
                    macroLines = txt.split('\n')
                else:
                    macroLines = macroTxt.split('\n')

                # Check if the macro should run in its own thread
                re_thread = re.compile(r'\s*#\s*run[\s_]*(macro)?[\s_]*in[\s_]*(new)?[\s_]*thread', re.I)
                for line in macroLines:
                    if re.match(re_thread, line):
                        thread = True
                        break
                else:
                    thread = False
                # Check for syntax errors (thows SyntaxError exception with line number)
                try:
                    compile('\n'.join(macroLines+['pass']), macrofilename, 'exec')
                except SyntaxError as e:
                    if not str(e).startswith("'return' outside function"):
                        raise
                # Wrap the macro in a function (allows top-level variables to be treated "globally" within the function)
                lineList = []
                while macroLines and macroLines[0].lstrip().startswith('#'):
                    lineList.append(macroLines.pop(0))
                lineList += ['def AvsP_macro_main():'] + ['\t%s' % line for line in macroLines] + ['global last\nlast = AvsP_macro_main()']
                macrotxt = '\n'.join(lineList)
                # Prepare the macro variables
                self.macroVars['avsp'] = self.AvsP_functions(self)
                self.macroVars['avsp'].Version = dict(AvsP=self.version,
                                    AviSynth_string=self.avisynthVersion[0],
                                    AviSynth_number=self.avisynthVersion[1],
                                    AviSynth_interface=self.avisynthVersion[2])
                macrobasename = os.path.splitext(os.path.basename(macrofilename))[0]
                match = re.match(r'\[\s*\d+\s*\]\s*(.*)', macrobasename)
                if match:
                    macrobasename = match.group(1)
                if macrobasename not in self.optionsMacros:
                    self.optionsMacros[macrobasename] = {}
                self.macroVars['avsp'].Options = self.optionsMacros[macrobasename]
                hash_pre = hash(repr(self.optionsMacros[macrobasename].items()))
                self.macroVars['avsp'].Last = self.macroVars['last']
                def MacroHelp(function):
                    '''help(function)\nPrint the function's description of use'''
                    print (self.FormatDocstring(function))
                self.macroVars['help'] = MacroHelp
                self.macroVars['_'] = _
                # Execute the macro
                def MacroFunction():
                    try:
                        #GPo, @PF not working on py2.7, Error(arg 1 must be string or..)
                        #~exec (macrotxt in self.macroVars, {})
                        exec macrotxt in self.macroVars, {}
                    except:
                        ShowException()
                    if (hash(repr(self.optionsMacros[macrobasename].items())) != hash_pre and
                        os.path.isdir(os.path.dirname(self.macrosfilename))):
                            f = open(self.macrosfilename, mode='wb')
                            cPickle.dump(self.optionsMacros, f, protocol=0)
                            f.close()
                if thread:
                    thread = threading.Thread(target=MacroFunction, name='MacroThread')
                    thread.daemon = True
                    thread.start()
                else:
                    MacroFunction()
            except:
                ShowException()
        else:
            wx.MessageBox(_("Couldn't find %(macrofilename)s") % locals(), _('Error'), style=wx.OK|wx.ICON_ERROR)

    def RenameMacro(self, menu):
        for menuItem in menu.GetMenuItems():
            if menuItem.IsCheckable():
                id = menuItem.GetId()
                macrofilename = self.macrosImportNames[id]
                newname = macrofilename
                if menuItem.IsChecked():
                    newname = newname.replace('ccc', 'CCC')
                    newname = newname.replace('rrr', 'RRR')
                else:
                    newname = newname.replace('CCC', 'ccc')
                    newname = newname.replace('RRR', 'rrr')
                if newname != macrofilename:
                    try:
                        os.rename(macrofilename, newname)
                    except OSError:
                        pass

    def OnMenuDetachThread(self, event):
        dlg = wx.MessageDialog(self, _('For test purpose only!\nDetach the active thread from the script.\n'+
                                        'This enables the clip to be re-initialized.\n\n' +
                                        'Warning! The thread is still active and it can cause unforeseen problems.'),
                                'Detach thread from script', wx.OK|wx.CANCEL)
        ID = dlg.ShowModal()
        dlg.Destroy()
        if ID == wx.ID_OK:
            script, index = self.getScriptAtIndex(None)
            script.AviThread = None
            script.FrameThread = None
            #if script.AVI:
                #self.NewTab(copytab=True)
                #self.scriptNotebook.DeletePage(index)

""" Test FilterEvent
  Event_Skip = -1,
  Event_Ignore = 0,
  Event_Processed = 1
  wx.GetApp().SetCallFilterEvent(True)
"""
class MainApp(wxp.App):
    def OnInit(self):
        self.frame = MainFrame()
        self.SetTopWindow(self.frame)
        return True
    """
    def FilterEvent(self, event):
        t = event.GetEventType()
        if t == wx.EVT_KEY_DOWN.typeId:
            print('Key down')
        if t == wx.EVT_PAINT.typeId or t == wx.EVT_NC_PAINT.typeId or t == wx.EVT_ERASE_BACKGROUND.typeId:
            return -1
        return 0
    """
def main():
    try:
        ctypes.CDLL('libX11.so').XInitThreads()
    except:
        pass
    threading.current_thread().name = 'MainThread'
    try:
        redirect_flag = not __debug__
        app = MainApp(redirect_flag)
        app.MainLoop()
    except SystemExit:
        sys.exit(0)

if __name__ == '__main__':
    main()
